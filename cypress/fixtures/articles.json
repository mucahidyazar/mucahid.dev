[
  {
    "title": "Test - WEB APIs - URL",
    "pubDate": "2022-01-14 19:02:23",
    "link": "https://mucahidyazar.medium.com/web-apis-url-e2d129b93d4c?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/e2d129b93d4c",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/761/0*NPkuyZEpAfabhBpm.png",
    "description": "\n<p>Uzun bir aradan sonra tekrardan herkese esenlikler. Hepinize güzel, verimli bir 2022 yılı diliyorum. Bugün URL API ını inceleyeceğiz. Keyifli okumalar diyerek sizleri direkt konuya bırakıyorum.</p>\n<p><strong>URL</strong> API arayüzü, urllerimizi parse, construct, normalize, and encode <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/URL\">e</a>tmek için kullanılır. URL komponentini bu şekilde kolaylıkla okuyabilir ve düzenleyebiliriz. Aşağıdaki step by step örnekle bunu çok daha iyi anlayacağız. Eğer URL arayüzünü browserınız desteklemiyorsa window arayüzünün URL propertysi ilede bunu yapabilirsiniz.</p>\n<h3>Get Started</h3>\n<p>Baslarken ilk olarak bir URL in yapısı nasıl, gelin onu öğrenelim. Aşağıdaki resim bunu bize gayet açık bir şekilde anlatıyor ve gösteriyor.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/761/0*NPkuyZEpAfabhBpm.png\"></figure><h4>new URL(‘urlLink’)</h4>\n<pre>new URL(‘<a href=\"https://medium.com/\">https://example.com/</a>’)</pre>\n<p>Buradaki gibi URL tanımı yapabilir ve bunu aşağıdaki gibi bir değişkene atayabiliriz.</p>\n<pre>let x = new URL(‘<a href=\"https://medium.com/\">https://example.com/</a>’)</pre>\n<p>Ve istersek bu değişkenden aşağıdaki gibi URL imizi çekip çıkartabiliriz.</p>\n<pre>x.toString() // <a href=\"https://example.com/\">https://example.com</a></pre>\n<h4>.searchParams.append(‘key’, ‘value’)</h4>\n<p>Veya param ve queryler ekleyebiliriz.</p>\n<pre>x.searchParams.append(‘category’, ‘electronic’)<br>x.toString() // <a href=\"https://example.com/\">https://example.com</a>/?category=electronic<br>x.searchPArams.append(‘sort’, ‘top’)<br>x.toString() // <a href=\"https://example.com/\">https://example.com</a>/?category=electronic&amp;sort=top</pre>\n<h4>.href</h4>\n<p>Veya bunu .href ile de yapabiliriz aşağıdaki gibi</p>\n<pre>x.href // <a href=\"https://example.com/\">https://example.com</a>/?category=electronic&amp;sort=top</pre>\n<h4>.host</h4>\n<p>Veya istersek aşağıdaki gibi host yani asıl domain adını direkt alabiliriz.</p>\n<pre>x.host // example.com</pre>\n<h4>.origin</h4>\n<p>Veya url’in scheme, domain ve portunu sadece istiyorsak origin ile bunu aşağıdaki gibi basitçe halledebiliriz. Biz ilk tanımlarken bir port vermediğimiz için URL imize bizde port gözükmeyecektir tabi ki.</p>\n<pre>x.origin // <a href=\"https://example.com/\">https://example.com</a></pre>\n<h4>.username &amp; .password</h4>\n<p>URL imize aşağıdaki gibi <strong>username password </strong>bilgileri ayarlayabiliriz, atayabiliriz.</p>\n<pre>x.username = ‘test’<br>x.username // test<br>x.href // <a href=\"https://example.com/\">https://test:@example.com</a>/?category=electronic&amp;sort=top<br>x.password = ‘12345’<br>x.password // 12345<br>x.href // <a href=\"https://example.com/\">https://test:12345@example.com</a>/?category=electronic&amp;sort=top</pre>\n<p>Veya aşağıdaki gibi direkt tanımlayarakda URL imizi oluşturabiliriz.</p>\n<pre>const url = new URL('https://anonymous:flabada@example.com');<br>console.log(url.password) // Logs \"flabada\"</pre>\n<h4>.pathname</h4>\n<p><strong>pathname </strong>lerimizide direkt ayarlayabilir, atayabiliriz aşağıdaki gibi.</p>\n<pre>x.pathname = ‘ankara’<br>x.pathname // ankara<br>x.href // <a href=\"https://example.com/\">https://test:12345@example.com</a>/ankara?category=electronic&amp;sort=top</pre>\n<h4><strong>.port</strong></h4>\n<p>Port larımızda aynı pathnamelerimiz gibi ayarlanabilir ve atanabilir.</p>\n<pre>x.port= ‘3000’<br>x.port // 3000<br>x.href // <a href=\"https://example.com/\">https://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=top</pre>\n<h4>.protocol</h4>\n<p>URL imizin protocolunun ne olduğunuda .<strong>protocol </strong>property si ile öğrenebiliriz. <strong>:</strong> işareti de dahil aşağıdaki gibi.</p>\n<pre>x.protocol= ‘https:’</pre>\n<p>Ve bunu da aslında manipule edebilir ve değiştirebiliriz, diğer properties lerde olduğu gibi.</p>\n<pre>x.protocol= ‘http:’<br>x.protocol // 'http:'<br>x.href // <a href=\"https://example.com/\">http://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=top</pre>\n<h4>.search</h4>\n<p>URL imizdeki ? ile başlayarak bütün parametrelerin stringini döner bize. Diğer property ler gibi buda değiştirilebilir.</p>\n<pre>x.search = ‘?category=electronic&amp;sort=top’<br>x.search// '?category=electronic&amp;sort=popular'<br>x.href // <a href=\"https://example.com/\">http://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=popular</pre>\n<h3>METHODS</h3>\n<h4>.toString() &amp; .toJSON()</h4>\n<p>.href property si gibi bütün URL i verir bize bu ikisi. Fakat ikisi de yeniden assign edilemez, yeniden value atanamaz diyebiliriz fark olarak.</p>\n<pre>x.toString() = <a href=\"https://example.com/\">http://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=popular<br>x.toJSON() = <a href=\"https://example.com/\">http://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=popular</pre>\n<h3>STATIC METHODS</h3>\n<h4>URL.createObjectURL(object, options)</h4>\n<p>Belirli bir object için URL oluşturur.</p>\n<p><strong>object </strong>URL ihtiyacı olan bir değerdir. Genellikle bir input diyebiliriz.</p>\n<pre><strong>var url = URL.createObjectURL(inputElement.files[0]);<br>imgElement.src = url;</strong></pre>\n<pre><strong>URL.createObjectURL(object, options);</strong></pre>\n<p><strong>options </strong>ise bu oluşturduğumuz URL objecti için bir ayarlar kısmıdir. Mesela aşağıda <strong>oneTimeOnly </strong>optionsunu vererek bu URL değişkeninin aslında <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\"><strong>revokeObjectURL</strong></a><strong> </strong>e ihtiyacı olmadığını çünkü sadece 1 defa kullanılacağını söyleriz.</p>\n<pre><strong>oURL = URL.createObjectURL(file, {oneTimeOnly: true});</strong></pre>\n<h4>URL.revokeObjectURL(Object)</h4>\n<p>URL.createObjectURL ile oluşturulmuş URL leri revoke etme işlemini bu static method ile yaparız.</p>\n<h3>KAYNAKLAR</h3>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL\">https://developer.mozilla.org/en-US/docs/Web/API/URL</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e2d129b93d4c\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>Uzun bir aradan sonra tekrardan herkese esenlikler. Hepinize güzel, verimli bir 2022 yılı diliyorum. Bugün URL API ını inceleyeceğiz. Keyifli okumalar diyerek sizleri direkt konuya bırakıyorum.</p>\n<p><strong>URL</strong> API arayüzü, urllerimizi parse, construct, normalize, and encode <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/URL\">e</a>tmek için kullanılır. URL komponentini bu şekilde kolaylıkla okuyabilir ve düzenleyebiliriz. Aşağıdaki step by step örnekle bunu çok daha iyi anlayacağız. Eğer URL arayüzünü browserınız desteklemiyorsa window arayüzünün URL propertysi ilede bunu yapabilirsiniz.</p>\n<h3>Get Started</h3>\n<p>Baslarken ilk olarak bir URL in yapısı nasıl, gelin onu öğrenelim. Aşağıdaki resim bunu bize gayet açık bir şekilde anlatıyor ve gösteriyor.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/761/0*NPkuyZEpAfabhBpm.png\"></figure><h4>new URL(‘urlLink’)</h4>\n<pre>new URL(‘<a href=\"https://medium.com/\">https://example.com/</a>’)</pre>\n<p>Buradaki gibi URL tanımı yapabilir ve bunu aşağıdaki gibi bir değişkene atayabiliriz.</p>\n<pre>let x = new URL(‘<a href=\"https://medium.com/\">https://example.com/</a>’)</pre>\n<p>Ve istersek bu değişkenden aşağıdaki gibi URL imizi çekip çıkartabiliriz.</p>\n<pre>x.toString() // <a href=\"https://example.com/\">https://example.com</a></pre>\n<h4>.searchParams.append(‘key’, ‘value’)</h4>\n<p>Veya param ve queryler ekleyebiliriz.</p>\n<pre>x.searchParams.append(‘category’, ‘electronic’)<br>x.toString() // <a href=\"https://example.com/\">https://example.com</a>/?category=electronic<br>x.searchPArams.append(‘sort’, ‘top’)<br>x.toString() // <a href=\"https://example.com/\">https://example.com</a>/?category=electronic&amp;sort=top</pre>\n<h4>.href</h4>\n<p>Veya bunu .href ile de yapabiliriz aşağıdaki gibi</p>\n<pre>x.href // <a href=\"https://example.com/\">https://example.com</a>/?category=electronic&amp;sort=top</pre>\n<h4>.host</h4>\n<p>Veya istersek aşağıdaki gibi host yani asıl domain adını direkt alabiliriz.</p>\n<pre>x.host // example.com</pre>\n<h4>.origin</h4>\n<p>Veya url’in scheme, domain ve portunu sadece istiyorsak origin ile bunu aşağıdaki gibi basitçe halledebiliriz. Biz ilk tanımlarken bir port vermediğimiz için URL imize bizde port gözükmeyecektir tabi ki.</p>\n<pre>x.origin // <a href=\"https://example.com/\">https://example.com</a></pre>\n<h4>.username &amp; .password</h4>\n<p>URL imize aşağıdaki gibi <strong>username password </strong>bilgileri ayarlayabiliriz, atayabiliriz.</p>\n<pre>x.username = ‘test’<br>x.username // test<br>x.href // <a href=\"https://example.com/\">https://test:@example.com</a>/?category=electronic&amp;sort=top<br>x.password = ‘12345’<br>x.password // 12345<br>x.href // <a href=\"https://example.com/\">https://test:12345@example.com</a>/?category=electronic&amp;sort=top</pre>\n<p>Veya aşağıdaki gibi direkt tanımlayarakda URL imizi oluşturabiliriz.</p>\n<pre>const url = new URL('https://anonymous:flabada@example.com');<br>console.log(url.password) // Logs \"flabada\"</pre>\n<h4>.pathname</h4>\n<p><strong>pathname </strong>lerimizide direkt ayarlayabilir, atayabiliriz aşağıdaki gibi.</p>\n<pre>x.pathname = ‘ankara’<br>x.pathname // ankara<br>x.href // <a href=\"https://example.com/\">https://test:12345@example.com</a>/ankara?category=electronic&amp;sort=top</pre>\n<h4><strong>.port</strong></h4>\n<p>Port larımızda aynı pathnamelerimiz gibi ayarlanabilir ve atanabilir.</p>\n<pre>x.port= ‘3000’<br>x.port // 3000<br>x.href // <a href=\"https://example.com/\">https://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=top</pre>\n<h4>.protocol</h4>\n<p>URL imizin protocolunun ne olduğunuda .<strong>protocol </strong>property si ile öğrenebiliriz. <strong>:</strong> işareti de dahil aşağıdaki gibi.</p>\n<pre>x.protocol= ‘https:’</pre>\n<p>Ve bunu da aslında manipule edebilir ve değiştirebiliriz, diğer properties lerde olduğu gibi.</p>\n<pre>x.protocol= ‘http:’<br>x.protocol // 'http:'<br>x.href // <a href=\"https://example.com/\">http://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=top</pre>\n<h4>.search</h4>\n<p>URL imizdeki ? ile başlayarak bütün parametrelerin stringini döner bize. Diğer property ler gibi buda değiştirilebilir.</p>\n<pre>x.search = ‘?category=electronic&amp;sort=top’<br>x.search// '?category=electronic&amp;sort=popular'<br>x.href // <a href=\"https://example.com/\">http://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=popular</pre>\n<h3>METHODS</h3>\n<h4>.toString() &amp; .toJSON()</h4>\n<p>.href property si gibi bütün URL i verir bize bu ikisi. Fakat ikisi de yeniden assign edilemez, yeniden value atanamaz diyebiliriz fark olarak.</p>\n<pre>x.toString() = <a href=\"https://example.com/\">http://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=popular<br>x.toJSON() = <a href=\"https://example.com/\">http://test:12345@example.com</a>:3000/ankara?category=electronic&amp;sort=popular</pre>\n<h3>STATIC METHODS</h3>\n<h4>URL.createObjectURL(object, options)</h4>\n<p>Belirli bir object için URL oluşturur.</p>\n<p><strong>object </strong>URL ihtiyacı olan bir değerdir. Genellikle bir input diyebiliriz.</p>\n<pre><strong>var url = URL.createObjectURL(inputElement.files[0]);<br>imgElement.src = url;</strong></pre>\n<pre><strong>URL.createObjectURL(object, options);</strong></pre>\n<p><strong>options </strong>ise bu oluşturduğumuz URL objecti için bir ayarlar kısmıdir. Mesela aşağıda <strong>oneTimeOnly </strong>optionsunu vererek bu URL değişkeninin aslında <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\"><strong>revokeObjectURL</strong></a><strong> </strong>e ihtiyacı olmadığını çünkü sadece 1 defa kullanılacağını söyleriz.</p>\n<pre><strong>oURL = URL.createObjectURL(file, {oneTimeOnly: true});</strong></pre>\n<h4>URL.revokeObjectURL(Object)</h4>\n<p>URL.createObjectURL ile oluşturulmuş URL leri revoke etme işlemini bu static method ile yaparız.</p>\n<h3>KAYNAKLAR</h3>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL\">https://developer.mozilla.org/en-US/docs/Web/API/URL</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e2d129b93d4c\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["links", "api", "url", "javascript", "tutorial"],
    "slug": "e2d129b93d4c"
  },
  {
    "title": "Test - Creating a UI Library &amp; Github Actions &amp; Rules, Tests and Version Management",
    "pubDate": "2021-08-06 10:25:32",
    "link": "https://mucahidyazar.medium.com/creating-a-ui-library-github-actions-rules-tests-and-version-management-3d18a41e3e27?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/3d18a41e3e27",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*9tZJmq1VYTIdble0ZgeZRQ.png",
    "description": "\n<p>Son 1 aydır npm paketleri ve buradaki yönetim ve best practiselerle alakalı okumalar ve denemeler yapıyordum. Hatta bunları yaparken bir tanede kendime ait icomoon-generator adında bir libraryde geliştirdim. Bu librarynin ne iş yaptığına niye oluşturduğuma daha sonra değineceğim. Fakat şimdi gördüğüm, öğrendiğim ve çalıştığım bu şeyleri uygulanan best practiselerle birlikte burada size anlatmaya çalışacağım.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9tZJmq1VYTIdble0ZgeZRQ.png\"></figure><h3><strong>What will we see?</strong></h3>\n<p><strong>1. Create a Github Repo<br>2. Creating the Project<br>3. Storybook<br>4. Prettier<br>5. Eslint<br>6. Button Components with Typescript<br>7. styled-components<br>8. prop-types<br>9. API Design<br>10. Composition API<br>11. Tests (jest Settings)<br>12. Tests (@testing-library/react Settings)<br>13. Tests<br>14. Module Formats<br>15. Typescript Declarations<br>16. husky<br>17. semantic-release<br>18. Github Environment Variable<br>19. Github Actions</strong></p>\n<h3>Get Started</h3>\n<h4>Step 1: Create a Github Repo</h4>\n<p>Github üzerinde ui-library adında bir repository oluşturdum. Ve oluştururken .gitignore ve Readme.md dosyalarınıda eklemesini istiyorum.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/749/1*pH6H3mVpnymO7zx6ytYtUg.jpeg\"></figure><h4>Step 2: Creating the Project</h4>\n<p>npx create-react-app ui-library — template typescript</p>\n<p>Yukarıda ki kodu çalıştırarak create-react-app ile typescriptli bir react projesi oluşturuyoruz.</p>\n<p>Sonra oluşturduğumuz github reposu ile bu oluşturduğumuz projeyi senkronize ediyoruz. Sonra da aşağıdaki gibi package.json dosyamızı kendimize ve oluşturduğumuz repositorye göre bilgilerini düzenliyoruz.</p>\n<a href=\"https://medium.com/media/4317426eb7cc26a2ee98a3789641af29/href\">https://medium.com/media/4317426eb7cc26a2ee98a3789641af29/href</a><p>Daha sonra root dizinimize aşağıda ki “tsconfig.json” dosyasını ekliyoruz.</p>\n<a href=\"https://medium.com/media/e8745d33f1f279381458c029e3cd6060/href\">https://medium.com/media/e8745d33f1f279381458c029e3cd6060/href</a><p>Sonra aşağıda ki gibi file-structure oluşturduktan sonra,</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/150/1*bnxz4xRvRm2dDbo5omNTjQ.png\"></figure><p>“Button” componentımı oluşturuyorum.</p>\n<a href=\"https://medium.com/media/7dbdf1af63c8544f69daf25683f30676/href\">https://medium.com/media/7dbdf1af63c8544f69daf25683f30676/href</a><a href=\"https://medium.com/media/5f08b730415ea268672f450b85e76cdc/href\">https://medium.com/media/5f08b730415ea268672f450b85e76cdc/href</a><a href=\"https://medium.com/media/a3d996f1a96317c483e123bdc2a1bbe6/href\">https://medium.com/media/a3d996f1a96317c483e123bdc2a1bbe6/href</a><h4>Step 3: Storybook</h4>\n<p>Ve şimdi de Storybook entegrasyonumuzu yapacağız. Bunun içni tek yapmamız gereken aşağıda ki kodu çalıştırarak projemize storybook’u entegre etmek.</p>\n<p>npx sb init</p>\n<p>Kurulumla birlikte gelen “stories” klasörünü proje dışındaki bir dizine taşıyın veya silin. Taşırsanız daha sonra bu örneklere bakıp kopyalar çekebilirsiniz veya direk silip documentationlarlada ilerleyebilirsiniz.</p>\n<p>Sonra “stories” klasorüne gelip “introduction.stories.mdx” adında dosya oluşturuyoruz ve aşağıdakileri içine yapıştırıyoruz.</p>\n<p>import { Meta, Description } from ‘@storybook/addon-docs/blocks’;<br>import README from ‘../../README.md’;<br>&lt;Meta title=”Example/Introduction” /&gt;<br>&lt;Description&gt;{README}&lt;/Description&gt;</p>\n<p>Ve daha sonra “Button.stories.tsx” story dosyasını oluşturup aşağıda ki kod blogunu ekliyoruz.</p>\n<a href=\"https://medium.com/media/1ff5721485859179538e8739cf354441/href\">https://medium.com/media/1ff5721485859179538e8739cf354441/href</a><p>Bu yüklemelerden sonra hata alırsanız .storybook dosyasındaki main.js e gelip aşağıda ki typescript blogunu ekleyin.</p>\n<a href=\"https://medium.com/media/771d50804bf463bdbc6af9f28dd0c2db/href\">https://medium.com/media/771d50804bf463bdbc6af9f28dd0c2db/href</a><h4>Step 4: Prettier</h4>\n<p>İlk önce prettieri aşağıdaki gibi yüklüyoruz.</p>\n<p>yarn add -D prettier</p>\n<p>Ve .prettierrc.json adında dosya oluşturup aşağıdaki bir tane ayarı ekliyorum. Siz daha fazla prettier ayarı burada projeniz için ayarlayabilirsiniz tabi ki de.</p>\n<a href=\"https://medium.com/media/9ef175d0c84bb36ab7756c4c5f4826c6/href\">https://medium.com/media/9ef175d0c84bb36ab7756c4c5f4826c6/href</a><p>Ve package.jsona gelip aşağıda ki 2 tane scripti ekliyoruz. Bunlar;</p>\n<p>- format, prettiere göre dosyaların formatlanmasını düzeltilmesini sağlıyoruz.<br>- lint:format, herşeyin bu formatta olduğunun teyitini yapıyoruz.</p>\n<a href=\"https://medium.com/media/c16d200883838179e5a5bf2751fc14eb/href\">https://medium.com/media/c16d200883838179e5a5bf2751fc14eb/href</a><h4>Step 5: Eslint</h4>\n<p>Eslint ilede javascript yazım kurallarını set edeceğiz. Aşağıdaki paketleri öncelikle yüklüyoruz.</p>\n<p>npm install — save-dev eslint eslint-config-prettier eslint-plugin-jest eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser</p>\n<p>or</p>\n<p>yarn add -D eslint eslint-config-prettier eslint-plugin-jest eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser</p>\n<p>Sonra <strong>“.eslintrc”</strong> adında bir dosya oluşturup içine aşağıdakileri yapıştırıyoruz.</p>\n<a href=\"https://medium.com/media/acdc5875e94663acd02964eaa0ea53e8/href\">https://medium.com/media/acdc5875e94663acd02964eaa0ea53e8/href</a><p>Bu config dosyası;</p>\n<p>-root, config dosyasının, root config dosyası olduğunu söyler.<br>-parser, typescriptli eslint rulelarını parse etmesini söyler.<br>-recommend edilen eslint ayarları tanımlanır. <br>-react ve react hookslarının eslint recommended kuralları set edilir.<br>-prettier için eslint ayarlarını set eder.</p>\n<p>Bu eslint kuralları typescriptlerle componentlarımızı tanımlamamızı zorunlu tutacağı için, Button componentımı aşağıda ki gibi düzenliyorum.</p>\n<a href=\"https://medium.com/media/1b67fdb6a088c9b9f6ffdfd3c854bec4/href\">https://medium.com/media/1b67fdb6a088c9b9f6ffdfd3c854bec4/href</a><p>Aşağıda da <strong>“lint”</strong> adında yeni bir script tanımlarız. Böylece eslint ile ayarladığımız ayarlarla yazdığımız javascript kolarının kurallara uyup uymadığınız denetleriz.</p>\n<a href=\"https://medium.com/media/36b914cd98783a1bfba72f775341f8d2/href\">https://medium.com/media/36b914cd98783a1bfba72f775341f8d2/href</a><h4>Step 6: Button Components with Typescript</h4>\n<p>Şimdi de kütüphanemizin ilk gerçek parçası Button componentını gerçek olarak oluşturalım.</p>\n<p>Button componentımızı React.forwardRef ile sarıyoruz ve generator olarak HTMLButtonElement veriyoruz ve bu buradaki elementin bir HTMLButtonElementi olacağını söylüyor ve 2. Argument olarak da bu generatore propslarin alması gereken attribute kuralları vererek propsları sınırlıyoruz ve onu da React.ComponentsPropsWithoutRef ile &lt;’button’&gt; olmasını söylüyoruz.</p>\n<a href=\"https://medium.com/media/732c82394e17bc543817840385545028/href\">https://medium.com/media/732c82394e17bc543817840385545028/href</a><h4>Step 7: styled-components</h4>\n<p>Componentlarımızı oluşturmak içinde styled-components kütüphanesinden faydalanacağımız için aşağıdaki kodla öncelikle yüklüyoruz.</p>\n<p>yarn add -D styled-components @types/styled-components polished<br>or<br>npm install --save-dev styled-components @types/styled-components polished</p>\n<p>Sonra src altında utils adında klasör oluşturup içinde de, colors.ts veya styles.ts adında dosyalarımızı oluşturup, aşağıda ki değişkenleri tanımlıyoruz.</p>\n<a href=\"https://medium.com/media/038878892f569253836e549f35dc333c/href\">https://medium.com/media/038878892f569253836e549f35dc333c/href</a><p>Daha sonra Button.tsx klasörüne gelip yukarıda ki style.ts dosyasını tanımlıyoruz ve bu butonu export ediyoruz ve Button.tsx içinde kullanıyoruz.</p>\n<a href=\"https://medium.com/media/806b89576d0ba2d6d2ea750beef5bdc5/href\">https://medium.com/media/806b89576d0ba2d6d2ea750beef5bdc5/href</a><p>Daha sonra Button.tsx dosyamız da style.ts den gelen styled-component ile oluşturduğum Button değişkenini component gibi kullanıyorum ve defaultProps tanımlıyorum.</p>\n<a href=\"https://medium.com/media/0372f8106b8ab4554116234447cb1b36/href\">https://medium.com/media/0372f8106b8ab4554116234447cb1b36/href</a><h4>Step 8: prop-types</h4>\n<p>Prop kontrollerini aslında typescript ile zaten yapıyoruz ama birde ekstra bir kütüphane ile de yapabiliyoruz. Biz bunu da ekstradan propsları kurallandırmak, sınırlandırmak için kullanacağız. Önce aşağıdaki gibi modülü yüklüyoruz.</p>\n<p>npm install --save-dev prop-types<br>or<br>yarn add -D prop-types</p>\n<a href=\"https://medium.com/media/20eb1aeb6f17bf7bf1deb2fca34feab5/href\">https://medium.com/media/20eb1aeb6f17bf7bf1deb2fca34feab5/href</a><h4>Step 9: API Design</h4>\n<p>UI librarylerinde 2 farklı API design, tasarım şekli vardır. Birisi Traditional API yani Geleneksel API, bir diğeri Compound API yani Bileşik API. Bunlar arasında ki farklar aşağıda ki gibidir.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*saaWKKfKtUaMCxnQa4_UWg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*c_WpyFCgnEh4erJMorUerA.png\"></figure><h4>Step 10: Composition API</h4>\n<p>Yeni nesil UI libraryleri genellikle bu yöntemi kullanmayı tercih ederler. Bu yöntem hem daha kontrol edilebilir hem de daha esnektir kullanım açısından.</p>\n<p>İlk önce src altında “Field” adında bir klasör ve içinde bir style.ts dosyası oluşturup aşağıda ki kodları içinde tanımlıyoruz.</p>\n<a href=\"https://medium.com/media/a3e5c0ffcb3addb3ab51c16ea2203fb1/href\">https://medium.com/media/a3e5c0ffcb3addb3ab51c16ea2203fb1/href</a><p>Daha sonra bu <strong>“Field”</strong> klasörü içinde “FieldContext” adın da bir context tutacağız. Burada createContext hooksu ile context oluşturup form alanlarında bu contextProviderını kullanacağız.</p>\n<a href=\"https://medium.com/media/d770c9eec2eb157bbdb9a8fde841ca17/href\">https://medium.com/media/d770c9eec2eb157bbdb9a8fde841ca17/href</a><p>Ve ayrıca bir altta ki “Field” componentımızda kullanacağımız unique id utilsini, utils klasörü altında useUniqueID.ts dosyası içinde aşağıdaki gibi oluşturuyoruz. Tabi önce bunu yapmamızı sağlayacak olan nanoid librarysini yüklüyoruz.</p>\n<p>npm install --save-dev nanoid<br>or<br>yard add -D nanoid</p>\n<a href=\"https://medium.com/media/d6f04186f5bec463330d8aaf87a7cedc/href\">https://medium.com/media/d6f04186f5bec463330d8aaf87a7cedc/href</a><p>Daha sonra yukarıda ki “ContextProvider”ı “Input”, “Label” gibi alanlari içine koyacağımız bir “Field.tsx” tanımlayacağız.</p>\n<a href=\"https://medium.com/media/fbe05d9c9a43c86c835430a25173a866/href\">https://medium.com/media/fbe05d9c9a43c86c835430a25173a866/href</a><p>Daha sonra “Input” ve “Label” componentlarımızı oluşturacağız.</p>\n<a href=\"https://medium.com/media/cf3663f3fccbd533265f21971d5f338b/href\">https://medium.com/media/cf3663f3fccbd533265f21971d5f338b/href</a><a href=\"https://medium.com/media/0909d2396763eb27fcdf6ea1dac2a344/href\">https://medium.com/media/0909d2396763eb27fcdf6ea1dac2a344/href</a><p>Daha sonra “Input.stories.tsx” adında yeni bir story dosyası oluşturup asağıda ki gibi “Field” ve içine gömdüğümüz “Input” ve “Label”ı çağırarak burada kullanabiliyor olacağız.</p>\n<a href=\"https://medium.com/media/a557a3e077e869bd8f572fda5bc65183/href\">https://medium.com/media/a557a3e077e869bd8f572fda5bc65183/href</a><p>Ve son olarak da gelin yine Field klasörü altında bir diğer form elemanımız Textarea componentimizi oluşturalım.</p>\n<a href=\"https://medium.com/media/fe59d67fa34511967de6b38218d4c17e/href\">https://medium.com/media/fe59d67fa34511967de6b38218d4c17e/href</a><p>Field.tsx dosyamızda da gerekli alanlara aşağdıa ki gibi Textarea’ı ekliyoruz.</p>\n<a href=\"https://medium.com/media/df7b6271bfdf908d9512a8a7eca7673b/href\">https://medium.com/media/df7b6271bfdf908d9512a8a7eca7673b/href</a><p>Ve son olarak da Textarea.stories.tsx dosyasını oluşturup aşağıda ki kodları gönderiyoruz.</p>\n<a href=\"https://medium.com/media/48d39e0b1794b3d403aca4b5b70e43b3/href\">https://medium.com/media/48d39e0b1794b3d403aca4b5b70e43b3/href</a><p>Ve artık Button ve Form bileşenlerine sahip bir UI kütüphanemiz hazır diyebiliriz :)</p>\n<h4>Step 11: Tests (Jest Settings)</h4>\n<p>İlk önce gerekli kurulumları aşağıda ki gibi yapıyoruz.</p>\n<p>npm install --save-dev jest ts-jest @types/jest react-is<br>or<br>yarn add -D jest ts-jest @types/jest react-is</p>\n<p>Daha sonra packaga.json içinde test adında bir script oluşturacağız aşağıda ki gibi. Şuana kadar olan tüm scriptlerimizde bu kadar zaten.</p>\n<a href=\"https://medium.com/media/97ac7bb56b3a9ad05238b84e6f921b41/href\">https://medium.com/media/97ac7bb56b3a9ad05238b84e6f921b41/href</a><p>Daha sonra root dizininde jest.config.js adıdna dosya oluşturup aşağıda ki ayarları içine yazıyoruz.</p>\n<a href=\"https://medium.com/media/f7c2aadd4e2933857941b09e5fd9f507/href\">https://medium.com/media/f7c2aadd4e2933857941b09e5fd9f507/href</a><h4>Step 12: Tests (@testing-library/react Settings)</h4>\n<p>Yine aşağıda ki kurulumları ilk olarak gerçekleştiriyoruz.</p>\n<p><strong>npm install --save-dev @testing-library/react @testing-library/jest-dom<br></strong>or<br><strong>yarn add -D @testing-library/react @testing-library/jest-dom</strong></p>\n<p>Daha sonra <strong>“jest-setup.ts”</strong> adında dosya oluşturup aşağıda ki 2 importu içine gönderiyoruz. Bunlarda react testleri için styled-component uyumluluğunu ve react için jest-dom’u aktif ediyor bizim için.</p>\n<a href=\"https://medium.com/media/8f6e60f1aec818286c6a749e5b00587a/href\">https://medium.com/media/8f6e60f1aec818286c6a749e5b00587a/href</a><p>tsconfig.json içine de eğer ekli değilse aşağıdaki satırı ekliyoruz.<br><strong> “include”: [“src/**/*”, “./jest-setup.ts”]</strong></p>\n<h4>Step 13: Tests</h4>\n<p>Daha sonra yeri size kalmış ama ben Button component klasörü içinde Button.spec.ts adında bir dosya oluşturup Button componentimizin testlerini yapıyoruz.</p>\n<a href=\"https://medium.com/media/14eb0fce15f5675e2d95cd9274c661af/href\">https://medium.com/media/14eb0fce15f5675e2d95cd9274c661af/href</a><p>Field testleri için useUniqueID adında bir mock utilse ihtiyacım olacağı için aşağıda ki gibi utils klasörü altında, __mocks__ klasörü oluşturup içinde <strong>“useUniqueID.ts”</strong> adında dosya oluşturup aşağıdaki mock utili oluşturuyorum.</p>\n<a href=\"https://medium.com/media/fe9b180171bd904d31ef3e881af0b949/href\">https://medium.com/media/fe9b180171bd904d31ef3e881af0b949/href</a><p>Daha sonrada <strong>“Field.spec.ts”</strong> adında test dosyamızı oluşturup aşağıda ki testleri yazıyoruz.</p>\n<a href=\"https://medium.com/media/abe1e1c9b05f5755a5f42d06befb59f3/href\">https://medium.com/media/abe1e1c9b05f5755a5f42d06befb59f3/href</a><h4>Step 14: Module Formats</h4>\n<p>Bu aşamada ise oluşturduğumuz ui librarymizi babel ve @rollup librarylerini kullanıp compressleyip dist çıktısını alacağız.</p>\n<p>Önce aşağıdaki gerekli libraryleri kuruyoruz.</p>\n<p>npm install @babel/runtime<br>npm install --save-dev @babel/preset-env @babel/preset-typescript @babel/preset-react @babel/plugin-transform-runtime babel-plugin-styled-components<br>or<br>yarn add @babel/runtime<br>yarn add -D @babel/preset-env @babel/preset-typescript @babel/preset-react @babel/plugin-transform-runtime babel-plugin-styled-components</p>\n<p>Şimdide .babelrc dosyası oluşturup aşağıda ki kodları yapıştırıyoruz.</p>\n<a href=\"https://medium.com/media/b781a3d505293316b7437ff4d2dc94df/href\">https://medium.com/media/b781a3d505293316b7437ff4d2dc94df/href</a><p>Ve şimdide rollup paketlerini yüklüyoruz. Bunlar build timeda kullanılacak paketler olduğu için devDependencies olarak ekleyebiliriz.</p>\n<p>npm install --save-dev rollup rollup-plugin-delete rollup-plugin-node-externals @rollup/plugin-babel @rollup/plugin-commonjs @rollup/plugin-node-resolve<br>or<br>yarn add -D rollup rollup-plugin-delete rollup-plugin-node-externals @rollup/plugin-babel @rollup/plugin-commonjs @rollup/plugin-node-resolve</p>\n<p>Ve rollup.config.js dosyası oluşturup aşağıda ki ayarları yerleştiriyoruz.</p>\n<a href=\"https://medium.com/media/1e9df70ebdf9aa57113bfd494731724b/href\">https://medium.com/media/1e9df70ebdf9aa57113bfd494731724b/href</a><h4><strong>Step 15: Typescript Declarations</strong></h4>\n<p>Daha sonra tsconfig.build.json ayarlarımızı aşağıda ki gibi yapıyoruz.</p>\n<p>Bu tanımlamalarla da index.d.ts gibi typescript rulelarını set eden dosyaları build olarak dist çıktı klasörümüze kopya olarak alacağız.</p>\n<p>Daha sonra <strong>“/root/src”</strong> altında <strong>“index.ts”</strong> dosyası oluşturup bundle edilecek tüm dosyaları burada export ediyoruz.</p>\n<a href=\"https://medium.com/media/b3cfbbcc58d4dfd9c78022e4e05f5d80/href\">https://medium.com/media/b3cfbbcc58d4dfd9c78022e4e05f5d80/href</a><p>Daha sonra package.json dosyamıza aşağıdaki “main”, “module” ve “sideEffects” kısımlarınıda ekliyoruz ve scriptlerimizin son halide aşağıda ki gibidir.</p>\n<a href=\"https://medium.com/media/0136ea5ef312f5e162c8a0bb2720f7e2/href\">https://medium.com/media/0136ea5ef312f5e162c8a0bb2720f7e2/href</a><p>Ve daha sonra aşağıda ki kodları sırayla çalıştırıp kontrol edip buildi aldığımızı görüyoruz.</p>\n<p>npm run format<br>npm run format:lint<br>npm run build</p>\n<h4>Step 16: husky</h4>\n<p>Husky ile ise githuba commit göndermeden veya pushlamadan önceki çalışması gereken actionları komut olarak vereceğiz. Örneğin her commit önceki eslint checki yapmasını istiyorum ve eğer eslint hatası varsa commiti kabul etmesini istemiyorum. İlk önce eslint hatalarını giderdikten sonra tekrar gelip commit atmasını ve tekrar denetleyerek hata yoksa commitini göndermesini istiyorum gibi.</p>\n<p>İlk önce aşağıda ki kodla “husky”i yüklüyoruz.</p>\n<p>npm install husky --save-dev<br>or<br>yarn add -D husky</p>\n<p>Ve daha sorna aşağıda ki kodla git hookslarını aktif ediyoruz.<br>npx husky install</p>\n<p>Kurulumdan sonra git hookslarını otomatik etkinleştirmek içinde aşağıda ki kodu set ediyoruz.<br>npm set-scrpit prepare “husky install”</p>\n<p>Ve şimdi de pre-commit ile commitlerden önce çalıştırılması gereken scriptleri set ediyoruz aşağıda ki gibi.<br>npx husky add .husky/pre-commit “npm run lint &amp;&amp; npm run format:lint &amp;&amp; npm run test”</p>\n<p>Ve şimdide push önceki olan pre-push daki kısmı ayarlıyoruz.</p>\n<p>npx husky add .husky/pre-push “npm run lint &amp;&amp; npm run format:lint &amp;&amp; npm run test”</p>\n<p>Ve bu kadar şimdi değişiklikleri tekrar githuba pushlayabiliriz.</p>\n<h4>Step 17: semantic-release</h4>\n<p>Ve artık son adımlarımızdan birisi olan semantic bir şekilde release çıkmaya geldik diyebiliriz. Burada yapacağımız ayarlarla semantic olarak version ve tag alabileceğiz, change log kayıtlarımız otomatik tutulacak ve commit mesajlarımızı daha düzgün bir şekilde tutabileceğiz.</p>\n<p>İlk önce aşağıda her zaman yaptığımız gibi gerekli libraryleri yüklüyoruz.</p>\n<p>yarn add -D semantic-release <a href=\"http://twitter.com/semantic\">@semantic</a>-release/changelog <a href=\"http://twitter.com/semantic\">@semantic</a>-release/git commitizen cz-conventional-changelog<br>or<br>npm install --save-dev semantic-release <a href=\"http://twitter.com/semantic\">@semantic</a>-release/changelog <a href=\"http://twitter.com/semantic\">@semantic</a>-release/git commitizen cz-conventional-changelog</p>\n<p>Sonra aşağıda ki release, repository alanını ve yeni 2 scriptimizi package.jsona ekleyelim.</p>\n<a href=\"https://medium.com/media/fb81467c9a845adae1cc54acba830c71/href\">https://medium.com/media/fb81467c9a845adae1cc54acba830c71/href</a><p>Artık commitlerimizi git add yaptıktan sorna npm run commit diyerek çalıştırdıktan sonra commitizen packagenin standartlarına göre göndereceğiz. Ve pushladıktan sonra github actionslar semantic-release paketiyle birlikte automation işlemini otomatik olarak yapacak.</p>\n<h4>Step 18: Github Environment Variable</h4>\n<p>Önce Github actionslarında kullanılmak üzere ilk başta NPM_TOKEN adında bir envıronment variable tanımlamamız gerekiyor github repomuza. Bu tokeni almak için npme gidip bir tane auyomation için token oluşturuyoruz ve aşağıdaki gibi oluşturduğumuz ui librarysinin github reposunun ayarlarında ki Secret kısmında, NPM_TOKEN name olacak şekilde npmden aldığımız token ile burada yeni bir environment variable tanımlıyoruz.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*tGzH7s0-wLwt7udp0ziMDA.png\"></figure><p>Github-actionslara geçmeden önce son olarakda ui-library olan package ismimizi unique bir npm package ismi seçerek değiştiriyoruz. Npm kütüphanesine girerek seçtiğiniz paket ismini kontrol edin. Ve privateyide false yapıyoruz çünkü free npm üyeliğiyle private npm packageleri yükleyemiyoruz. Bizimkisi de free olduğu için public bir npm kütüphanesi oluşturuyoruz.</p>\n<a href=\"https://medium.com/media/f669438b417eabdee9a87611714157cf/href\">https://medium.com/media/f669438b417eabdee9a87611714157cf/href</a><h4>Step 19: Github Actions</h4>\n<p>Ve şimdi tüm ayarlarımızı yaptığımıza göre sıra oluşturduğumuz libraryi npme publish etmeye geldi. Npm publish işini github actionslarla otomatik bir şekilde yapacağız. Süreç şu şekilde işleyecek. Biz bir commit gönderdiğimiz de yani githuba push ettiğimiz de githubda aşağıda yazdığımız ci actionu çalışıp npm release ve semantic versioning automationunu bizim için yapacak.</p>\n<p>Bunun için tek yapmamız gereken aşağıdaki dizine release veya istediginiz bir dosya adı .yml şeklinde bir dosya oluşturmak ve aşağdıa ki kodları oraya yazmak. Yorumlu satırdaki test kısmını bilerek bıraktım isterseniz oradaki gibi ikinci bir job daha ekleyip kullanabilirsiniz.<br><strong>/root/.github/workflows/release.yml</strong></p>\n<a href=\"https://medium.com/media/e0fc5b9220dd0709d6b17b9b327c625b/href\">https://medium.com/media/e0fc5b9220dd0709d6b17b9b327c625b/href</a><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3d18a41e3e27\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>Son 1 aydır npm paketleri ve buradaki yönetim ve best practiselerle alakalı okumalar ve denemeler yapıyordum. Hatta bunları yaparken bir tanede kendime ait icomoon-generator adında bir libraryde geliştirdim. Bu librarynin ne iş yaptığına niye oluşturduğuma daha sonra değineceğim. Fakat şimdi gördüğüm, öğrendiğim ve çalıştığım bu şeyleri uygulanan best practiselerle birlikte burada size anlatmaya çalışacağım.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9tZJmq1VYTIdble0ZgeZRQ.png\"></figure><h3><strong>What will we see?</strong></h3>\n<p><strong>1. Create a Github Repo<br>2. Creating the Project<br>3. Storybook<br>4. Prettier<br>5. Eslint<br>6. Button Components with Typescript<br>7. styled-components<br>8. prop-types<br>9. API Design<br>10. Composition API<br>11. Tests (jest Settings)<br>12. Tests (@testing-library/react Settings)<br>13. Tests<br>14. Module Formats<br>15. Typescript Declarations<br>16. husky<br>17. semantic-release<br>18. Github Environment Variable<br>19. Github Actions</strong></p>\n<h3>Get Started</h3>\n<h4>Step 1: Create a Github Repo</h4>\n<p>Github üzerinde ui-library adında bir repository oluşturdum. Ve oluştururken .gitignore ve Readme.md dosyalarınıda eklemesini istiyorum.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/749/1*pH6H3mVpnymO7zx6ytYtUg.jpeg\"></figure><h4>Step 2: Creating the Project</h4>\n<p>npx create-react-app ui-library — template typescript</p>\n<p>Yukarıda ki kodu çalıştırarak create-react-app ile typescriptli bir react projesi oluşturuyoruz.</p>\n<p>Sonra oluşturduğumuz github reposu ile bu oluşturduğumuz projeyi senkronize ediyoruz. Sonra da aşağıdaki gibi package.json dosyamızı kendimize ve oluşturduğumuz repositorye göre bilgilerini düzenliyoruz.</p>\n<a href=\"https://medium.com/media/4317426eb7cc26a2ee98a3789641af29/href\">https://medium.com/media/4317426eb7cc26a2ee98a3789641af29/href</a><p>Daha sonra root dizinimize aşağıda ki “tsconfig.json” dosyasını ekliyoruz.</p>\n<a href=\"https://medium.com/media/e8745d33f1f279381458c029e3cd6060/href\">https://medium.com/media/e8745d33f1f279381458c029e3cd6060/href</a><p>Sonra aşağıda ki gibi file-structure oluşturduktan sonra,</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/150/1*bnxz4xRvRm2dDbo5omNTjQ.png\"></figure><p>“Button” componentımı oluşturuyorum.</p>\n<a href=\"https://medium.com/media/7dbdf1af63c8544f69daf25683f30676/href\">https://medium.com/media/7dbdf1af63c8544f69daf25683f30676/href</a><a href=\"https://medium.com/media/5f08b730415ea268672f450b85e76cdc/href\">https://medium.com/media/5f08b730415ea268672f450b85e76cdc/href</a><a href=\"https://medium.com/media/a3d996f1a96317c483e123bdc2a1bbe6/href\">https://medium.com/media/a3d996f1a96317c483e123bdc2a1bbe6/href</a><h4>Step 3: Storybook</h4>\n<p>Ve şimdi de Storybook entegrasyonumuzu yapacağız. Bunun içni tek yapmamız gereken aşağıda ki kodu çalıştırarak projemize storybook’u entegre etmek.</p>\n<p>npx sb init</p>\n<p>Kurulumla birlikte gelen “stories” klasörünü proje dışındaki bir dizine taşıyın veya silin. Taşırsanız daha sonra bu örneklere bakıp kopyalar çekebilirsiniz veya direk silip documentationlarlada ilerleyebilirsiniz.</p>\n<p>Sonra “stories” klasorüne gelip “introduction.stories.mdx” adında dosya oluşturuyoruz ve aşağıdakileri içine yapıştırıyoruz.</p>\n<p>import { Meta, Description } from ‘@storybook/addon-docs/blocks’;<br>import README from ‘../../README.md’;<br>&lt;Meta title=”Example/Introduction” /&gt;<br>&lt;Description&gt;{README}&lt;/Description&gt;</p>\n<p>Ve daha sonra “Button.stories.tsx” story dosyasını oluşturup aşağıda ki kod blogunu ekliyoruz.</p>\n<a href=\"https://medium.com/media/1ff5721485859179538e8739cf354441/href\">https://medium.com/media/1ff5721485859179538e8739cf354441/href</a><p>Bu yüklemelerden sonra hata alırsanız .storybook dosyasındaki main.js e gelip aşağıda ki typescript blogunu ekleyin.</p>\n<a href=\"https://medium.com/media/771d50804bf463bdbc6af9f28dd0c2db/href\">https://medium.com/media/771d50804bf463bdbc6af9f28dd0c2db/href</a><h4>Step 4: Prettier</h4>\n<p>İlk önce prettieri aşağıdaki gibi yüklüyoruz.</p>\n<p>yarn add -D prettier</p>\n<p>Ve .prettierrc.json adında dosya oluşturup aşağıdaki bir tane ayarı ekliyorum. Siz daha fazla prettier ayarı burada projeniz için ayarlayabilirsiniz tabi ki de.</p>\n<a href=\"https://medium.com/media/9ef175d0c84bb36ab7756c4c5f4826c6/href\">https://medium.com/media/9ef175d0c84bb36ab7756c4c5f4826c6/href</a><p>Ve package.jsona gelip aşağıda ki 2 tane scripti ekliyoruz. Bunlar;</p>\n<p>- format, prettiere göre dosyaların formatlanmasını düzeltilmesini sağlıyoruz.<br>- lint:format, herşeyin bu formatta olduğunun teyitini yapıyoruz.</p>\n<a href=\"https://medium.com/media/c16d200883838179e5a5bf2751fc14eb/href\">https://medium.com/media/c16d200883838179e5a5bf2751fc14eb/href</a><h4>Step 5: Eslint</h4>\n<p>Eslint ilede javascript yazım kurallarını set edeceğiz. Aşağıdaki paketleri öncelikle yüklüyoruz.</p>\n<p>npm install — save-dev eslint eslint-config-prettier eslint-plugin-jest eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser</p>\n<p>or</p>\n<p>yarn add -D eslint eslint-config-prettier eslint-plugin-jest eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser</p>\n<p>Sonra <strong>“.eslintrc”</strong> adında bir dosya oluşturup içine aşağıdakileri yapıştırıyoruz.</p>\n<a href=\"https://medium.com/media/acdc5875e94663acd02964eaa0ea53e8/href\">https://medium.com/media/acdc5875e94663acd02964eaa0ea53e8/href</a><p>Bu config dosyası;</p>\n<p>-root, config dosyasının, root config dosyası olduğunu söyler.<br>-parser, typescriptli eslint rulelarını parse etmesini söyler.<br>-recommend edilen eslint ayarları tanımlanır. <br>-react ve react hookslarının eslint recommended kuralları set edilir.<br>-prettier için eslint ayarlarını set eder.</p>\n<p>Bu eslint kuralları typescriptlerle componentlarımızı tanımlamamızı zorunlu tutacağı için, Button componentımı aşağıda ki gibi düzenliyorum.</p>\n<a href=\"https://medium.com/media/1b67fdb6a088c9b9f6ffdfd3c854bec4/href\">https://medium.com/media/1b67fdb6a088c9b9f6ffdfd3c854bec4/href</a><p>Aşağıda da <strong>“lint”</strong> adında yeni bir script tanımlarız. Böylece eslint ile ayarladığımız ayarlarla yazdığımız javascript kolarının kurallara uyup uymadığınız denetleriz.</p>\n<a href=\"https://medium.com/media/36b914cd98783a1bfba72f775341f8d2/href\">https://medium.com/media/36b914cd98783a1bfba72f775341f8d2/href</a><h4>Step 6: Button Components with Typescript</h4>\n<p>Şimdi de kütüphanemizin ilk gerçek parçası Button componentını gerçek olarak oluşturalım.</p>\n<p>Button componentımızı React.forwardRef ile sarıyoruz ve generator olarak HTMLButtonElement veriyoruz ve bu buradaki elementin bir HTMLButtonElementi olacağını söylüyor ve 2. Argument olarak da bu generatore propslarin alması gereken attribute kuralları vererek propsları sınırlıyoruz ve onu da React.ComponentsPropsWithoutRef ile &lt;’button’&gt; olmasını söylüyoruz.</p>\n<a href=\"https://medium.com/media/732c82394e17bc543817840385545028/href\">https://medium.com/media/732c82394e17bc543817840385545028/href</a><h4>Step 7: styled-components</h4>\n<p>Componentlarımızı oluşturmak içinde styled-components kütüphanesinden faydalanacağımız için aşağıdaki kodla öncelikle yüklüyoruz.</p>\n<p>yarn add -D styled-components @types/styled-components polished<br>or<br>npm install --save-dev styled-components @types/styled-components polished</p>\n<p>Sonra src altında utils adında klasör oluşturup içinde de, colors.ts veya styles.ts adında dosyalarımızı oluşturup, aşağıda ki değişkenleri tanımlıyoruz.</p>\n<a href=\"https://medium.com/media/038878892f569253836e549f35dc333c/href\">https://medium.com/media/038878892f569253836e549f35dc333c/href</a><p>Daha sonra Button.tsx klasörüne gelip yukarıda ki style.ts dosyasını tanımlıyoruz ve bu butonu export ediyoruz ve Button.tsx içinde kullanıyoruz.</p>\n<a href=\"https://medium.com/media/806b89576d0ba2d6d2ea750beef5bdc5/href\">https://medium.com/media/806b89576d0ba2d6d2ea750beef5bdc5/href</a><p>Daha sonra Button.tsx dosyamız da style.ts den gelen styled-component ile oluşturduğum Button değişkenini component gibi kullanıyorum ve defaultProps tanımlıyorum.</p>\n<a href=\"https://medium.com/media/0372f8106b8ab4554116234447cb1b36/href\">https://medium.com/media/0372f8106b8ab4554116234447cb1b36/href</a><h4>Step 8: prop-types</h4>\n<p>Prop kontrollerini aslında typescript ile zaten yapıyoruz ama birde ekstra bir kütüphane ile de yapabiliyoruz. Biz bunu da ekstradan propsları kurallandırmak, sınırlandırmak için kullanacağız. Önce aşağıdaki gibi modülü yüklüyoruz.</p>\n<p>npm install --save-dev prop-types<br>or<br>yarn add -D prop-types</p>\n<a href=\"https://medium.com/media/20eb1aeb6f17bf7bf1deb2fca34feab5/href\">https://medium.com/media/20eb1aeb6f17bf7bf1deb2fca34feab5/href</a><h4>Step 9: API Design</h4>\n<p>UI librarylerinde 2 farklı API design, tasarım şekli vardır. Birisi Traditional API yani Geleneksel API, bir diğeri Compound API yani Bileşik API. Bunlar arasında ki farklar aşağıda ki gibidir.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*saaWKKfKtUaMCxnQa4_UWg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*c_WpyFCgnEh4erJMorUerA.png\"></figure><h4>Step 10: Composition API</h4>\n<p>Yeni nesil UI libraryleri genellikle bu yöntemi kullanmayı tercih ederler. Bu yöntem hem daha kontrol edilebilir hem de daha esnektir kullanım açısından.</p>\n<p>İlk önce src altında “Field” adında bir klasör ve içinde bir style.ts dosyası oluşturup aşağıda ki kodları içinde tanımlıyoruz.</p>\n<a href=\"https://medium.com/media/a3e5c0ffcb3addb3ab51c16ea2203fb1/href\">https://medium.com/media/a3e5c0ffcb3addb3ab51c16ea2203fb1/href</a><p>Daha sonra bu <strong>“Field”</strong> klasörü içinde “FieldContext” adın da bir context tutacağız. Burada createContext hooksu ile context oluşturup form alanlarında bu contextProviderını kullanacağız.</p>\n<a href=\"https://medium.com/media/d770c9eec2eb157bbdb9a8fde841ca17/href\">https://medium.com/media/d770c9eec2eb157bbdb9a8fde841ca17/href</a><p>Ve ayrıca bir altta ki “Field” componentımızda kullanacağımız unique id utilsini, utils klasörü altında useUniqueID.ts dosyası içinde aşağıdaki gibi oluşturuyoruz. Tabi önce bunu yapmamızı sağlayacak olan nanoid librarysini yüklüyoruz.</p>\n<p>npm install --save-dev nanoid<br>or<br>yard add -D nanoid</p>\n<a href=\"https://medium.com/media/d6f04186f5bec463330d8aaf87a7cedc/href\">https://medium.com/media/d6f04186f5bec463330d8aaf87a7cedc/href</a><p>Daha sonra yukarıda ki “ContextProvider”ı “Input”, “Label” gibi alanlari içine koyacağımız bir “Field.tsx” tanımlayacağız.</p>\n<a href=\"https://medium.com/media/fbe05d9c9a43c86c835430a25173a866/href\">https://medium.com/media/fbe05d9c9a43c86c835430a25173a866/href</a><p>Daha sonra “Input” ve “Label” componentlarımızı oluşturacağız.</p>\n<a href=\"https://medium.com/media/cf3663f3fccbd533265f21971d5f338b/href\">https://medium.com/media/cf3663f3fccbd533265f21971d5f338b/href</a><a href=\"https://medium.com/media/0909d2396763eb27fcdf6ea1dac2a344/href\">https://medium.com/media/0909d2396763eb27fcdf6ea1dac2a344/href</a><p>Daha sonra “Input.stories.tsx” adında yeni bir story dosyası oluşturup asağıda ki gibi “Field” ve içine gömdüğümüz “Input” ve “Label”ı çağırarak burada kullanabiliyor olacağız.</p>\n<a href=\"https://medium.com/media/a557a3e077e869bd8f572fda5bc65183/href\">https://medium.com/media/a557a3e077e869bd8f572fda5bc65183/href</a><p>Ve son olarak da gelin yine Field klasörü altında bir diğer form elemanımız Textarea componentimizi oluşturalım.</p>\n<a href=\"https://medium.com/media/fe59d67fa34511967de6b38218d4c17e/href\">https://medium.com/media/fe59d67fa34511967de6b38218d4c17e/href</a><p>Field.tsx dosyamızda da gerekli alanlara aşağdıa ki gibi Textarea’ı ekliyoruz.</p>\n<a href=\"https://medium.com/media/df7b6271bfdf908d9512a8a7eca7673b/href\">https://medium.com/media/df7b6271bfdf908d9512a8a7eca7673b/href</a><p>Ve son olarak da Textarea.stories.tsx dosyasını oluşturup aşağıda ki kodları gönderiyoruz.</p>\n<a href=\"https://medium.com/media/48d39e0b1794b3d403aca4b5b70e43b3/href\">https://medium.com/media/48d39e0b1794b3d403aca4b5b70e43b3/href</a><p>Ve artık Button ve Form bileşenlerine sahip bir UI kütüphanemiz hazır diyebiliriz :)</p>\n<h4>Step 11: Tests (Jest Settings)</h4>\n<p>İlk önce gerekli kurulumları aşağıda ki gibi yapıyoruz.</p>\n<p>npm install --save-dev jest ts-jest @types/jest react-is<br>or<br>yarn add -D jest ts-jest @types/jest react-is</p>\n<p>Daha sonra packaga.json içinde test adında bir script oluşturacağız aşağıda ki gibi. Şuana kadar olan tüm scriptlerimizde bu kadar zaten.</p>\n<a href=\"https://medium.com/media/97ac7bb56b3a9ad05238b84e6f921b41/href\">https://medium.com/media/97ac7bb56b3a9ad05238b84e6f921b41/href</a><p>Daha sonra root dizininde jest.config.js adıdna dosya oluşturup aşağıda ki ayarları içine yazıyoruz.</p>\n<a href=\"https://medium.com/media/f7c2aadd4e2933857941b09e5fd9f507/href\">https://medium.com/media/f7c2aadd4e2933857941b09e5fd9f507/href</a><h4>Step 12: Tests (@testing-library/react Settings)</h4>\n<p>Yine aşağıda ki kurulumları ilk olarak gerçekleştiriyoruz.</p>\n<p><strong>npm install --save-dev @testing-library/react @testing-library/jest-dom<br></strong>or<br><strong>yarn add -D @testing-library/react @testing-library/jest-dom</strong></p>\n<p>Daha sonra <strong>“jest-setup.ts”</strong> adında dosya oluşturup aşağıda ki 2 importu içine gönderiyoruz. Bunlarda react testleri için styled-component uyumluluğunu ve react için jest-dom’u aktif ediyor bizim için.</p>\n<a href=\"https://medium.com/media/8f6e60f1aec818286c6a749e5b00587a/href\">https://medium.com/media/8f6e60f1aec818286c6a749e5b00587a/href</a><p>tsconfig.json içine de eğer ekli değilse aşağıdaki satırı ekliyoruz.<br><strong> “include”: [“src/**/*”, “./jest-setup.ts”]</strong></p>\n<h4>Step 13: Tests</h4>\n<p>Daha sonra yeri size kalmış ama ben Button component klasörü içinde Button.spec.ts adında bir dosya oluşturup Button componentimizin testlerini yapıyoruz.</p>\n<a href=\"https://medium.com/media/14eb0fce15f5675e2d95cd9274c661af/href\">https://medium.com/media/14eb0fce15f5675e2d95cd9274c661af/href</a><p>Field testleri için useUniqueID adında bir mock utilse ihtiyacım olacağı için aşağıda ki gibi utils klasörü altında, __mocks__ klasörü oluşturup içinde <strong>“useUniqueID.ts”</strong> adında dosya oluşturup aşağıdaki mock utili oluşturuyorum.</p>\n<a href=\"https://medium.com/media/fe9b180171bd904d31ef3e881af0b949/href\">https://medium.com/media/fe9b180171bd904d31ef3e881af0b949/href</a><p>Daha sonrada <strong>“Field.spec.ts”</strong> adında test dosyamızı oluşturup aşağıda ki testleri yazıyoruz.</p>\n<a href=\"https://medium.com/media/abe1e1c9b05f5755a5f42d06befb59f3/href\">https://medium.com/media/abe1e1c9b05f5755a5f42d06befb59f3/href</a><h4>Step 14: Module Formats</h4>\n<p>Bu aşamada ise oluşturduğumuz ui librarymizi babel ve @rollup librarylerini kullanıp compressleyip dist çıktısını alacağız.</p>\n<p>Önce aşağıdaki gerekli libraryleri kuruyoruz.</p>\n<p>npm install @babel/runtime<br>npm install --save-dev @babel/preset-env @babel/preset-typescript @babel/preset-react @babel/plugin-transform-runtime babel-plugin-styled-components<br>or<br>yarn add @babel/runtime<br>yarn add -D @babel/preset-env @babel/preset-typescript @babel/preset-react @babel/plugin-transform-runtime babel-plugin-styled-components</p>\n<p>Şimdide .babelrc dosyası oluşturup aşağıda ki kodları yapıştırıyoruz.</p>\n<a href=\"https://medium.com/media/b781a3d505293316b7437ff4d2dc94df/href\">https://medium.com/media/b781a3d505293316b7437ff4d2dc94df/href</a><p>Ve şimdide rollup paketlerini yüklüyoruz. Bunlar build timeda kullanılacak paketler olduğu için devDependencies olarak ekleyebiliriz.</p>\n<p>npm install --save-dev rollup rollup-plugin-delete rollup-plugin-node-externals @rollup/plugin-babel @rollup/plugin-commonjs @rollup/plugin-node-resolve<br>or<br>yarn add -D rollup rollup-plugin-delete rollup-plugin-node-externals @rollup/plugin-babel @rollup/plugin-commonjs @rollup/plugin-node-resolve</p>\n<p>Ve rollup.config.js dosyası oluşturup aşağıda ki ayarları yerleştiriyoruz.</p>\n<a href=\"https://medium.com/media/1e9df70ebdf9aa57113bfd494731724b/href\">https://medium.com/media/1e9df70ebdf9aa57113bfd494731724b/href</a><h4><strong>Step 15: Typescript Declarations</strong></h4>\n<p>Daha sonra tsconfig.build.json ayarlarımızı aşağıda ki gibi yapıyoruz.</p>\n<p>Bu tanımlamalarla da index.d.ts gibi typescript rulelarını set eden dosyaları build olarak dist çıktı klasörümüze kopya olarak alacağız.</p>\n<p>Daha sonra <strong>“/root/src”</strong> altında <strong>“index.ts”</strong> dosyası oluşturup bundle edilecek tüm dosyaları burada export ediyoruz.</p>\n<a href=\"https://medium.com/media/b3cfbbcc58d4dfd9c78022e4e05f5d80/href\">https://medium.com/media/b3cfbbcc58d4dfd9c78022e4e05f5d80/href</a><p>Daha sonra package.json dosyamıza aşağıdaki “main”, “module” ve “sideEffects” kısımlarınıda ekliyoruz ve scriptlerimizin son halide aşağıda ki gibidir.</p>\n<a href=\"https://medium.com/media/0136ea5ef312f5e162c8a0bb2720f7e2/href\">https://medium.com/media/0136ea5ef312f5e162c8a0bb2720f7e2/href</a><p>Ve daha sonra aşağıda ki kodları sırayla çalıştırıp kontrol edip buildi aldığımızı görüyoruz.</p>\n<p>npm run format<br>npm run format:lint<br>npm run build</p>\n<h4>Step 16: husky</h4>\n<p>Husky ile ise githuba commit göndermeden veya pushlamadan önceki çalışması gereken actionları komut olarak vereceğiz. Örneğin her commit önceki eslint checki yapmasını istiyorum ve eğer eslint hatası varsa commiti kabul etmesini istemiyorum. İlk önce eslint hatalarını giderdikten sonra tekrar gelip commit atmasını ve tekrar denetleyerek hata yoksa commitini göndermesini istiyorum gibi.</p>\n<p>İlk önce aşağıda ki kodla “husky”i yüklüyoruz.</p>\n<p>npm install husky --save-dev<br>or<br>yarn add -D husky</p>\n<p>Ve daha sorna aşağıda ki kodla git hookslarını aktif ediyoruz.<br>npx husky install</p>\n<p>Kurulumdan sonra git hookslarını otomatik etkinleştirmek içinde aşağıda ki kodu set ediyoruz.<br>npm set-scrpit prepare “husky install”</p>\n<p>Ve şimdi de pre-commit ile commitlerden önce çalıştırılması gereken scriptleri set ediyoruz aşağıda ki gibi.<br>npx husky add .husky/pre-commit “npm run lint &amp;&amp; npm run format:lint &amp;&amp; npm run test”</p>\n<p>Ve şimdide push önceki olan pre-push daki kısmı ayarlıyoruz.</p>\n<p>npx husky add .husky/pre-push “npm run lint &amp;&amp; npm run format:lint &amp;&amp; npm run test”</p>\n<p>Ve bu kadar şimdi değişiklikleri tekrar githuba pushlayabiliriz.</p>\n<h4>Step 17: semantic-release</h4>\n<p>Ve artık son adımlarımızdan birisi olan semantic bir şekilde release çıkmaya geldik diyebiliriz. Burada yapacağımız ayarlarla semantic olarak version ve tag alabileceğiz, change log kayıtlarımız otomatik tutulacak ve commit mesajlarımızı daha düzgün bir şekilde tutabileceğiz.</p>\n<p>İlk önce aşağıda her zaman yaptığımız gibi gerekli libraryleri yüklüyoruz.</p>\n<p>yarn add -D semantic-release <a href=\"http://twitter.com/semantic\">@semantic</a>-release/changelog <a href=\"http://twitter.com/semantic\">@semantic</a>-release/git commitizen cz-conventional-changelog<br>or<br>npm install --save-dev semantic-release <a href=\"http://twitter.com/semantic\">@semantic</a>-release/changelog <a href=\"http://twitter.com/semantic\">@semantic</a>-release/git commitizen cz-conventional-changelog</p>\n<p>Sonra aşağıda ki release, repository alanını ve yeni 2 scriptimizi package.jsona ekleyelim.</p>\n<a href=\"https://medium.com/media/fb81467c9a845adae1cc54acba830c71/href\">https://medium.com/media/fb81467c9a845adae1cc54acba830c71/href</a><p>Artık commitlerimizi git add yaptıktan sorna npm run commit diyerek çalıştırdıktan sonra commitizen packagenin standartlarına göre göndereceğiz. Ve pushladıktan sonra github actionslar semantic-release paketiyle birlikte automation işlemini otomatik olarak yapacak.</p>\n<h4>Step 18: Github Environment Variable</h4>\n<p>Önce Github actionslarında kullanılmak üzere ilk başta NPM_TOKEN adında bir envıronment variable tanımlamamız gerekiyor github repomuza. Bu tokeni almak için npme gidip bir tane auyomation için token oluşturuyoruz ve aşağıdaki gibi oluşturduğumuz ui librarysinin github reposunun ayarlarında ki Secret kısmında, NPM_TOKEN name olacak şekilde npmden aldığımız token ile burada yeni bir environment variable tanımlıyoruz.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*tGzH7s0-wLwt7udp0ziMDA.png\"></figure><p>Github-actionslara geçmeden önce son olarakda ui-library olan package ismimizi unique bir npm package ismi seçerek değiştiriyoruz. Npm kütüphanesine girerek seçtiğiniz paket ismini kontrol edin. Ve privateyide false yapıyoruz çünkü free npm üyeliğiyle private npm packageleri yükleyemiyoruz. Bizimkisi de free olduğu için public bir npm kütüphanesi oluşturuyoruz.</p>\n<a href=\"https://medium.com/media/f669438b417eabdee9a87611714157cf/href\">https://medium.com/media/f669438b417eabdee9a87611714157cf/href</a><h4>Step 19: Github Actions</h4>\n<p>Ve şimdi tüm ayarlarımızı yaptığımıza göre sıra oluşturduğumuz libraryi npme publish etmeye geldi. Npm publish işini github actionslarla otomatik bir şekilde yapacağız. Süreç şu şekilde işleyecek. Biz bir commit gönderdiğimiz de yani githuba push ettiğimiz de githubda aşağıda yazdığımız ci actionu çalışıp npm release ve semantic versioning automationunu bizim için yapacak.</p>\n<p>Bunun için tek yapmamız gereken aşağıdaki dizine release veya istediginiz bir dosya adı .yml şeklinde bir dosya oluşturmak ve aşağdıa ki kodları oraya yazmak. Yorumlu satırdaki test kısmını bilerek bıraktım isterseniz oradaki gibi ikinci bir job daha ekleyip kullanabilirsiniz.<br><strong>/root/.github/workflows/release.yml</strong></p>\n<a href=\"https://medium.com/media/e0fc5b9220dd0709d6b17b9b327c625b/href\">https://medium.com/media/e0fc5b9220dd0709d6b17b9b327c625b/href</a><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3d18a41e3e27\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": [
      "repository-pattern",
      "github",
      "git",
      "ui-library",
      "version-control"
    ],
    "slug": "3d18a41e3e27"
  },
  {
    "title": "Test - NPM - Package Publishing Notes &amp; Policy",
    "pubDate": "2021-07-30 07:02:36",
    "link": "https://mucahidyazar.medium.com/npm-package-publishing-notes-policy-3b7d4be9f1fb?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/3b7d4be9f1fb",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*-_8rJAQ9c9JTizPGCX8Cyg.png",
    "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*-_8rJAQ9c9JTizPGCX8Cyg.png\"></figure><p>Bu sefer NPM’de package publishing yaparken yaptığım hatalar, karşılaştığım sorunlar ve bulduğum çözümleri anlattığım bir yazı yazmak istiyorum. Aslında burada anlatacaklarımın bir çoğunu sizde merak edip araştırıp düşünmek ve challenge yaşamak zorunda kalacaksınız eğer günün birince bu işe deep dive girişecek olursanız.</p>\n<h3>Yaptığım hatalar</h3>\n<h4>Özel isimle publish etmek &amp; Version numarası kullanmak</h4>\n<p>Diyelim ki icon-generator diye özel ve güzel bir isime sahip bir library oluşturacağım. Bu libraryi npm’e direk olarak bu isimle pushlamak yerine daha sıradan icon-test-generator adıyla göndermek daha doğru olurdu. Ve ayrıca ben 1.0.0 gibi bir version numarası kullanmıştım package.json içinde. Buda bu özel isimle oluşturduğum packagenin bir daha asla bu version numarası ile yeniden publish edemeyeceğim anlamına geliyordu. Yani eğer oluşturduğunuz packageA kütüphanesini npm’e 1.0.0 version numarasıyla veya herhangi bir version numarası ile npm’e gönderirseniz bir daha bu packageyi npmden silseniz dahi aynı version numarası ile npme publish edemeyeceğiniz anlamına gelir. Yani version numarasını değişip tekrar publish etmeliyiz demek oluyor bu. :(</p>\n<h4>Test publishleri npm üzerinde yapmak</h4>\n<p>Evet buda işin bir diğer acı tarafı. Test publishlerimi aşağıdaki şu toolu bilene kadar hep npm üzerinde yaptım buda bana fazlaca maliyetli oldu nihayetinde. Siz bu hatayı yapmayın ve <strong>Verdaccio </strong>isimli local npm publish toolunu kullanarak oluşturduğunuz packageleri önce localde publsih edip sonuçlarını gözlemleyin.</p>\n<h4>Alpha - Beta - RC Releaseleri Yapmamak</h4>\n<p>İlla paketinizi npm’e veya bir bulut ortamına publish edecekseniz paketlerinizin çalışırlığından emin olmadan önce paketlerinizi kesinlikle alpha, beta, rc gibi stabil olmayan sürümlerle çıkartmalısınız. Bu hem bu sürümlerin halen test edildiğini hem bazı özelliklerinin çalışmıyor olabileceğini anlattığı için yanlış publishlerde bu versionlarla birlikte sorun olmayacaktır. Tabi ki eğer ufak tefek buglar yoksa major problemler varsa stabil veya fix versionları çıktıktan sonra bu sürümleri unpublish yapın yapamıyorsanızda deprecated yapın.</p>\n<p><a href=\"https://docs.npmjs.com/cli/v7/commands/npm-version\">npm-version | npm Docs</a></p>\n<h4>Summary</h4>\n<ul>\n<li>npm’e sadece bir kere aynı versionu publish edebilirsiniz, unpublish etseniz dahi daha önce publish edilmiş bir versionu tekrar npm’e publish edemezsiniz.</li>\n<li>npm’e publish etmeden önce Verdaccio gibi local package managerlere publish ediniz.</li>\n<li>çalıştığına tam olarak emin olmadığınız packageleri alpha, beta veya rc gibi sürüm adları ile çıkınız.</li>\n</ul>\n<h3>Notes &amp; Important Things</h3>\n<ul>\n<li>unpublish policy’ye dikkat edin. Özetle bu yazının yazıldığı tarih itibari ile: (Değişebilir burası bu yüzden documentation tavsiye edilir)<br>- İlk publishden 72 saat içinde her hangi bir zaman<br>- Eğer 72 saat önceden publish edildiyse:<br> * son hafta 300 den az download edildiyse<br> * sadece 1 tane owner veya maintainera sahipse<br> * npmdeki diğer paketler bu pakete bağlı değilse<br>unpublish edilebilir.</li>\n<li>Bu şartlar dışındakiler unpublish edilemez fakat profilinizde illada bu paketleri görmek istemiyorsanız, npm i maintainer olarak ekleyerek kendinizide maintainerlardan çıkartarak bu paketi npm’e devrederek profilinizden kaldırabilirsiniz. Böylece paket yine var olur ama en azından sizin üzerinizden ve profilinizden kalkmış olur.</li>\n<li>Belirli bir pacakge versionunu unpublish yapmak.<br>npm unpublish packageName@version</li>\n<li>Bütün packageyi unpublish yapmak. (-f force anlamında)<br>npm unpublish -f packageName@version</li>\n<li>Npm’i maintainer olarak pakete eklemek:<br>npm owner add npm package</li>\n<li>Paketten kendinizi maintainerlar arasından çıkartmak<br>npm owner rm username package</li>\n<li>Bütün bir paketi depracated yapmak.<br>npm deprecate packageName \"message\"</li>\n<li>Belirli bir paketi deprecated yapmak.<br>npm deprecate packageName@version \"message\"</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3b7d4be9f1fb\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*-_8rJAQ9c9JTizPGCX8Cyg.png\"></figure><p>Bu sefer NPM’de package publishing yaparken yaptığım hatalar, karşılaştığım sorunlar ve bulduğum çözümleri anlattığım bir yazı yazmak istiyorum. Aslında burada anlatacaklarımın bir çoğunu sizde merak edip araştırıp düşünmek ve challenge yaşamak zorunda kalacaksınız eğer günün birince bu işe deep dive girişecek olursanız.</p>\n<h3>Yaptığım hatalar</h3>\n<h4>Özel isimle publish etmek &amp; Version numarası kullanmak</h4>\n<p>Diyelim ki icon-generator diye özel ve güzel bir isime sahip bir library oluşturacağım. Bu libraryi npm’e direk olarak bu isimle pushlamak yerine daha sıradan icon-test-generator adıyla göndermek daha doğru olurdu. Ve ayrıca ben 1.0.0 gibi bir version numarası kullanmıştım package.json içinde. Buda bu özel isimle oluşturduğum packagenin bir daha asla bu version numarası ile yeniden publish edemeyeceğim anlamına geliyordu. Yani eğer oluşturduğunuz packageA kütüphanesini npm’e 1.0.0 version numarasıyla veya herhangi bir version numarası ile npm’e gönderirseniz bir daha bu packageyi npmden silseniz dahi aynı version numarası ile npme publish edemeyeceğiniz anlamına gelir. Yani version numarasını değişip tekrar publish etmeliyiz demek oluyor bu. :(</p>\n<h4>Test publishleri npm üzerinde yapmak</h4>\n<p>Evet buda işin bir diğer acı tarafı. Test publishlerimi aşağıdaki şu toolu bilene kadar hep npm üzerinde yaptım buda bana fazlaca maliyetli oldu nihayetinde. Siz bu hatayı yapmayın ve <strong>Verdaccio </strong>isimli local npm publish toolunu kullanarak oluşturduğunuz packageleri önce localde publsih edip sonuçlarını gözlemleyin.</p>\n<h4>Alpha - Beta - RC Releaseleri Yapmamak</h4>\n<p>İlla paketinizi npm’e veya bir bulut ortamına publish edecekseniz paketlerinizin çalışırlığından emin olmadan önce paketlerinizi kesinlikle alpha, beta, rc gibi stabil olmayan sürümlerle çıkartmalısınız. Bu hem bu sürümlerin halen test edildiğini hem bazı özelliklerinin çalışmıyor olabileceğini anlattığı için yanlış publishlerde bu versionlarla birlikte sorun olmayacaktır. Tabi ki eğer ufak tefek buglar yoksa major problemler varsa stabil veya fix versionları çıktıktan sonra bu sürümleri unpublish yapın yapamıyorsanızda deprecated yapın.</p>\n<p><a href=\"https://docs.npmjs.com/cli/v7/commands/npm-version\">npm-version | npm Docs</a></p>\n<h4>Summary</h4>\n<ul>\n<li>npm’e sadece bir kere aynı versionu publish edebilirsiniz, unpublish etseniz dahi daha önce publish edilmiş bir versionu tekrar npm’e publish edemezsiniz.</li>\n<li>npm’e publish etmeden önce Verdaccio gibi local package managerlere publish ediniz.</li>\n<li>çalıştığına tam olarak emin olmadığınız packageleri alpha, beta veya rc gibi sürüm adları ile çıkınız.</li>\n</ul>\n<h3>Notes &amp; Important Things</h3>\n<ul>\n<li>unpublish policy’ye dikkat edin. Özetle bu yazının yazıldığı tarih itibari ile: (Değişebilir burası bu yüzden documentation tavsiye edilir)<br>- İlk publishden 72 saat içinde her hangi bir zaman<br>- Eğer 72 saat önceden publish edildiyse:<br> * son hafta 300 den az download edildiyse<br> * sadece 1 tane owner veya maintainera sahipse<br> * npmdeki diğer paketler bu pakete bağlı değilse<br>unpublish edilebilir.</li>\n<li>Bu şartlar dışındakiler unpublish edilemez fakat profilinizde illada bu paketleri görmek istemiyorsanız, npm i maintainer olarak ekleyerek kendinizide maintainerlardan çıkartarak bu paketi npm’e devrederek profilinizden kaldırabilirsiniz. Böylece paket yine var olur ama en azından sizin üzerinizden ve profilinizden kalkmış olur.</li>\n<li>Belirli bir pacakge versionunu unpublish yapmak.<br>npm unpublish packageName@version</li>\n<li>Bütün packageyi unpublish yapmak. (-f force anlamında)<br>npm unpublish -f packageName@version</li>\n<li>Npm’i maintainer olarak pakete eklemek:<br>npm owner add npm package</li>\n<li>Paketten kendinizi maintainerlar arasından çıkartmak<br>npm owner rm username package</li>\n<li>Bütün bir paketi depracated yapmak.<br>npm deprecate packageName \"message\"</li>\n<li>Belirli bir paketi deprecated yapmak.<br>npm deprecate packageName@version \"message\"</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3b7d4be9f1fb\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["npm", "policy", "package", "package-manager", "publishing"],
    "slug": "3b7d4be9f1fb"
  },
  {
    "title": "Test - Semantic Versioning (Version ruleset in package.json (^,~,&gt;,&gt;=,&lt;,&lt;=,=,-,||))",
    "pubDate": "2021-07-23 07:03:18",
    "link": "https://mucahidyazar.medium.com/semantic-versioning-version-ruleset-in-package-json-372cfe9c93af?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/372cfe9c93af",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/374/1*eWYHDceiwMSdnHavp-DAVA.png",
    "description": "\n<p>Node.js packageslerinde en güzel şey kesinlikle packageler için version numaralandırma sürümlerinde semantic versioning kullanmaları diyebiliriz.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/374/1*eWYHDceiwMSdnHavp-DAVA.png\"></figure><p>Semantic Versioning konsepti oldukça basittir. Bütün version sadece 3 digit yani sayıdan oluşur: x.y.z.</p>\n<ul>\n<li>İlk sayı yani x, major version</li>\n<li>İkinci sayı yani y, minor version</li>\n<li>Üçüncü sayı yani z, patch version</li>\n</ul>\n<p>Yeni bir sürüm çıkmak istediğinizde istediğiniz gibi bir sayıyı arttırmazsınız. Bazı kurallar dahilinde bu sayıları arttırırız.</p>\n<ul>\n<li>API’da eskiye göre uyumsuz önemli değişikliklerde MAJOR versionu arttırırız</li>\n<li>Geriye dönük uyumlu bir şekilde çıkarttığımız yeni özellik ve functionalitylerde MINOR versionu arttırırız</li>\n<li>Geriye dönük uyumlu bir şekilde bug fixlerde veya küçük düzeltmelerde veya typolarda PATCH versionu arttırırız</li>\n</ul>\n<p>The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.</p>\n<p>Bu yapı bütün proğramlanma dillerinde bu şekilde benimsenmiştir. Ve npm packagelerininde bu kurallara bağlı kalması hem bizim hem de sistem için çok önemlidir. Çünkü bütün sistem ucunda buna bağlıdır.</p>\n<h4>Why is that so important?</h4>\n<p>Çünkünpm bazı kurallar ayarlar ve biz bu kurallara göre package versionlarını ayarlarız uygulamamızın<a href=\"https://flaviocopes.com/package-json/\">package.json </a>içinde. Ve bu packagelerimize bazı ruleslar ekleriz <a href=\"https://flaviocopes.com/package-json/\">package.json </a>içinde. Bu rullara göre npm update yaptığımızda düzgünce yüklemelerimizi gerçekleştiririz.</p>\n<h4>The rules use those symbols:</h4>\n<ul>\n<li>^</li>\n<li>~</li>\n<li>&gt;</li>\n<li>&gt;=</li>\n<li>&lt;</li>\n<li>&lt;=</li>\n<li>=</li>\n<li>-</li>\n<li>||</li>\n</ul>\n<h4>Let’s see those rules in detail:</h4>\n<ul>\n<li>^: Eğer version number olarak bir packageye ^0.13.0 yazarsanız npm update yaptığımızda eğer bu packagenin yeni minor veya patch releasesi (0.13.1, 0.14.0gibi) paylaşılmışsa bu paylaşılan yeni versionları yükler, eğer yoksa yazılmış versionu yükler.</li>\n<li>~: Eğer version number olarak bir packageye ~0.13.0 yazarsanız npm update yaptığımızda eğer bu packagenin yeni patch releasesi (0.13.1 gibi) paylaşılmışsa bu paylaşılan yeni versionları yükler, eğer yoksa yazılmış versionu yükler.</li>\n<li>&gt;: Herhangi bir yüksek versionu kabul eder.</li>\n<li>&gt;=: Herhangi bir yüksek veya eşit versionu kabul eder</li>\n<li>&lt;=: Herhangi bir düşük veya eşit versionu kabul eder</li>\n<li>&lt;: Herhangi bir düşük versionu kabul eder.</li>\n<li>=: Tam olarak belirttiğimiz versionu kabul eder</li>\n<li>-: Belirlik bir aralıkta ki versionu kabul eder. Example: 2.1.0 - 2.6.2</li>\n<li>||: Birden fazla rule set ederiz pipelarla. Example: &lt; 2.1 || &gt; 2.6</li>\n</ul>\n<p>Yukarıdaki formuüllerden bir kaçını kullanarak kendinize özeli kurallarda ayarlayabilirziniz, for example use 1.0.0 || &gt;=1.1.0 &lt;1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.</p>\n<p>Başka kurallarda var:</p>\n<ul>\n<li>no symbol: Her hangi bir işaret koymazsak sadece belirttiğimiz versionu yüklemesini istediğimizi söyleriz. Bir nevi = işareti gibi. (1.2.1)</li>\n<li>latest: packagenin latest yani en son sürümü hangisi ise onu kullanmak istediğimizi söyleriz.</li>\n</ul>\n<p><a href=\"https://docs.npmjs.com/about-semantic-versioning\">About semantic versioning | npm Docs</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=372cfe9c93af\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>Node.js packageslerinde en güzel şey kesinlikle packageler için version numaralandırma sürümlerinde semantic versioning kullanmaları diyebiliriz.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/374/1*eWYHDceiwMSdnHavp-DAVA.png\"></figure><p>Semantic Versioning konsepti oldukça basittir. Bütün version sadece 3 digit yani sayıdan oluşur: x.y.z.</p>\n<ul>\n<li>İlk sayı yani x, major version</li>\n<li>İkinci sayı yani y, minor version</li>\n<li>Üçüncü sayı yani z, patch version</li>\n</ul>\n<p>Yeni bir sürüm çıkmak istediğinizde istediğiniz gibi bir sayıyı arttırmazsınız. Bazı kurallar dahilinde bu sayıları arttırırız.</p>\n<ul>\n<li>API’da eskiye göre uyumsuz önemli değişikliklerde MAJOR versionu arttırırız</li>\n<li>Geriye dönük uyumlu bir şekilde çıkarttığımız yeni özellik ve functionalitylerde MINOR versionu arttırırız</li>\n<li>Geriye dönük uyumlu bir şekilde bug fixlerde veya küçük düzeltmelerde veya typolarda PATCH versionu arttırırız</li>\n</ul>\n<p>The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.</p>\n<p>Bu yapı bütün proğramlanma dillerinde bu şekilde benimsenmiştir. Ve npm packagelerininde bu kurallara bağlı kalması hem bizim hem de sistem için çok önemlidir. Çünkü bütün sistem ucunda buna bağlıdır.</p>\n<h4>Why is that so important?</h4>\n<p>Çünkünpm bazı kurallar ayarlar ve biz bu kurallara göre package versionlarını ayarlarız uygulamamızın<a href=\"https://flaviocopes.com/package-json/\">package.json </a>içinde. Ve bu packagelerimize bazı ruleslar ekleriz <a href=\"https://flaviocopes.com/package-json/\">package.json </a>içinde. Bu rullara göre npm update yaptığımızda düzgünce yüklemelerimizi gerçekleştiririz.</p>\n<h4>The rules use those symbols:</h4>\n<ul>\n<li>^</li>\n<li>~</li>\n<li>&gt;</li>\n<li>&gt;=</li>\n<li>&lt;</li>\n<li>&lt;=</li>\n<li>=</li>\n<li>-</li>\n<li>||</li>\n</ul>\n<h4>Let’s see those rules in detail:</h4>\n<ul>\n<li>^: Eğer version number olarak bir packageye ^0.13.0 yazarsanız npm update yaptığımızda eğer bu packagenin yeni minor veya patch releasesi (0.13.1, 0.14.0gibi) paylaşılmışsa bu paylaşılan yeni versionları yükler, eğer yoksa yazılmış versionu yükler.</li>\n<li>~: Eğer version number olarak bir packageye ~0.13.0 yazarsanız npm update yaptığımızda eğer bu packagenin yeni patch releasesi (0.13.1 gibi) paylaşılmışsa bu paylaşılan yeni versionları yükler, eğer yoksa yazılmış versionu yükler.</li>\n<li>&gt;: Herhangi bir yüksek versionu kabul eder.</li>\n<li>&gt;=: Herhangi bir yüksek veya eşit versionu kabul eder</li>\n<li>&lt;=: Herhangi bir düşük veya eşit versionu kabul eder</li>\n<li>&lt;: Herhangi bir düşük versionu kabul eder.</li>\n<li>=: Tam olarak belirttiğimiz versionu kabul eder</li>\n<li>-: Belirlik bir aralıkta ki versionu kabul eder. Example: 2.1.0 - 2.6.2</li>\n<li>||: Birden fazla rule set ederiz pipelarla. Example: &lt; 2.1 || &gt; 2.6</li>\n</ul>\n<p>Yukarıdaki formuüllerden bir kaçını kullanarak kendinize özeli kurallarda ayarlayabilirziniz, for example use 1.0.0 || &gt;=1.1.0 &lt;1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.</p>\n<p>Başka kurallarda var:</p>\n<ul>\n<li>no symbol: Her hangi bir işaret koymazsak sadece belirttiğimiz versionu yüklemesini istediğimizi söyleriz. Bir nevi = işareti gibi. (1.2.1)</li>\n<li>latest: packagenin latest yani en son sürümü hangisi ise onu kullanmak istediğimizi söyleriz.</li>\n</ul>\n<p><a href=\"https://docs.npmjs.com/about-semantic-versioning\">About semantic versioning | npm Docs</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=372cfe9c93af\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": [
      "git",
      "packagejson",
      "semantic-versioning",
      "nodejs",
      "npm"
    ],
    "slug": "372cfe9c93af"
  },
  {
    "title": "Test - What are peer dependencies in a Node module?",
    "pubDate": "2021-07-16 07:02:40",
    "link": "https://mucahidyazar.medium.com/what-are-peer-dependencies-in-a-node-module-e49324fdb976?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/e49324fdb976",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/960/1*lwbNvBFRXPU_z0G1aB4QQA.png",
    "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/1*lwbNvBFRXPU_z0G1aB4QQA.png\"></figure><p>Bu ay öğrendiğim harika şeylerden biriside bu oldu diyebilirim. Hepimiz package.json dosyalarında “dependencies” veya “devDependencies” lere aşinayız. Bazı package.json dosyalarında ise aşağıda ki gibi “peerDependencies” kullanımı görmüş olabilirsiniz. Peki bu bize ne söyler ve ne işe yarar?</p>\n<a href=\"https://medium.com/media/f38753d8835cfa94cff34cf5f9b66fb3/href\">https://medium.com/media/f38753d8835cfa94cff34cf5f9b66fb3/href</a><p>dependencies: Projemizin çalışması için kesnilikle yüklü olması gereken yani projemizin bağlı olduğu zorunlu paketlerdir.</p>\n<p>devDependencies: Projemizin development yaparken ihtiyacımız olan kullanacağımzı paketlerdir. Bu paketler productionda projemizin veya uygulamamızın kullanmadığı ihtiyacı olmadığı paketlerdir.</p>\n<p><strong>peerDependencies</strong>: Burası biraz karışık. O yüzden örnek vererek açıklayacağım.</p>\n<p>Diyelim <strong>“shopping-app”</strong> adında bir uygulama geliştiriyoruz. Ve uygulamamıza <strong>“packageA”</strong> librarysini eklemek istiyoruz. <br>Ve <strong>“packageA ”</strong>librarysinde <strong>peerDependencies </strong>olarak <strong>“nodemon”</strong> paketi eklenmiş.</p>\n<p>Ve <strong>“packageA”</strong> librarysinin projemizde doğru çalışması için, <br><strong>“nodemon”</strong> paketinin <strong>“dependencies”</strong> olarak, <br><strong>“shopping-app”</strong> uygulamamızın <strong>“package.json”</strong> dosyasına <strong>dependencies </strong>olarak eklenmesi yani yüklememiz gerektiğini söyler.</p>\n<p>Eğer “peerDependencies”leri olan bir paketi projemize eklediğimizde, o paketin “peerDependencies”lerini projemize “dependencies” olarak yüklemezsek, npm install veya yarn install yaptığımızda, package managerimiz bizi uyaracak ve “peerDependencies”lerin yüklenmesini terminalda sarı renkli warning yazılarıyla bize gösterecek.</p>\n<p>Gelin bir örnek daha verelim.</p>\n<p>package a mız dependencies olarak b packagesine sahip.</p>\n<a href=\"https://medium.com/media/c3123da3b496a7aee8bcdf6587df2f21/href\">https://medium.com/media/c3123da3b496a7aee8bcdf6587df2f21/href</a><p>package b mizde peerDependenciy olarak package c yi istiyor:</p>\n<a href=\"https://medium.com/media/98b2559bf626cb42739ffe660cdc0ac1/href\">https://medium.com/media/98b2559bf626cb42739ffe660cdc0ac1/href</a><p>Bu nedenle package a da, package c yi dependency olarak eklemeliyiz yoksa package b yi yüklediğimiz zaman terminal bize uyarı olarak yüklememiz gerektiğini söyleyen bir mesaj gösterecek. (Ve muhtemelen uygulamamızda fail olacak ve düzgün çalışmayacak peerDependencyi yüklemediğimiz için)</p>\n<a href=\"https://medium.com/media/38dcfd775826dab9a6e4605592e66e06/href\">https://medium.com/media/38dcfd775826dab9a6e4605592e66e06/href</a><p>Package version sürüm numaraları uyumlu olmalıdır, yani eğer peerDependency olarak eklenen package 2.x versiyonunu istiyorsa, 1.x veya aşağısında ki herhangi bir sürümünü dependency olarak yükleyemezsin.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e49324fdb976\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/1*lwbNvBFRXPU_z0G1aB4QQA.png\"></figure><p>Bu ay öğrendiğim harika şeylerden biriside bu oldu diyebilirim. Hepimiz package.json dosyalarında “dependencies” veya “devDependencies” lere aşinayız. Bazı package.json dosyalarında ise aşağıda ki gibi “peerDependencies” kullanımı görmüş olabilirsiniz. Peki bu bize ne söyler ve ne işe yarar?</p>\n<a href=\"https://medium.com/media/f38753d8835cfa94cff34cf5f9b66fb3/href\">https://medium.com/media/f38753d8835cfa94cff34cf5f9b66fb3/href</a><p>dependencies: Projemizin çalışması için kesnilikle yüklü olması gereken yani projemizin bağlı olduğu zorunlu paketlerdir.</p>\n<p>devDependencies: Projemizin development yaparken ihtiyacımız olan kullanacağımzı paketlerdir. Bu paketler productionda projemizin veya uygulamamızın kullanmadığı ihtiyacı olmadığı paketlerdir.</p>\n<p><strong>peerDependencies</strong>: Burası biraz karışık. O yüzden örnek vererek açıklayacağım.</p>\n<p>Diyelim <strong>“shopping-app”</strong> adında bir uygulama geliştiriyoruz. Ve uygulamamıza <strong>“packageA”</strong> librarysini eklemek istiyoruz. <br>Ve <strong>“packageA ”</strong>librarysinde <strong>peerDependencies </strong>olarak <strong>“nodemon”</strong> paketi eklenmiş.</p>\n<p>Ve <strong>“packageA”</strong> librarysinin projemizde doğru çalışması için, <br><strong>“nodemon”</strong> paketinin <strong>“dependencies”</strong> olarak, <br><strong>“shopping-app”</strong> uygulamamızın <strong>“package.json”</strong> dosyasına <strong>dependencies </strong>olarak eklenmesi yani yüklememiz gerektiğini söyler.</p>\n<p>Eğer “peerDependencies”leri olan bir paketi projemize eklediğimizde, o paketin “peerDependencies”lerini projemize “dependencies” olarak yüklemezsek, npm install veya yarn install yaptığımızda, package managerimiz bizi uyaracak ve “peerDependencies”lerin yüklenmesini terminalda sarı renkli warning yazılarıyla bize gösterecek.</p>\n<p>Gelin bir örnek daha verelim.</p>\n<p>package a mız dependencies olarak b packagesine sahip.</p>\n<a href=\"https://medium.com/media/c3123da3b496a7aee8bcdf6587df2f21/href\">https://medium.com/media/c3123da3b496a7aee8bcdf6587df2f21/href</a><p>package b mizde peerDependenciy olarak package c yi istiyor:</p>\n<a href=\"https://medium.com/media/98b2559bf626cb42739ffe660cdc0ac1/href\">https://medium.com/media/98b2559bf626cb42739ffe660cdc0ac1/href</a><p>Bu nedenle package a da, package c yi dependency olarak eklemeliyiz yoksa package b yi yüklediğimiz zaman terminal bize uyarı olarak yüklememiz gerektiğini söyleyen bir mesaj gösterecek. (Ve muhtemelen uygulamamızda fail olacak ve düzgün çalışmayacak peerDependencyi yüklemediğimiz için)</p>\n<a href=\"https://medium.com/media/38dcfd775826dab9a6e4605592e66e06/href\">https://medium.com/media/38dcfd775826dab9a6e4605592e66e06/href</a><p>Package version sürüm numaraları uyumlu olmalıdır, yani eğer peerDependency olarak eklenen package 2.x versiyonunu istiyorsa, 1.x veya aşağısında ki herhangi bir sürümünü dependency olarak yükleyemezsin.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e49324fdb976\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": [
      "peer-dependencies",
      "package-manager",
      "yarn",
      "packagejson",
      "npm"
    ],
    "slug": "e49324fdb976"
  },
  {
    "title": "Test - What’s the difference between a tilde (~) and a caret (^) in a npm package.json file?",
    "pubDate": "2021-07-09 07:02:30",
    "link": "https://mucahidyazar.medium.com/whats-the-difference-between-a-tilde-and-a-caret-in-a-npm-package-json-file-6e9de27b447b?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/6e9de27b447b",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*UM73V7OTZ1j9x2NnkySrJA.png",
    "description": "\n<p><strong>What’s the difference between a tilde (~) and a caret (^) in a npm package.json file?</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UM73V7OTZ1j9x2NnkySrJA.png\"></figure><p>Eğer node.js ve npm packaga manageri kullanıp bir Javascript uygulaması geliştiriyorsanız aşağıda ki gibi package.json dosyalarına aşinasınızdır.</p>\n<pre>{<br>  \"devDependencies\": {<br>    \"ember-cli\": \"~2.14.0\"<br>  }<br>}</pre>\n<p>npm package.json dosyasında uygulamamızın ihtiyacı olan kullandığımız paketleri belirtir. Ve bu paketler <a href=\"http://semver.org/\">semver syntax</a> ile sürüm version numaralandırması ile sürümlendirilirler aşağıdaki gibi.</p>\n<pre>major.minor.patch<br>1.0.2</pre>\n<p>Major, minor and patch lerin her biri başka bir tür releaseyi temsil eder. Büyük güncellemeler Major release iken featureler minor release ve fixler ise patch releasesi gibi düşünebilirsiniz.</p>\n<p>npm, sırasıyla hangi patch veya minor versionun kullanılacağını belirlemek için tilde işareti (~) ve caret işareti (^) kullanır.</p>\n<p>Eğer sen package.json dosyasında yüklediğin bir paketin yanında ~1.0.2 bunun gibi bir işaret görüyorsan bu npm paketi yüklerken ya 1.0.2 sürümünü yükleyeceğini yada varsa 1.0.4 bunun gibi son gelmiş patch sürümünü yükleyeceğini belirtir. ^1.0.2 bu işareti görüyorsan ise npm ya 1.0.2 ya bu sürümü yükleyeceğini yada varsa 1.1.0 gibi son patch sürümünü yükler.</p>\n<p>Original Article<br><a href=\"https://michaelsoolee.com/npm-package-tilde-caret/\">https://michaelsoolee.com/npm-package-tilde-caret/</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6e9de27b447b\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p><strong>What’s the difference between a tilde (~) and a caret (^) in a npm package.json file?</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UM73V7OTZ1j9x2NnkySrJA.png\"></figure><p>Eğer node.js ve npm packaga manageri kullanıp bir Javascript uygulaması geliştiriyorsanız aşağıda ki gibi package.json dosyalarına aşinasınızdır.</p>\n<pre>{<br>  \"devDependencies\": {<br>    \"ember-cli\": \"~2.14.0\"<br>  }<br>}</pre>\n<p>npm package.json dosyasında uygulamamızın ihtiyacı olan kullandığımız paketleri belirtir. Ve bu paketler <a href=\"http://semver.org/\">semver syntax</a> ile sürüm version numaralandırması ile sürümlendirilirler aşağıdaki gibi.</p>\n<pre>major.minor.patch<br>1.0.2</pre>\n<p>Major, minor and patch lerin her biri başka bir tür releaseyi temsil eder. Büyük güncellemeler Major release iken featureler minor release ve fixler ise patch releasesi gibi düşünebilirsiniz.</p>\n<p>npm, sırasıyla hangi patch veya minor versionun kullanılacağını belirlemek için tilde işareti (~) ve caret işareti (^) kullanır.</p>\n<p>Eğer sen package.json dosyasında yüklediğin bir paketin yanında ~1.0.2 bunun gibi bir işaret görüyorsan bu npm paketi yüklerken ya 1.0.2 sürümünü yükleyeceğini yada varsa 1.0.4 bunun gibi son gelmiş patch sürümünü yükleyeceğini belirtir. ^1.0.2 bu işareti görüyorsan ise npm ya 1.0.2 ya bu sürümü yükleyeceğini yada varsa 1.1.0 gibi son patch sürümünü yükler.</p>\n<p>Original Article<br><a href=\"https://michaelsoolee.com/npm-package-tilde-caret/\">https://michaelsoolee.com/npm-package-tilde-caret/</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6e9de27b447b\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["caret", "mean", "tilde", "package", "npm"],
    "slug": "6e9de27b447b"
  },
  {
    "title": "Test - Super Simple Start to ESModules in Node.js",
    "pubDate": "2021-06-18 07:03:06",
    "link": "https://mucahidyazar.medium.com/super-simple-start-to-esmodules-in-node-js-e2bdc6a8489c?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/e2bdc6a8489c",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/1024/0*in3EvvxkSMhiyeV2.png",
    "description": "\n<p>Node.js’in tüm desteklenen versiyonları artık ESModules’ü destekliyor. Bu yazımızda bunu nasıl çok basit bir şekilde yapacağımızı göstereceğim.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*in3EvvxkSMhiyeV2.png\"></figure><p>30 Nisan 2021'de, Node v10 resmi olarak “kullanım ömrünün sonuna” ulaşacak (<a href=\"https://nodejs.org/en/about/releases/\"><strong>Node Release</strong></a> sayfasından daha fazla bilgi edinin). Bu heyecan verici çünkü Node.js JavaScript runtime desteklenen her sürümünün, Node’un resmi EcmaScript Modüllerini destekleyeceği anlamına geliyor! Bu değişiklikle ilgili karışık duygular var (bazıları Node.js ekosisteminde CommonJS’ye bağlı kalmamızı tercih ederdi), ancak konuyla ilgili fikriniz ne olursa olsun, ESModüller burada ve onlar gelecek. Öyleyse onları bir Node.js ortamında nasıl kullanacağımızı öğrenelim.</p>\n<p>Note: You might be interested in my companion post <a href=\"https://kentcdodds.com/blog/super-simple-start-to-es-modules-in-the-browser\">Super Simple Start to ESModules in the Browser</a></p>\n<p>First, we need the JavaScript we want to run:</p>\n<p>İlk olarak ihtiyacımız olan, çalıştıracağımız get-files.js isimli javascript dosyasını aşağıya bırakıyorum. Ve burada dikkat edin “import ve export” kullanıyoruz yani modern javascript ES Modules özelliklerini kullanıyoruz.</p>\n<p>Burada olan şu:</p>\n<ul><li>getFiles fonksiyonu bir dizin yani path parametresi alıyor. Ve bu dizindeki dosyaların bazı özelliklerini bir array içinde dönüyor bize. Örnek array yapısı aşağıdaki gibi olacak. Yani typeda dosya veya klasör olduğu, filepathda dosya yolu, content’de ise odosyanın içindeki herşeyi satır satır string olarak bize dönecek.<br>[{ type: ‘file’, filepath: ‘package.json’, content: ‘…’ }]</li></ul>\n<a href=\"https://medium.com/media/de6e1a2cc31c5e49db2cf611832c704e/href\">https://medium.com/media/de6e1a2cc31c5e49db2cf611832c704e/href</a><p>Next, let’s make a JavaScript file that imports this and runs it:</p>\n<p>Sonra bir index dosyası oluşturup yukarıdaki util fonksiyonumuzu import ederek kullanalım.</p>\n<a href=\"https://medium.com/media/e3657bb1d52841cf7856a51edeeceaf7/href\">https://medium.com/media/e3657bb1d52841cf7856a51edeeceaf7/href</a><p>Eğer hiçbir ayar yapmadan çalıştırırsak aşağıda ki konsol hatasını alacağız. Aşağıdaki kodla çalıştırıp terminal hatasını göreceksiniz.<br><strong>node index.js</strong></p>\n<pre>node .<br>2(node:5369) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.<br>3(Use `node --trace-warnings ...` to show where the warning was created)<br>4/Users/kentcdodds/Desktop/super-simple-start-to-esm-in-node/index.js:1<br>5import {getFiles} from './get-files.js'<br>6^^^^^^<br>7<br>8SyntaxError: Cannot use import statement outside a module<br>9    at wrapSafe (internal/modules/cjs/loader.js:979:16)<br>10    at Module._compile (internal/modules/cjs/loader.js:1027:27)<br>11    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)<br>12    at Module.load (internal/modules/cjs/loader.js:928:32)<br>13    at Function.Module._load (internal/modules/cjs/loader.js:769:14)<br>14    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)<br>15    at internal/main/run_main_module.js:17:47</pre>\n<p>Node.js projesi bazen breaking changelerle karşılaşacaktır ve bu normaldir, ancak burada olan ise bir non-starter durumudur yani hiçbir breaking change ile karşılaşmadan çalışmama durumudur. Bu yüzden ESM kullanmak bir seçimdir. Fakat bu şekilde kullanmak istersek burada 2 seçeneğimiz olduğunu biliyoruz.</p>\n<p>Birincisi, dosyalarımızın uzantısını .Js’den .mjs’ye geçerek başarıyla import kullanan .mjs dosyalarımızı çalıştırabiliriz.</p>\n<p>İkincisi en basiti “type”: “module” satırını bir package.json ekleyerek .js dosyalarımızı süper basit bir şekilde başarıyla çalıştırabiliriz.</p>\n<p>İkinci seçenekle gidelim, böylece tüm dosyalarımızı yeniden adlandırmak zorunda kalmayalım. Bunu bir package.json içine koyun:</p>\n<pre>{<br>  \"type\": \"module\"<br>}</pre>\n<p>Ve şimdi tekrar çalıştırıyoruz. Ve sonuç aşağıda ki gibi olacaktır sizde de eminim :)</p>\n<pre>node .<br>2[<br>3  {<br>4    type: 'file',<br>5    filepath: 'get-files.js',<br>6    content: \"import path from 'path'\\n\" +<br>7      // clipped for brevity<br>8      'export {getFiles}\\n'<br>9  },<br>10  {<br>11    type: 'file',<br>12    filepath: 'index.js',<br>13    content: \"import {getFiles} from './get-files.js'\\n\" +<br>14      '\\n' +<br>15      \"console.log(await getFiles('.'))\\n\"<br>16  },<br>17  {<br>18    type: 'file',<br>19    filepath: 'package.json',<br>20    content: '{\\n  \"type\": \"module\"\\n}\\n'<br>21  }<br>22]</pre>\n<p>Ve işte bu kadar basit bir şekilde doğal native ESM kodlarımızı node.js ile çalıştırıyoruz.</p>\n<p>Eğer official destek duyurusunu ve detaylarını okumak isterseniz, detaylara aşağıdaki linkten ulaşabilirsiniz.<br><a href=\"https://nodejs.medium.com/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663\">https://nodejs.medium.com/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663</a></p>\n<p>Bu makalenin orjinali için ayrıca aşağıdaki linkten göz atabilirsiniz.<br><a href=\"https://kentcdodds.com/blog/super-simple-start-to-es-modules-in-node-js\">https://kentcdodds.com/blog/super-simple-start-to-es-modules-in-node-js</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e2bdc6a8489c\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>Node.js’in tüm desteklenen versiyonları artık ESModules’ü destekliyor. Bu yazımızda bunu nasıl çok basit bir şekilde yapacağımızı göstereceğim.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*in3EvvxkSMhiyeV2.png\"></figure><p>30 Nisan 2021'de, Node v10 resmi olarak “kullanım ömrünün sonuna” ulaşacak (<a href=\"https://nodejs.org/en/about/releases/\"><strong>Node Release</strong></a> sayfasından daha fazla bilgi edinin). Bu heyecan verici çünkü Node.js JavaScript runtime desteklenen her sürümünün, Node’un resmi EcmaScript Modüllerini destekleyeceği anlamına geliyor! Bu değişiklikle ilgili karışık duygular var (bazıları Node.js ekosisteminde CommonJS’ye bağlı kalmamızı tercih ederdi), ancak konuyla ilgili fikriniz ne olursa olsun, ESModüller burada ve onlar gelecek. Öyleyse onları bir Node.js ortamında nasıl kullanacağımızı öğrenelim.</p>\n<p>Note: You might be interested in my companion post <a href=\"https://kentcdodds.com/blog/super-simple-start-to-es-modules-in-the-browser\">Super Simple Start to ESModules in the Browser</a></p>\n<p>First, we need the JavaScript we want to run:</p>\n<p>İlk olarak ihtiyacımız olan, çalıştıracağımız get-files.js isimli javascript dosyasını aşağıya bırakıyorum. Ve burada dikkat edin “import ve export” kullanıyoruz yani modern javascript ES Modules özelliklerini kullanıyoruz.</p>\n<p>Burada olan şu:</p>\n<ul><li>getFiles fonksiyonu bir dizin yani path parametresi alıyor. Ve bu dizindeki dosyaların bazı özelliklerini bir array içinde dönüyor bize. Örnek array yapısı aşağıdaki gibi olacak. Yani typeda dosya veya klasör olduğu, filepathda dosya yolu, content’de ise odosyanın içindeki herşeyi satır satır string olarak bize dönecek.<br>[{ type: ‘file’, filepath: ‘package.json’, content: ‘…’ }]</li></ul>\n<a href=\"https://medium.com/media/de6e1a2cc31c5e49db2cf611832c704e/href\">https://medium.com/media/de6e1a2cc31c5e49db2cf611832c704e/href</a><p>Next, let’s make a JavaScript file that imports this and runs it:</p>\n<p>Sonra bir index dosyası oluşturup yukarıdaki util fonksiyonumuzu import ederek kullanalım.</p>\n<a href=\"https://medium.com/media/e3657bb1d52841cf7856a51edeeceaf7/href\">https://medium.com/media/e3657bb1d52841cf7856a51edeeceaf7/href</a><p>Eğer hiçbir ayar yapmadan çalıştırırsak aşağıda ki konsol hatasını alacağız. Aşağıdaki kodla çalıştırıp terminal hatasını göreceksiniz.<br><strong>node index.js</strong></p>\n<pre>node .<br>2(node:5369) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.<br>3(Use `node --trace-warnings ...` to show where the warning was created)<br>4/Users/kentcdodds/Desktop/super-simple-start-to-esm-in-node/index.js:1<br>5import {getFiles} from './get-files.js'<br>6^^^^^^<br>7<br>8SyntaxError: Cannot use import statement outside a module<br>9    at wrapSafe (internal/modules/cjs/loader.js:979:16)<br>10    at Module._compile (internal/modules/cjs/loader.js:1027:27)<br>11    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)<br>12    at Module.load (internal/modules/cjs/loader.js:928:32)<br>13    at Function.Module._load (internal/modules/cjs/loader.js:769:14)<br>14    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)<br>15    at internal/main/run_main_module.js:17:47</pre>\n<p>Node.js projesi bazen breaking changelerle karşılaşacaktır ve bu normaldir, ancak burada olan ise bir non-starter durumudur yani hiçbir breaking change ile karşılaşmadan çalışmama durumudur. Bu yüzden ESM kullanmak bir seçimdir. Fakat bu şekilde kullanmak istersek burada 2 seçeneğimiz olduğunu biliyoruz.</p>\n<p>Birincisi, dosyalarımızın uzantısını .Js’den .mjs’ye geçerek başarıyla import kullanan .mjs dosyalarımızı çalıştırabiliriz.</p>\n<p>İkincisi en basiti “type”: “module” satırını bir package.json ekleyerek .js dosyalarımızı süper basit bir şekilde başarıyla çalıştırabiliriz.</p>\n<p>İkinci seçenekle gidelim, böylece tüm dosyalarımızı yeniden adlandırmak zorunda kalmayalım. Bunu bir package.json içine koyun:</p>\n<pre>{<br>  \"type\": \"module\"<br>}</pre>\n<p>Ve şimdi tekrar çalıştırıyoruz. Ve sonuç aşağıda ki gibi olacaktır sizde de eminim :)</p>\n<pre>node .<br>2[<br>3  {<br>4    type: 'file',<br>5    filepath: 'get-files.js',<br>6    content: \"import path from 'path'\\n\" +<br>7      // clipped for brevity<br>8      'export {getFiles}\\n'<br>9  },<br>10  {<br>11    type: 'file',<br>12    filepath: 'index.js',<br>13    content: \"import {getFiles} from './get-files.js'\\n\" +<br>14      '\\n' +<br>15      \"console.log(await getFiles('.'))\\n\"<br>16  },<br>17  {<br>18    type: 'file',<br>19    filepath: 'package.json',<br>20    content: '{\\n  \"type\": \"module\"\\n}\\n'<br>21  }<br>22]</pre>\n<p>Ve işte bu kadar basit bir şekilde doğal native ESM kodlarımızı node.js ile çalıştırıyoruz.</p>\n<p>Eğer official destek duyurusunu ve detaylarını okumak isterseniz, detaylara aşağıdaki linkten ulaşabilirsiniz.<br><a href=\"https://nodejs.medium.com/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663\">https://nodejs.medium.com/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663</a></p>\n<p>Bu makalenin orjinali için ayrıca aşağıdaki linkten göz atabilirsiniz.<br><a href=\"https://kentcdodds.com/blog/super-simple-start-to-es-modules-in-node-js\">https://kentcdodds.com/blog/super-simple-start-to-es-modules-in-node-js</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e2bdc6a8489c\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": [
      "nodejs",
      "modules",
      "import-export",
      "javascript",
      "node-js-tutorial"
    ],
    "slug": "e2bdc6a8489c"
  },
  {
    "title": "Test - Docker - Building Multi Container Applications",
    "pubDate": "2021-06-11 07:02:43",
    "link": "https://mucahidyazar.medium.com/docker-building-multi-container-applications-4e56b97ee3ce?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/4e56b97ee3ce",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/1000/0*M3IzARZRrGSXtXpz.png",
    "description": "\n<p>Bu yazımda diğer 2 docker serisinden öğrendiklerimizi kullanarak, backend, frontend ve database containlerları oluşturup, 3 containerı birbirleriyle iletişime geçirip uygulamamızı kurmayı, ayağa kaldırmayı öğreneceğiz ve öğrendiklerimiz içinde güzel bir pratik olacak bu.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*M3IzARZRrGSXtXpz.png\"></figure><h3>STEP 1 - Get started</h3>\n<p><a href=\"https://github.com/mucahidyazar/docker\">https://github.com/mucahidyazar/docker</a></p>\n<ul>\n<li>Yukarıdaki linkten gerekli repoyu indiriyoruz.<br>git clone <a href=\"https://github.com/mucahidyazar/docker.git\">https://github.com/mucahidyazar/docker.git</a>\n</li>\n<li>Ve tutorials branchine geçiyoruz.<br>git checkout tutorials</li>\n<li>Be burada multi-container adlı dizine geliyoruz. Burada 2 klasör var. 1. si başlangıç yani starter klasörü, diğeri bitiş yani fnished dosyalarımız.</li>\n<li>Takıldığınız yerde fnished klasörüne bakıp kopya çekebilirsiniz.</li>\n</ul>\n<h3>STEP 2 - .dockerignore</h3>\n<ul><li>İlk önce backend ve frontend klasörlerimize .dockerignore klasörü oluşturalım. Ve aşağıdaki gibi dockerın dokunmaması gereken dosya ve klasörleri belirleyelim. Ben standart olarak aşağıdaki şekilde oluşturuyorum.</li></ul>\n<a href=\"https://medium.com/media/c1245081a5ce0ac679e41b0f0b536c94/href\">https://medium.com/media/c1245081a5ce0ac679e41b0f0b536c94/href</a><h3>STEP 3 - Network</h3>\n<ul>\n<li>İlk önce containerlarımızın birbirleriyle iletişime geçecekleri networku oluşturalım. Ben multi adında bir network oluşturuyorum.<br><strong>docker volume create multi</strong>\n</li>\n<li>Daha sonra listeleyip volumemizin oluşturulduğundan emin olalım.<br><strong>docker volume ls</strong>\n</li>\n</ul>\n<h3>STEP 3 - Dockerfile (for mongodb)</h3>\n<ul><li>Şimdi ilk container olarak mongo imagesinde bir mongodb çalışan container ayağa kaldıracağız.</li></ul>\n<blockquote><strong>docker run \\ <br>-v data:/data/db \\ <br>-e MONGO_INITDB_ROOT_USERNAME=root \\ <br>-e MONGO_INITDB_ROOT_PASSWORD=secret \\<br>--name multi-mongo-container \\ <br>--network multi \\<br>--rm \\ <br>-d \\ <br>mongo</strong></blockquote>\n<p>Yukarıda ilk olarak data adında bir volume oluşturuyoruz ve mongo containerındaki /data/db yolunu bu data volumesine stroage olmasını yedeklemesini istiyoruz.<br>--name multi-mongo-container adıyla adlandırmak istediğimi belirtiyorum bu containerın.<br>-d ile detach modda çalıştırıyorum yani çalıştırdıktan sonra mongo terminalde kalmasın istiyorum.<br>--rm ile containerın stop olduğunda otomatik olarak silinmesini istiyoruz.<br>--network ile yukarıda oluşturduğumuz multi networkune mongo imagemizi başlatacağımız containerı bağlamak istiyoruz.<br>-e ile mongo database için belirlememiz gereken 2 tane environment variable’ı belirliyoruz. Bu environmentdaki varaiblesları daha sonra backend projemizde app.js içinde mongo databaseye bağlanmak için kullanacağız.<br>ve son olarak mongo imagesini çalıştırmasını söylüyoruz. Bu makinamızda yoksa dockerhub üzerinden indirir ve bu komutlarla çalıştırır.</p>\n<ul><li>Ve şimdi yine aşağıdaki kodla çalışan containerlarımızı görerek imageyi başarıyla çalıştırdığımızdan emin olalım.<br><strong>docker ps -a</strong>\n</li></ul>\n<h3>STEP 4 - Dockerfile (for backend)</h3>\n<ul><li>Ben aşağıda ki gibi Dockerfilemi oluşturuyorum. Daha önceki derslerde buradaki kavramları anlattığım için burayı detaylı olarak sizlere anlatmayacağım.</li></ul>\n<a href=\"https://medium.com/media/8273c4a7e4273169b2681969c191e598/href\">https://medium.com/media/8273c4a7e4273169b2681969c191e598/href</a><ul>\n<li>Fakat yukarıda görüyoruz ki node app.js yaparak uygulamamızı başlatıyoruz. Bu uygulamamızda bir değişiklik olduğunda server taraflı değişikliklerde yeniden çalıştırılmayacağı için değişiklikleri yakalayabilmek için yeniden containerımızı başlatmak zorunda kalırız. Bu yüzden burada nodemon adlı package ile değişiklik olduğunda backend servisimizin kendisini otomatik olarak yenilemesini sağlayan paketi yükleyeceğim.</li>\n<li>Önce backend dizinine geliyoruz terminalde ve aşağıda ki kodla packagemizi yükleyeceğiz.<br>yarn add -D nodemon<br>npm install --save-dev nodemon</li>\n<li>Daha sonra package.jsonu aşağıdaki şekilde düzenliyorum.</li>\n</ul>\n<a href=\"https://medium.com/media/b9817f95ea52ac87972f401f498d6394/href\">https://medium.com/media/b9817f95ea52ac87972f401f498d6394/href</a><ul><li>Ve Dockerfilemizdede CMD komutunu aşağıdaki şekildeki gibi düzeltiyoruz.</li></ul>\n<a href=\"https://medium.com/media/cfe2bb215b43cf0d94aa070805cecbbf/href\">https://medium.com/media/cfe2bb215b43cf0d94aa070805cecbbf/href</a><ul>\n<li>Ve şimdi de mongo imagesinde tanımladığımız environment variablesları backend içinde, config klasörü ve içindede env klasörü oluşturduktan sonra dev.env dosyası açarak içine aşağıdaki varaiblesları tanımlayalım.</li>\n<li>Burada DB_NAME ve DB_PASSWORD mongo conta’nerımızda tanımladığımı environment variableslar olmalı yoksa erişimi sağlayamayız. Daha sonra bağlanacağımız databasenin host adresini DB_HOST, port adresini DB_PORT, ve adınıda DB_NAME olarak tanımlıyoruz.</li>\n</ul>\n<a href=\"https://medium.com/media/cc86cd548620589adbbc82609678eb20/href\">https://medium.com/media/cc86cd548620589adbbc82609678eb20/href</a><ul>\n<li>Tabi bu variablesları kullanabilmek için node.js projemizde dotenv gibi ekstra paketleri yüklememiz ve kullanmamız gerekecek. Ben dotenv yi yükleyeceğim.<br>yarn add dotenv<br>npm install dotenv</li>\n<li>Ve app.js içine gelerek yüklediğimiz bu dotenv modülünü require ile aşağıdaki gibi projenin en başına ekleyerek, içine dev.env dosyamızın yolunu yani pathini veriyoruz.</li>\n</ul>\n<a href=\"https://medium.com/media/36805c025ea6ac8c9b571d59d0414893/href\">https://medium.com/media/36805c025ea6ac8c9b571d59d0414893/href</a><ul>\n<li>Ve daha sonra yine app.js içinde mongo databasesine bağlandığımız kod dizininde bu dev.environment variablesları buraya veriyoruz. Ve bu varaibleslar mongoda tanımladığımız varaibleslarla eşleşince başarıyla bağlantı sağlayabileceğiz.</li>\n<li>Ve ikinci olarak da mongo container adımızı database bağlantı hostu için ayarladığımı DB_HOST environment variablesını ve portunu DB_PORT’u aralarında “:” işareti olacak şekilde yazıyoruz. Çünkü backendide aynı networke bağladığımızda container adıyla mongoya erişebiliyor olacağız.</li>\n<li>Sonrada bağlanacağımız database ismini atadığımız environment variable’ı yazıyoruz.</li>\n<li>Ve en son olarakda “?authSource=admin” diyererek ayarlamamızı yapıyoruz. Burası user credentialsala birlikte collection’a sahip databasenin adıdır. Kısaca username ve passwordların ayarlandığı yerdir.</li>\n</ul>\n<a href=\"https://medium.com/media/6e4a4e1468f73b29cf1878dd7de22092/href\">https://medium.com/media/6e4a4e1468f73b29cf1878dd7de22092/href</a><ul>\n<li>Ve şimdi tüm ayarlamalarımızı yaptıktan sonra imagemizi oluşturabilir ve containerımızı çalıştırabiliriz.</li>\n<li>İlk önce şağıdaki kodla imagemizi oluşturuyoruz.<br>docker build -t multi-backend-image .</li>\n</ul>\n<p><strong>docker run <br>-p 80:80 \\<br>-v ${pwd}:/app \\<br>-v logs:/app/logs \\<br>-v /app/node_modules \\<br>--env-file ./config/env/dev.env \\<br>--name multi-backend-container \\<br>--network multi \\<br>--rm \\<br>multi-backend-image</strong></p>\n<ul><li>Ve şimdide yukarıdaki kodla containerımızı çalıştırıyoruz.<br><strong>--rm</strong> ile containerımızın stop olunca silinmesini söylüyoruz<br><strong>--network </strong>ile containerımızı multi isimli networke dahil ediyoruz<br><strong>-p</strong> ile port binding yaparak containerımızı kendi <strong>OS sistemimizdeki 80 ile</strong> çalıştığı <strong>VM(Virtual Machine)’deki 80</strong> portlarını bind etmesini bağlamasını söylüyoruz. Böylece containerın çalıştığı VM’deki 80 portu bizim makinamızdaki 80 portuna yansıyacak. Ve böylelikle localhost adresinden direkt olarak container’a erişim sağlayabileceğiz.<br><strong>--name</strong> ile containerımızı identifier ettiğimiz bir isimlendirme uyguluyoruz yani containerımızı isimlendiriyoruz. Burada backend için multi-backend-container koydum ben düzenli olması için.<br><strong>-v ${pwd}:/app volume</strong> belirlemesi ile şuan ki dizinde yani kodu yazdığımız dizindeki, yani backend klasörünün içindeki tüm herşeyi Dockerdaki /app klasörüne yani WORKDIR’e bağlamasını istiyoruz. Böylelikle localde yaptığımız değişiklikler anında, containerımızın çalıştığı VM’ye yansıyabilecek.<br><strong>-v logs:/app/logs</strong> volume tanımlaması ilede, logs adında bir volume oluşturmasını söylüyoruz Docker’a, ve bu logs volumesine, conteinerımızın logladığı VM’de çalışma dizindeki logların tutulduğu pathdeki(/app/logs) logları saklamasını söylüyoruz.<br><strong>-v /app/node_modules</strong> ile containerımızın npm install yaptıktan sonra buradaki node_modules dosyalarını anonymous volume oluşturarak saklamasını istiyoruz.<br><strong>--env-file</strong> ilede backend projemizin çalıştığı zaman ihtiyacı olacak environment varaiblesları içeren env dosyasının yolunu vererek, environment variableslarını dockera tanımlamasını söylüyoruz.<br>Ve son olarak image adını yazıyoruz.</li></ul>\n<h3>STEP 5 - Dockerfile (for frontend)</h3>\n<p>Backend ve mongo-containerımızı ayağa kaldırdığımıza göre şimdi sıra frontend uygulamamızı Dockerize etmeye geldi.</p>\n<ul><li>Dockerfile’mi oluşturup içini aşağıda ki gibi ayarladım.</li></ul>\n<a href=\"https://medium.com/media/78305b4fee423fd9cf516e45370f56f2/href\">https://medium.com/media/78305b4fee423fd9cf516e45370f56f2/href</a><ul><li>Daha sonra imagemizi build alıyoruz aşağıda ki kodla.<br><strong>docker build -t multi-frontend-image .</strong>\n</li></ul>\n<p><strong>docker run -v ${pwd}/src:/app/src --rm -it --name multi-frontend-container -p 3000:3000 multi-frontend-image</strong></p>\n<ul>\n<li>Ve son olarak da aşağıda ki kodu kullanarak oluşturduğumuz uygulamamızın imagesini containerımızı çalıştırarak kullanıyoruz.<br><strong>-v ${pwd}/src:/app/src</strong> ile uygulamamızın kendi OS sistemimiz üzerindeki src yolunu, pathini, containerımızın sistemi üzerindeki /app/src dizini ile bind ediyoruz bağlıyoruz. Böylelikle react uygulamamız localde yaptığımız değişiklikleri anında containera yansıtacaktır.<br><strong>--rm</strong> ile containerımızın stop olunca silinmesini söylüyoruz<br><strong>--network </strong>ile containerımızı multi isimli networke dahil ediyoruz<br><strong>-it</strong> ile interactive mod ile containerımızı başlatacağız ve böylelikle react uygulaması çalışırken teminali izleyip başarıyla başlayıp başlamadığını görebileceğiz.<br><strong> --name</strong> ile containerımızı identifier ettiğimiz bir isimlendirme uyguluyoruz yani containerımızı isimlendiriyoruz. Burada frontend için multi-frontend-container koydum ben düzenli olması için.<br><strong>-p</strong> ile port binding yaparak containerımızı kendi <strong>OS sistemimizdeki 3000 ile</strong> çalıştığı <strong>VM(Virtual Machine)’deki 3000</strong> portlarını bind etmesini bağlamasını söylüyoruz. Böylece containerın çalıştığı VM’deki 3000 portu bizim makinamızdaki 3000 portuna yansıyacak. Ve böylelikle localhost adresinden direkt olarak container’a erişim sağlayabileceğiz.<br>Ve son olarak image adını yazıyoruz.</li>\n<li>Ve evet tüm adımları tamamlayıp uygulamalarımızı başarıyla Dockerize ettik. Final görüntüsü aşağıda ki gibi.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*nfHCiqB_NdyZLD8XttzdZQ.png\"></figure><ul><li>Peki biz bu yazımız da neler yaptık?<br>3 container çalıştırdık.<br>Network kurup containerlarımız arası iletişim kanalı iletişim kanalı oluşturup, bu kanal üzerinden haberleştik.<br>2 tane Dockerfile oluşturduk.<br>3 containerımıza özel farklı volumeler oluşturduk.<br>Bir önceki yazılardan öğrendiklerimizi fazlasıyla tekrar ettik.</li></ul>\n<p>Bu yazımda anlatacaklarım bu kadardı. Bir sonra ki örnekte bunu docker-compose kullanarak nasıl çok daha az terminal kodu yazarak yapacağız bunu göreceğiz. Esen kalın.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4e56b97ee3ce\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>Bu yazımda diğer 2 docker serisinden öğrendiklerimizi kullanarak, backend, frontend ve database containlerları oluşturup, 3 containerı birbirleriyle iletişime geçirip uygulamamızı kurmayı, ayağa kaldırmayı öğreneceğiz ve öğrendiklerimiz içinde güzel bir pratik olacak bu.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*M3IzARZRrGSXtXpz.png\"></figure><h3>STEP 1 - Get started</h3>\n<p><a href=\"https://github.com/mucahidyazar/docker\">https://github.com/mucahidyazar/docker</a></p>\n<ul>\n<li>Yukarıdaki linkten gerekli repoyu indiriyoruz.<br>git clone <a href=\"https://github.com/mucahidyazar/docker.git\">https://github.com/mucahidyazar/docker.git</a>\n</li>\n<li>Ve tutorials branchine geçiyoruz.<br>git checkout tutorials</li>\n<li>Be burada multi-container adlı dizine geliyoruz. Burada 2 klasör var. 1. si başlangıç yani starter klasörü, diğeri bitiş yani fnished dosyalarımız.</li>\n<li>Takıldığınız yerde fnished klasörüne bakıp kopya çekebilirsiniz.</li>\n</ul>\n<h3>STEP 2 - .dockerignore</h3>\n<ul><li>İlk önce backend ve frontend klasörlerimize .dockerignore klasörü oluşturalım. Ve aşağıdaki gibi dockerın dokunmaması gereken dosya ve klasörleri belirleyelim. Ben standart olarak aşağıdaki şekilde oluşturuyorum.</li></ul>\n<a href=\"https://medium.com/media/c1245081a5ce0ac679e41b0f0b536c94/href\">https://medium.com/media/c1245081a5ce0ac679e41b0f0b536c94/href</a><h3>STEP 3 - Network</h3>\n<ul>\n<li>İlk önce containerlarımızın birbirleriyle iletişime geçecekleri networku oluşturalım. Ben multi adında bir network oluşturuyorum.<br><strong>docker volume create multi</strong>\n</li>\n<li>Daha sonra listeleyip volumemizin oluşturulduğundan emin olalım.<br><strong>docker volume ls</strong>\n</li>\n</ul>\n<h3>STEP 3 - Dockerfile (for mongodb)</h3>\n<ul><li>Şimdi ilk container olarak mongo imagesinde bir mongodb çalışan container ayağa kaldıracağız.</li></ul>\n<blockquote><strong>docker run \\ <br>-v data:/data/db \\ <br>-e MONGO_INITDB_ROOT_USERNAME=root \\ <br>-e MONGO_INITDB_ROOT_PASSWORD=secret \\<br>--name multi-mongo-container \\ <br>--network multi \\<br>--rm \\ <br>-d \\ <br>mongo</strong></blockquote>\n<p>Yukarıda ilk olarak data adında bir volume oluşturuyoruz ve mongo containerındaki /data/db yolunu bu data volumesine stroage olmasını yedeklemesini istiyoruz.<br>--name multi-mongo-container adıyla adlandırmak istediğimi belirtiyorum bu containerın.<br>-d ile detach modda çalıştırıyorum yani çalıştırdıktan sonra mongo terminalde kalmasın istiyorum.<br>--rm ile containerın stop olduğunda otomatik olarak silinmesini istiyoruz.<br>--network ile yukarıda oluşturduğumuz multi networkune mongo imagemizi başlatacağımız containerı bağlamak istiyoruz.<br>-e ile mongo database için belirlememiz gereken 2 tane environment variable’ı belirliyoruz. Bu environmentdaki varaiblesları daha sonra backend projemizde app.js içinde mongo databaseye bağlanmak için kullanacağız.<br>ve son olarak mongo imagesini çalıştırmasını söylüyoruz. Bu makinamızda yoksa dockerhub üzerinden indirir ve bu komutlarla çalıştırır.</p>\n<ul><li>Ve şimdi yine aşağıdaki kodla çalışan containerlarımızı görerek imageyi başarıyla çalıştırdığımızdan emin olalım.<br><strong>docker ps -a</strong>\n</li></ul>\n<h3>STEP 4 - Dockerfile (for backend)</h3>\n<ul><li>Ben aşağıda ki gibi Dockerfilemi oluşturuyorum. Daha önceki derslerde buradaki kavramları anlattığım için burayı detaylı olarak sizlere anlatmayacağım.</li></ul>\n<a href=\"https://medium.com/media/8273c4a7e4273169b2681969c191e598/href\">https://medium.com/media/8273c4a7e4273169b2681969c191e598/href</a><ul>\n<li>Fakat yukarıda görüyoruz ki node app.js yaparak uygulamamızı başlatıyoruz. Bu uygulamamızda bir değişiklik olduğunda server taraflı değişikliklerde yeniden çalıştırılmayacağı için değişiklikleri yakalayabilmek için yeniden containerımızı başlatmak zorunda kalırız. Bu yüzden burada nodemon adlı package ile değişiklik olduğunda backend servisimizin kendisini otomatik olarak yenilemesini sağlayan paketi yükleyeceğim.</li>\n<li>Önce backend dizinine geliyoruz terminalde ve aşağıda ki kodla packagemizi yükleyeceğiz.<br>yarn add -D nodemon<br>npm install --save-dev nodemon</li>\n<li>Daha sonra package.jsonu aşağıdaki şekilde düzenliyorum.</li>\n</ul>\n<a href=\"https://medium.com/media/b9817f95ea52ac87972f401f498d6394/href\">https://medium.com/media/b9817f95ea52ac87972f401f498d6394/href</a><ul><li>Ve Dockerfilemizdede CMD komutunu aşağıdaki şekildeki gibi düzeltiyoruz.</li></ul>\n<a href=\"https://medium.com/media/cfe2bb215b43cf0d94aa070805cecbbf/href\">https://medium.com/media/cfe2bb215b43cf0d94aa070805cecbbf/href</a><ul>\n<li>Ve şimdi de mongo imagesinde tanımladığımız environment variablesları backend içinde, config klasörü ve içindede env klasörü oluşturduktan sonra dev.env dosyası açarak içine aşağıdaki varaiblesları tanımlayalım.</li>\n<li>Burada DB_NAME ve DB_PASSWORD mongo conta’nerımızda tanımladığımı environment variableslar olmalı yoksa erişimi sağlayamayız. Daha sonra bağlanacağımız databasenin host adresini DB_HOST, port adresini DB_PORT, ve adınıda DB_NAME olarak tanımlıyoruz.</li>\n</ul>\n<a href=\"https://medium.com/media/cc86cd548620589adbbc82609678eb20/href\">https://medium.com/media/cc86cd548620589adbbc82609678eb20/href</a><ul>\n<li>Tabi bu variablesları kullanabilmek için node.js projemizde dotenv gibi ekstra paketleri yüklememiz ve kullanmamız gerekecek. Ben dotenv yi yükleyeceğim.<br>yarn add dotenv<br>npm install dotenv</li>\n<li>Ve app.js içine gelerek yüklediğimiz bu dotenv modülünü require ile aşağıdaki gibi projenin en başına ekleyerek, içine dev.env dosyamızın yolunu yani pathini veriyoruz.</li>\n</ul>\n<a href=\"https://medium.com/media/36805c025ea6ac8c9b571d59d0414893/href\">https://medium.com/media/36805c025ea6ac8c9b571d59d0414893/href</a><ul>\n<li>Ve daha sonra yine app.js içinde mongo databasesine bağlandığımız kod dizininde bu dev.environment variablesları buraya veriyoruz. Ve bu varaibleslar mongoda tanımladığımız varaibleslarla eşleşince başarıyla bağlantı sağlayabileceğiz.</li>\n<li>Ve ikinci olarak da mongo container adımızı database bağlantı hostu için ayarladığımı DB_HOST environment variablesını ve portunu DB_PORT’u aralarında “:” işareti olacak şekilde yazıyoruz. Çünkü backendide aynı networke bağladığımızda container adıyla mongoya erişebiliyor olacağız.</li>\n<li>Sonrada bağlanacağımız database ismini atadığımız environment variable’ı yazıyoruz.</li>\n<li>Ve en son olarakda “?authSource=admin” diyererek ayarlamamızı yapıyoruz. Burası user credentialsala birlikte collection’a sahip databasenin adıdır. Kısaca username ve passwordların ayarlandığı yerdir.</li>\n</ul>\n<a href=\"https://medium.com/media/6e4a4e1468f73b29cf1878dd7de22092/href\">https://medium.com/media/6e4a4e1468f73b29cf1878dd7de22092/href</a><ul>\n<li>Ve şimdi tüm ayarlamalarımızı yaptıktan sonra imagemizi oluşturabilir ve containerımızı çalıştırabiliriz.</li>\n<li>İlk önce şağıdaki kodla imagemizi oluşturuyoruz.<br>docker build -t multi-backend-image .</li>\n</ul>\n<p><strong>docker run <br>-p 80:80 \\<br>-v ${pwd}:/app \\<br>-v logs:/app/logs \\<br>-v /app/node_modules \\<br>--env-file ./config/env/dev.env \\<br>--name multi-backend-container \\<br>--network multi \\<br>--rm \\<br>multi-backend-image</strong></p>\n<ul><li>Ve şimdide yukarıdaki kodla containerımızı çalıştırıyoruz.<br><strong>--rm</strong> ile containerımızın stop olunca silinmesini söylüyoruz<br><strong>--network </strong>ile containerımızı multi isimli networke dahil ediyoruz<br><strong>-p</strong> ile port binding yaparak containerımızı kendi <strong>OS sistemimizdeki 80 ile</strong> çalıştığı <strong>VM(Virtual Machine)’deki 80</strong> portlarını bind etmesini bağlamasını söylüyoruz. Böylece containerın çalıştığı VM’deki 80 portu bizim makinamızdaki 80 portuna yansıyacak. Ve böylelikle localhost adresinden direkt olarak container’a erişim sağlayabileceğiz.<br><strong>--name</strong> ile containerımızı identifier ettiğimiz bir isimlendirme uyguluyoruz yani containerımızı isimlendiriyoruz. Burada backend için multi-backend-container koydum ben düzenli olması için.<br><strong>-v ${pwd}:/app volume</strong> belirlemesi ile şuan ki dizinde yani kodu yazdığımız dizindeki, yani backend klasörünün içindeki tüm herşeyi Dockerdaki /app klasörüne yani WORKDIR’e bağlamasını istiyoruz. Böylelikle localde yaptığımız değişiklikler anında, containerımızın çalıştığı VM’ye yansıyabilecek.<br><strong>-v logs:/app/logs</strong> volume tanımlaması ilede, logs adında bir volume oluşturmasını söylüyoruz Docker’a, ve bu logs volumesine, conteinerımızın logladığı VM’de çalışma dizindeki logların tutulduğu pathdeki(/app/logs) logları saklamasını söylüyoruz.<br><strong>-v /app/node_modules</strong> ile containerımızın npm install yaptıktan sonra buradaki node_modules dosyalarını anonymous volume oluşturarak saklamasını istiyoruz.<br><strong>--env-file</strong> ilede backend projemizin çalıştığı zaman ihtiyacı olacak environment varaiblesları içeren env dosyasının yolunu vererek, environment variableslarını dockera tanımlamasını söylüyoruz.<br>Ve son olarak image adını yazıyoruz.</li></ul>\n<h3>STEP 5 - Dockerfile (for frontend)</h3>\n<p>Backend ve mongo-containerımızı ayağa kaldırdığımıza göre şimdi sıra frontend uygulamamızı Dockerize etmeye geldi.</p>\n<ul><li>Dockerfile’mi oluşturup içini aşağıda ki gibi ayarladım.</li></ul>\n<a href=\"https://medium.com/media/78305b4fee423fd9cf516e45370f56f2/href\">https://medium.com/media/78305b4fee423fd9cf516e45370f56f2/href</a><ul><li>Daha sonra imagemizi build alıyoruz aşağıda ki kodla.<br><strong>docker build -t multi-frontend-image .</strong>\n</li></ul>\n<p><strong>docker run -v ${pwd}/src:/app/src --rm -it --name multi-frontend-container -p 3000:3000 multi-frontend-image</strong></p>\n<ul>\n<li>Ve son olarak da aşağıda ki kodu kullanarak oluşturduğumuz uygulamamızın imagesini containerımızı çalıştırarak kullanıyoruz.<br><strong>-v ${pwd}/src:/app/src</strong> ile uygulamamızın kendi OS sistemimiz üzerindeki src yolunu, pathini, containerımızın sistemi üzerindeki /app/src dizini ile bind ediyoruz bağlıyoruz. Böylelikle react uygulamamız localde yaptığımız değişiklikleri anında containera yansıtacaktır.<br><strong>--rm</strong> ile containerımızın stop olunca silinmesini söylüyoruz<br><strong>--network </strong>ile containerımızı multi isimli networke dahil ediyoruz<br><strong>-it</strong> ile interactive mod ile containerımızı başlatacağız ve böylelikle react uygulaması çalışırken teminali izleyip başarıyla başlayıp başlamadığını görebileceğiz.<br><strong> --name</strong> ile containerımızı identifier ettiğimiz bir isimlendirme uyguluyoruz yani containerımızı isimlendiriyoruz. Burada frontend için multi-frontend-container koydum ben düzenli olması için.<br><strong>-p</strong> ile port binding yaparak containerımızı kendi <strong>OS sistemimizdeki 3000 ile</strong> çalıştığı <strong>VM(Virtual Machine)’deki 3000</strong> portlarını bind etmesini bağlamasını söylüyoruz. Böylece containerın çalıştığı VM’deki 3000 portu bizim makinamızdaki 3000 portuna yansıyacak. Ve böylelikle localhost adresinden direkt olarak container’a erişim sağlayabileceğiz.<br>Ve son olarak image adını yazıyoruz.</li>\n<li>Ve evet tüm adımları tamamlayıp uygulamalarımızı başarıyla Dockerize ettik. Final görüntüsü aşağıda ki gibi.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*nfHCiqB_NdyZLD8XttzdZQ.png\"></figure><ul><li>Peki biz bu yazımız da neler yaptık?<br>3 container çalıştırdık.<br>Network kurup containerlarımız arası iletişim kanalı iletişim kanalı oluşturup, bu kanal üzerinden haberleştik.<br>2 tane Dockerfile oluşturduk.<br>3 containerımıza özel farklı volumeler oluşturduk.<br>Bir önceki yazılardan öğrendiklerimizi fazlasıyla tekrar ettik.</li></ul>\n<p>Bu yazımda anlatacaklarım bu kadardı. Bir sonra ki örnekte bunu docker-compose kullanarak nasıl çok daha az terminal kodu yazarak yapacağız bunu göreceğiz. Esen kalın.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4e56b97ee3ce\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["volume", "nodejs", "containers", "docker", "network"],
    "slug": "4e56b97ee3ce"
  },
  {
    "title": "Test - Docker - The neccesarry part (Volume &amp; Network &amp; Environment)",
    "pubDate": "2021-06-04 07:02:08",
    "link": "https://mucahidyazar.medium.com/docker-the-neccesarry-part-volume-network-environment-f5d1ee8b815b?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/f5d1ee8b815b",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/720/0*Xd83Y1MygzaJ-WQK.png",
    "description": "\n<p>Bu kısımda sizlerle datalarımızı makinada saklamanın yolları yani host ve kullandığımız OS sistemi arasındaki dosya paylaşımlarını, containerlar arası network oluşturup birbirleriyle iletişim kurmalarını, ve projelerimizin olmazsa olmazı environment variable tanımlamalarını öğreneceğiz.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/720/0*Xd83Y1MygzaJ-WQK.png\"></figure><h3>Volume</h3>\n<p>Volumelar bizim datalarımızı containerımızın çalıştığı sanal makinamız üzerindeki sistemde saklamamıza yarayan yapılardır. Mesela bir web projemiz olduğunu düşünün bu projemizde yüklediğimiz resimlerin veya formlarla eklediğimiz metinlerin, containerı çalıştırdığımız makinada tutulmasını istiyoruz. Ve volumelarda depoladığımız için, containerımız ne zaman çalışıp aktif olduğunda bu depolanmış dataların tekrar uygulamamız üzerinde erişimine sahip olmuş oluyor ve datalarımızı kaybetmemiş oluyoruz.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*NPh1MKLAVfIZeFQr8QsWYg.png\"></figure><p><a href=\"https://github.com/mucahidyazar/docker\">https://github.com/mucahidyazar/docker</a></p>\n<ul>\n<li>Yukarıdaki linkten gerekli repoyu indiriyoruz.<br>git clone <a href=\"https://github.com/mucahidyazar/docker.git\">https://github.com/mucahidyazar/docker.git</a>\n</li>\n<li>Ve tutorials branchine geçiyoruz.<br>git checkout tutorials</li>\n<li>Be burada volume-example adlı dizine geliyoruz. Burada 2 klasör var. 1. si starter yani başlangıç klasörü, diğeri fnished yani bitiş dosyalarımız.</li>\n<li>Takıldığınız yerde fnished klasörüne bakıp kopya çekebilirsiniz.</li>\n<li>Elimizde aşağıda ki kodlardan oluşan bir server.js dosyası var.</li>\n</ul>\n<a href=\"https://medium.com/media/2e609dc754238ed90327df8b21d8e3fe/href\">https://medium.com/media/2e609dc754238ed90327df8b21d8e3fe/href</a><ul><li>Dosya structure yapısı da aşağıdaki gibi.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*meZy9B2WE5S7ZIZ72mWpsw.png\"></figure><ul><li>Uygulamamızın görünümü bu şekilde. Eğer biz bir title ve text ile feedback bırakacak olursak, uygulamamız bunu bir metin belgesine dönüştürecek titleda yazan text’e göre ve bunu dosya structure yapısındaki feedback klasörünün içine atacaktır.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*fTuK_uMzTuCeVROjq3shwg.png\"></figure><ul><li>Ve daha sonra buna biz ulaşmak isteseydik url kısmına aşağıdaki gibi feedback/awesome.txt yazdığımızda kaydettiğimiz txt dosyasını görüntüleyebilecektik.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*Y79ozGSurLELNn0zi2OQiA.png\"></figure><ul>\n<li>Burada sorun şu. Biz bu dosyayı dockerize edip docker containerında çalıştığı zaman image kendi dosya sistemi üzerinde çalışacak ve kaydedilen awesome.txt gibi dosyalar bizim uygulama dosyalarının olduğu yerde saklanmayacak. İşte volumelarla container image hostu ve kendi hostumuz arasında bağlantıyı sağlayacağız.</li>\n<li>Şunu iyice anlamalıyız ki imageler sadece read-only’dir. Container ise read-write. Yani biz bir dosya kaydettiğimizde bu dosya containerın file systeminde saklanır. Imagenin file systeminde değil.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*PaqPfWUmCWINT2CBjr4l2g.png\"></figure><ul>\n<li>Eğer bir containerı silersek ve daha sonra aynı image ile yeni container oluşturursak daha önce yaptığımız değişikliklerde containerın silinmesiyle gider. Fakat volume ile bu durumu değiştirebiliriz.</li>\n<li>Veya container silmeden sadece stop yaparak durdurup daha sonra çalıştırırsak eski dosyalar silinmez ve aynı dosyaları kullanabilir veya bulabiliriz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*IWCjW0QsMnzMJey0Ibx7Iw.png\"></figure><ul>\n<li>İki şekilde volume tanımlayabiliriz. Anonymous Volume veya Named volumes.</li>\n<li>Anonymous volumesları Dockerfile içinde aşağıda ki gibi veya docker run volume create komutunu kullanırken :’den önceki ilk tanımı yapmayarak</li>\n</ul>\n<a href=\"https://medium.com/media/b84fda36807764dfaa31335aff739a4a/href\">https://medium.com/media/b84fda36807764dfaa31335aff739a4a/href</a><ul><li>Ananymous volumeslar container silindikten sonra otomatik olarak silinir.</li></ul>\n<h4>docker volume -help</h4>\n<ul><li>Aşağıda docker volume ile yapabileceğimiz komutların bazılarını görüyorsunuz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/285/1*whZs7r1mTqcWimR_fXCt7A.png\"></figure><h4>docker volume ls</h4>\n<ul><li>Docker volumelerimizi listeler.</li></ul>\n<h4>docker volume create volumeName</h4>\n<ul><li>Docker volumesı oluştururuz.</li></ul>\n<h4>docker volume prune</h4>\n<ul><li>Kullanılmayan voluemleri siler.</li></ul>\n<h4>docker volume rm volumeName</h4>\n<ul><li>volume ismine göre volumelerimizi siler.</li></ul>\n<h4>docker volume inspect volumeName</h4>\n<ul><li>Oluşturduğumuz volume ait bilgileri görürüz yani inspect ederiz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*grgVtSNaEpzLvqPO9nt6Gg.png\"></figure><ul><li>Terminale gelip yeni temiz bir image buildi alıyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*jxbx5oqFsAIn_LDvIBM7lw.png\"></figure><h4><strong>docker run -v volumeName:/volumePathFromWorkdirOnImageFileSystem …</strong></h4>\n<ul><li>Yukarıda ise named yani isimlendirilmiş bir volume oluşturuyoruz, imagemizi container oluşturup çalıştırırken yapıyoruz bu işlemleri. İlk olarak volume için isim veriyoruz, ikinci olarak ise : işaretinden sonra imagemizdeki hangi pathdeki dosyaları bu volumede tutacağımız yolu belirliyoruz.</li></ul>\n<p><strong>docker run -v feedback-volume:/app/feedback --name feedback-container -p 3000:80 --rm -d feedback-node:latest</strong></p>\n<ul>\n<li>Bizim kendi örneğimizzden gidecek olursak,<br>1. -v ile feedback-volume adında bir volume oluşturuyoruz ve bu volumenin yolu olarakta : işaretinden sonra imagedeki WORKDIR’den volumede tutulacak konumu belirliyoruz.<br>2. --name ile oluşturulup çalıştırılacak containerımıza feedback-container ismini veriyoruz.<br>3. -p ile makinamızdaki 3000 portunu containerın çalıştırdığı imagenin 80 portuyla bind ediyoruz<br>4. --rm ile container stop olduğunda silinsin istiyoruz.<br>5. -d ile detach modda çalışsın istiyoruz. Bu bizi container başlattıktan sonra default olarak attach moddan kurtarır. Böylelikle node terminalinde kalmayız ve direk kendi terminalimize döneriz.<br>6. Ve son olarakda feedback-node:latest ile imageName ve tagine göre imagemizi seçiyoruz.</li>\n<li>Yukarıdaki kodu çalıştırıp detach moda geçtiğimizde<br>1. docker ps -a yaparak tüm containerlarımızı görüyorum ve ilk gördüğünüz gibi containerımız çalışıyor.<br>2. Daha sonra docker volume ls yaparak volumeleri listeliyorum. Ve gördüğünüz gibi yukarıda imagemizi containerla çalıştırırken oluşturduğumuz volume burada.<br>3. Daha sonra docker stop containerId mi yazarak çalışan containerımı durduruyorum ve --rm bu container otomatik olarak siliyor. Hatta 2 alt satırda docker ps -a yaptım bunu görmeniz için.<br>4. Daha sonra docker volume ls yapıyoruz ve volumemizin hala silinmediğini ve orada olduğunu görüyoruz. Containerın silinmesine ragmen. Buda bir daha yeni container oluştursak bu volumeyi kaybetmeyeceğimiz için uygulamamız sürekli her çalıştığında aynı verileri bulup saklayabileceği anlamına gelmektedir.<br>5. Ve en alt satırda ki gibi, containerımız silindikten sonra tekrar aynı image ile yeni container oluşturup çalıştırırken aynı isim ile volume’ye bağlanmalıyız.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*eYMi61st67zwFZFJqxpsag.png\"></figure><ul>\n<li>Container ve volume etkileşimini iyi anlamamız gerekmektedir.</li>\n<li>Container ilk açıldığında /app/data da eğer dosya yoksa volüme deki /some-path den alır. Fakat dosya varsa eğer o zaman containerdaki dosyalar volüme deki /some-path üzerine overwrite edilir yani yazılır.</li>\n<li>Fakat /app/code içinde ilk container çalıştığında dosya yoksa /some-other-path volumedeki dosyalar /app/code içine gönderilerek container her başladığında eklenir.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*XJ7O8s3xGcZDoMz2p8EP8Q.png\"></figure><h4>Sharing Source Code with a Container</h4>\n<ul>\n<li>Ve şimdi şöyle bir sistem yapalım. Lokalimizde proje dosyalarında herhangi bir değişiklik yaptığımız da bunun projeye anında yansımasını sağlayan bir yapı kuralım volumelerle.</li>\n<li>Aşağıda ki gibi projemizde bir değişiklik yaparsak bu hemen browserda bize yansımaz. Bunun için yeni bir volume tanımalıyız. Öyle bir şey yapacağız ki projedeki herhangi bir değişiklik immediately yani acil olarak containera yansıyacak.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*_BlYr8v1qzYSk8TWs0tzvw.png\"></figure><p><strong><em>NOTE</em></strong>: Tabi burada unutmamız gereken şey,<br>önceki volume tanımlamamız orada dataları toplayıp daha sonra uygulamamızın containerı çalışıp mount olduğunda burada voluemdaki dataları uygulamamıza kopyalamak,<br>burada ki volüme tanımlamamızda ki sebep ise uygulamamız açıldığında, şuan ki dizinin adında bir volüme oluşturup bunu anında uygulamamızın containerı çalıştığında oradaki WORKDIR’e yani /app’e göndermek.</p>\n<p>PATH Tanımlamaları</p>\n<ul>\n<li>İster absolute pathi almak için aşağıdaki gibi uzun adres tanımlayın<br><strong>E:\\Software\\worksheets\\docker\\examples\\volume-example\\final</strong>\n</li>\n<li>İsterseniz de aşağıdaki gibi sistemlere özgü kısa yolları kullanın<br><strong>macOS / Linux:</strong> -v $(pwd):/app<br><strong>Windows:</strong> -v “%cd%”:/app</li>\n<li>Veya image tercihine göre containerımızın virtual machinesinin çalıştıracağı imageye göre aşağıdaki şekillerde kullanabilirsiniz.</li>\n</ul>\n<p><strong>FROM node:14<br></strong>docker run -v feedback-volume:/app/feedback -v <strong>${pwd}</strong>:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</p>\n<p><strong>FROM node:14.16.0-alpine3.13<br></strong>docker run -v feedback-volume:/app/feedback -v <strong>$(pwd)</strong>:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</p>\n<p><strong>with absolute path<br>E:\\Software\\worksheets\\docker\\examples\\volume-example\\final<br></strong>Özel karakter olur diye “” bu isaret içinde yazmak en güvenilir yoludur volume pathi tanımlarken. Özel karakter yoksa kullanmayada gerek yoktur. Aslında aşağıda da kullanmasak da olurdu.<br>docker run -v feedback-volume:/app/feedback -v <strong>“Software\\worksheets\\docker\\examples\\volume-example\\final:/app” --</strong>name feedback-container -p 3000:80 --rm -d feedback-node:latest</p>\n<h4><strong>docker run -v /pathThatBindingWithVolume</strong></h4>\n<ul><li>Eger volumeName yazmasak yukarıda ki gibi, anonymous bir volume tanımlamış oluruz.</li></ul>\n<h4><strong>docker run -v bindedPathOnOurOS:/bindedPathOnVMOS</strong></h4>\n<p><strong>docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</strong></p>\n<ul>\n<li>Evet bunun için ikinci bir volume belirliyoruz -v ile. Birinci volume hatırlarsanız feedbackleri volumeda tutmak içindi.</li>\n<li>Ve bu volume’yi dynamic olarak <strong>node:14</strong> imagesini kullandığım için <strong>${ }</strong> arasina pwd yazarak current directorymizle bir volume oluşturuyoruz. Ve bu volumeyi imagedeki app klasörüyle bağlıyoruz. Böylelikle projede yani ${pwd} dizininde yaptığımız her değişiklik anında app klasörüne yansımış olacak.</li>\n<li>Bu şekilde docker run yaptığımızda uygulamamızın çalışıp ve bir container oluşturup ardından daha sonra hemen stop ederek containerın silindiğini göreceksiniz. Çünkü express hatası verecek aşağıda ki gibi.</li>\n</ul>\n<p><strong>docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 -d feedback-node:latest</strong></p>\n<ul>\n<li>Bunu gösterebilmek için ben --rm yi silerek yukarıdaki kodun aynısını çalıştıracağım. Böylelikle uygulamamız hata verdiğinde otomatik kapanmayacak ve container silinmeyecek. Bu şekildede biz containerın çalıştırdığı imagemizin terminale bastırdığı hatanın logunu alabileceğiz.</li>\n<li>Gördüğünüz gibi Express hatası alıyoruz. Sebebi ikinci volüme(<strong>-v ${pwd}:/app --name feedback-container</strong>) tanımlamamız yüzünden. Çünkü <strong>pwd</strong> deki kendi OS sistemimizdeki dizinde bizim node_modules klasörümüz yukarıda tanımladığımız volumenin bizim pwd dizinindeki tüm herşeyi /app ile overwrite etmesinden dolayı yok, yani uygulamamız npm install yapıyor imagenin Dockerfilesına göre ama daha sonra bu node_modules overwrite yüzünden siliniyor ve uygulama mounted olduğunda node_modules olmayan buradaki tüm klasörler ve dosyaları, imagemizin çalıştığı containerdaki WORKDIR deki /app dizinindeki tüm dosyalarla değiştir. Buda Dockerfile ile npm install yapıp yüklediğimiz node_modules de silinmiş oluyor.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*s2KBalno70zlOQQTj4o01Q.png\"></figure><ul><li>Bu sorunu gidermek için bir kaç farklı yöntem var. Ya bir user oluşturup, buna çeşitli yetkiler vererek halledebiliriz. Yada aşağıdaki gibi node_modules’u başka bir anonymous volume’a veririz ve silinmesini engelleriz. Ve bu şekilde yukarıdaki hatayı önlemiş oluruz.</li></ul>\n<p><strong>docker run -v feedback-volume:/app/feedback -v ${pwd}:/app -v /app/node_modules --name feedback-container -p 3000:80 -d --rm feedback-node:latest</strong></p>\n<ul>\n<li>Ve şimdi artık uygulamamızda yaptığımız her değişiklik anında çalışan containerdaki dosya sistemimize anında yansıyacaktır. Artık dosyada bir değişiklik yapıp bunu görebilirsiniz.</li>\n<li>Fakat yinede bir sorunumuz daha var yukarıdaki yaptığımız değişiklikler dosyalara aynı anda hemen yansır fakat bizim projemiz bu yansımayı hemen bize gösterir mi? Pages içindeki html sayfalarında yaparsak eğer bir f5 sornası yaptığımız değişikliği hemen görebiliriz. Fakat biz hatırlarsanız nodeda kullandığımız express serverını node server.js diyerek başlatıyoruz. Yani biz server.js içindeki bir fonksiyon içinde bir console.log yapacak olursak, node server.js ile bunu yaptığımız için değişiklik hemen yansımayacaktır, çünkü node serverını kapatıp tekrar node server.js dememiz gerekecektir içindeki o değişikliği yakalayabilmek için. Veya bunun için nodemon adında bir npm packagei çözüm sunar bize. O zaman buradada bu değişikliği aşağıdaki gibi package.jsona hemen ekliyoruz.</li>\n</ul>\n<p><a href=\"https://gist.github.com/mucahidyazar/ffc479cfbc0b4257ecb5e986604b17b8\">https://gist.github.com/mucahidyazar/ffc479cfbc0b4257ecb5e986604b17b8</a></p>\n<ul>\n<li>Ve yukarıda ki yaptığımız değişiklikten ötürü CMD yi artık node server.js yerine yukarıda tanımladığımız script ile kullanacağız.</li>\n<li>Anonymous volumeyide her seferinde terminalde yazmak yerine artık Dockerfileye aşağıdaki gibi ekliyoruz.</li>\n</ul>\n<a href=\"https://medium.com/media/e9239ae3b6d542fc0b59e1396f85cdf4/href\">https://medium.com/media/e9239ae3b6d542fc0b59e1396f85cdf4/href</a><ul>\n<li>Daha sonra imagemizi yeniden build alarak oluşturuyoruz.</li>\n<li>Ve artık terminale gelip aşağıdaki kodla imagemizi container oluşturarak çalıştırıyoruz.</li>\n</ul>\n<p><strong>docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 -d --rm feedback-node:latest</strong></p>\n<ul>\n<li>Aslında (<strong>${pwd}:/app</strong>) bunu yaparak Dockerfiledaki COPY . . nın işini bir nevi yine yapıyoruz yani Dockerfiledan onu kaldırsakta hiç bir şey olmaz. Fakat biz (<strong>${pwd}:/app</strong>) bunu developmentda yaptığımız için günün sonunda COPY . . ya bizim productionda yine ihtiyacımız olacak o yüzden kaldırmaya gerek yok yinede tutabiliriz.</li>\n<li>Ve şimdi server tarafında yaptığımız değişikliklerde anında yansıyacaktır nodemon sayesinde.</li>\n<li>Bu tarz sorunlar bize farklı uygulamalarda da çıkabilir bunları aşmak için bu tarz yöntemleri araştırıp bulmalıyız veya geliştirmeliyiz.</li>\n</ul>\n<h4>ro (read-only)<br>docker run -v volumeName:/projectPath:ro</h4>\n<ul><li>Yukarıda ki gibi tanımlayacağımız volumeleri sadece read-only yapabiliriz.</li></ul>\n<h3>ENVironment Variables &amp; ARGuments</h3>\n<h4>ENV</h4>\n<ul><li>Environment variablelari ise Dockerfile içerisinde asagidaki gibi ya aralarinda bir bosluk birakarak yada = ile tanimlayabiliriz ben = ile tanımlamayı tercih ediyorum.</li></ul>\n<a href=\"https://medium.com/media/2965ca455e97dbae8ae6de11f7793511/href\">https://medium.com/media/2965ca455e97dbae8ae6de11f7793511/href</a><ul><li>Ve daha sorna imagemizi oluşturup containerimızı imagemizle çalıştırdığımızda istersek bu environmentleri aşağıda ki gibi görebiliriz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*RzTwqJbwDXTqm2iywI8_IA.png\"></figure><ul><li>Veya shell ile çalıştırdığımız için istersek yazdırabiliriz de echo yaparak.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*UhdCNM6LQc_Nv0r4iJY8Uw.png\"></figure><h4>docker run --env/-e PORT=80 …</h4>\n<ul><li>Veya yukarıdaki tanımdaki veya aşağıdaki örnekteki gibi docker run yaparken de environment variablesları tanımlayabilirsiniz.<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app --<strong>env PORT=80</strong> feedback-image<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app <strong>-e PORT=80</strong> feedback-image<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app --<strong>env PORT=80</strong> --<strong>env ENDPOINT=https://www.google.com</strong> feedback-image</li></ul>\n<h4>docker run --env-file ./dev.env …</h4>\n<ul><li>Veya kendi OS sistemimizde terminaldeki konumumuza göre dev.env veya prod.env gibi dosyalarımızı --env-file komutuna tanımlatarak aslında birden fazla environment variable olan dosyamızdaki tüm environment variablesları tanımlatabiliriz.</li></ul>\n<h4>ARGuments</h4>\n<ul>\n<li>Argslar bizim aslında Dockerfile içinde tanımladığımız variableslardır diyebiliriz.</li>\n<li>Ve genellikle ENVlerin hemen üstüne tanımlamalıyız çünkü değiştiklerinde aşağısındaki layerların bir daha boş yere hesaplanmasını istemiyoruz.</li>\n</ul>\n<a href=\"https://medium.com/media/d63f877abc21de3ebd928cd788ac69ad/href\">https://medium.com/media/d63f877abc21de3ebd928cd788ac69ad/href</a><ul><li>Ve artık aşağıdaki gibi yeni bir build aldığımızda default port env ve expose port 80 olarak hesaplanarak image oluşturulur.</li></ul>\n<p><strong>docker build -t feedback-image .</strong></p>\n<ul>\n<li>Fakat istersekde sadece arg tanımımızı docker run da değiştirerek default portu ezerek yeni bir arg tanımlayabiliriz aşağıda ki gibi.</li>\n<li>Böylelikle bu buildimiz ise yeni Dockerfile içinde olan DEFAUULT_PORT argını yeni değeri 8000 ile tanımlamış oluruz.</li>\n</ul>\n<p>docker build -t feedback-image:defaultArg --build-arg <strong>DEFAULT_PORT=8000</strong> .</p>\n<h3>NETWORKING: (CROSS-) CONTAINER COMMUNICATION</h3>\n<ul><li>Öncelikle githubdan api-example örneğinin starter klasörünü vs codeumuzda indirip açıyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*qfmfMRnNZkIDJB3wg4-y-g.png\"></figure><ul><li>Bu örnekte containerımızla dış dünya arasındaki ilişkileri inceleyeceğiz. Burada 3 çeşit bağlantımız olabilir.</li></ul>\n<ol><li>Bir API’a istek atıyor olabileceğimiz durumlar. Bu örneğimizde starwars ile ilgili bir apia istek atıyoruz.</li></ol>\n<a href=\"https://medium.com/media/16bb38907548a9147f3bcd0c6b8e5d21/href\">https://medium.com/media/16bb38907548a9147f3bcd0c6b8e5d21/href</a><p>2. Local makinamızla kuracağımız communicationlar. Bu örneğimizde mongodb’ye kendi makinamızda bağlanıyoruz.</p>\n<a href=\"https://medium.com/media/3f6ece701108b4440ccaa63670cd7fa7/href\">https://medium.com/media/3f6ece701108b4440ccaa63670cd7fa7/href</a><p>3. Başka containerlarla olan communicationlar. Bu örneğimizde şuan yok ama ileride bunları da yapabiliyor olacağız.</p>\n<h4>API Communications</h4>\n<ul>\n<li>Api communicatinoslar için yapmamız gereken her hangi bir özel ayar yoktur.</li>\n<li>Yukarıdaki örnek için konuşacak olursam, app.listenı en yukarı alarak mongoose’yi tamamen iptal ediyorum çünkü şuanda bu şekilde dockerda çalıştırırsak imagemizi build alıp mongoose, localhost’a bağlanamayacağı için hata verecek ve app.listen serverımızı çalıştırmayacaktır.</li>\n<li>Aşağıdaki gibi yapıp build alıyoruz,</li>\n</ul>\n<p><strong>docker build -t api-image .</strong></p>\n<ul><li>Daha sorna run yapıyoruz</li></ul>\n<p><strong>docker run --rm --name api-container -p 3000:3000 api-image:latest</strong></p>\n<ul><li>Ve şimdi localhost:3000/movies veya localhost:3000/people ‘a gidersek swapi.dev apiına atyıp aldığımız responseleri, kendi responselerimiz olarak browserda göreceğiz. Yani hiçbir ayar yapmadan api isteklerini atıp alabiliyoruz.</li></ul>\n<a href=\"https://medium.com/media/e7669f3cf8d1eac10b48e9d0f56b08f2/href\">https://medium.com/media/e7669f3cf8d1eac10b48e9d0f56b08f2/href</a><h4>Your Host Machine Communications</h4>\n<ul>\n<li>Şimdi tekrar yukarıdaki satırı eski haline getiriyoruz.</li>\n<li>Tek yapmamız gereken localhost yerine host.docker.internal kullanmaktır. Bu o anki hostunuzun adresi ne ise onun tarifidir. Localhost ise localhost, www ile başlayan özel bir AWS hostu ise o hostu temsil eder.</li>\n<li>Ve şimdi tekrar aşağıdaki gibi yapıp build alıyoruz,</li>\n</ul>\n<p><strong>docker build -t api-image .</strong></p>\n<ul><li>Daha sorna run yapıyoruz</li></ul>\n<p><strong>docker run --rm --name api-container -p 3000:3000 api-image:latest</strong></p>\n<ul><li>Ve artık localhost’a attığımız favorites POST isteğinide postman vasıtasıyla atıp, localdeki mongo databasemize birşeyler kaydedebiliriz.</li></ul>\n<a href=\"https://medium.com/media/ac0338cd931d9facdd38ee061e473be7/href\">https://medium.com/media/ac0338cd931d9facdd38ee061e473be7/href</a><h4>Containers Communications</h4>\n<ul>\n<li>İlk önce mongo imagesini dockerhubdan indirtip makinamızda çalıştıralım.<br><strong>docker run --rm --name mongo-container -d mongo</strong>\n</li>\n<li>Daha sonra docker ps yaptığımızda göreceğiniz üzere mongo-container adında bir container çalışıyor.</li>\n<li>Daha sonra buna inspect yaparak bu containerın bilgilerini alıyoruz.<br><strong>docker inspect mongo-container</strong>\n</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*q-qyn4miehe4bEYdXmAzJw.png\"></figure><ul><li>Ve daha sonra çıkan bilgilerden, Networks’deki bridgeden IPAdress’i alıyoruz ve aşağıdaki gibi mongodb tanımına yazıyoruz.</li></ul>\n<a href=\"https://medium.com/media/5cbc87d57c7d1c2e8ace41001a0f7c4e/href\">https://medium.com/media/5cbc87d57c7d1c2e8ace41001a0f7c4e/href</a><ul><li>Ve şimdi tekrar uygulamamızın imagesini silip tekrar build alıyoruz ve run yapıyoruz. Göreceksiniz ki artık mongodb miz diğer containerın ip adresine bağlanacaktır. Ve hatta localhost:3000/favorites adresine istek attığınızda göreceksiniz ki boş bir array dönecek çünkü bu mongo imagesinin hostundaki databaseden dönen değerdir.</li></ul>\n<h3>Networks</h3>\n<ul><li>Containerları dahil edebilip birbirleriyle iletişim kurabilecekleri bir grup gibi düşünebilirsiniz burayı. Birden fazla containerı bir network oluşturup bu networke dahil ederiz run yaptığımız zaman ve daha sonra birbirlerine ulaşmak için tek yapmaları gereken birbir container isimlerini kuyllanmak olacaktır.</li></ul>\n<h4>docker network create networkName</h4>\n<ul><li>Containerların birbirleriyle iletişim kuracağı network oluşturur</li></ul>\n<h4>docker network ls</h4>\n<ul><li>Networkleri listeler.</li></ul>\n<h4>docker network rm networkName</h4>\n<ul>\n<li>network ismi ile networku siler.</li>\n<li>Yukarıda ki örneğimiz için önce çalışan containerlarımızı durduruyoruz.</li>\n<li>Ve aşağıdaki gibi bir network kuruyoruz.</li>\n</ul>\n<p><strong>docker network create api-network</strong></p>\n<ul><li>Ve şimdi mongo imagemizi çalıştırıp containerının bu networke dahil olmasını sağlıyoruz. Ve artık mongo imagemizin containerı api-network adında kurduğumuz networke girmiş oluyor.</li></ul>\n<p><strong>docker run --rm --name mongo-container -d --network api-network mongo</strong></p>\n<ul><li>Şimdi uygulamamızdaki app.js’e gelip mongodb bağlantı noktasını mongo imagesi için ayarladığımız container isimi olan mongo-container yapıyoruz aşağıdaki gibi.</li></ul>\n<a href=\"https://medium.com/media/4dcbd58497fb63730055428d6055efe3/href\">https://medium.com/media/4dcbd58497fb63730055428d6055efe3/href</a><ul><li>Ve şimdi bu uygulamamızın imagesinide silip yeniden build alıyoruz.</li></ul>\n<p><strong>docker build -t api-image .</strong></p>\n<ul><li>Ve şimdi uygulamamızı aşağıdaki gibi mongo imagesini run ederken yaptığımız gibi aynı networke dahil edip run yaptırıyoruz.</li></ul>\n<p><strong>docker run --rm --name api-container -p 3000:3000 --network api-network api-image:latest</strong></p>\n<ul><li>Ve artık imagemizde aynı networkde olduğu için diğer containerı container adıyla yani mongo-container ile tanıyım bulup başarılı bir şekilde diğer bir containerla iletişimi kurup isteklerimizi cevap verecektir.</li></ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f5d1ee8b815b\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>Bu kısımda sizlerle datalarımızı makinada saklamanın yolları yani host ve kullandığımız OS sistemi arasındaki dosya paylaşımlarını, containerlar arası network oluşturup birbirleriyle iletişim kurmalarını, ve projelerimizin olmazsa olmazı environment variable tanımlamalarını öğreneceğiz.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/720/0*Xd83Y1MygzaJ-WQK.png\"></figure><h3>Volume</h3>\n<p>Volumelar bizim datalarımızı containerımızın çalıştığı sanal makinamız üzerindeki sistemde saklamamıza yarayan yapılardır. Mesela bir web projemiz olduğunu düşünün bu projemizde yüklediğimiz resimlerin veya formlarla eklediğimiz metinlerin, containerı çalıştırdığımız makinada tutulmasını istiyoruz. Ve volumelarda depoladığımız için, containerımız ne zaman çalışıp aktif olduğunda bu depolanmış dataların tekrar uygulamamız üzerinde erişimine sahip olmuş oluyor ve datalarımızı kaybetmemiş oluyoruz.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*NPh1MKLAVfIZeFQr8QsWYg.png\"></figure><p><a href=\"https://github.com/mucahidyazar/docker\">https://github.com/mucahidyazar/docker</a></p>\n<ul>\n<li>Yukarıdaki linkten gerekli repoyu indiriyoruz.<br>git clone <a href=\"https://github.com/mucahidyazar/docker.git\">https://github.com/mucahidyazar/docker.git</a>\n</li>\n<li>Ve tutorials branchine geçiyoruz.<br>git checkout tutorials</li>\n<li>Be burada volume-example adlı dizine geliyoruz. Burada 2 klasör var. 1. si starter yani başlangıç klasörü, diğeri fnished yani bitiş dosyalarımız.</li>\n<li>Takıldığınız yerde fnished klasörüne bakıp kopya çekebilirsiniz.</li>\n<li>Elimizde aşağıda ki kodlardan oluşan bir server.js dosyası var.</li>\n</ul>\n<a href=\"https://medium.com/media/2e609dc754238ed90327df8b21d8e3fe/href\">https://medium.com/media/2e609dc754238ed90327df8b21d8e3fe/href</a><ul><li>Dosya structure yapısı da aşağıdaki gibi.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*meZy9B2WE5S7ZIZ72mWpsw.png\"></figure><ul><li>Uygulamamızın görünümü bu şekilde. Eğer biz bir title ve text ile feedback bırakacak olursak, uygulamamız bunu bir metin belgesine dönüştürecek titleda yazan text’e göre ve bunu dosya structure yapısındaki feedback klasörünün içine atacaktır.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*fTuK_uMzTuCeVROjq3shwg.png\"></figure><ul><li>Ve daha sonra buna biz ulaşmak isteseydik url kısmına aşağıdaki gibi feedback/awesome.txt yazdığımızda kaydettiğimiz txt dosyasını görüntüleyebilecektik.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*Y79ozGSurLELNn0zi2OQiA.png\"></figure><ul>\n<li>Burada sorun şu. Biz bu dosyayı dockerize edip docker containerında çalıştığı zaman image kendi dosya sistemi üzerinde çalışacak ve kaydedilen awesome.txt gibi dosyalar bizim uygulama dosyalarının olduğu yerde saklanmayacak. İşte volumelarla container image hostu ve kendi hostumuz arasında bağlantıyı sağlayacağız.</li>\n<li>Şunu iyice anlamalıyız ki imageler sadece read-only’dir. Container ise read-write. Yani biz bir dosya kaydettiğimizde bu dosya containerın file systeminde saklanır. Imagenin file systeminde değil.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*PaqPfWUmCWINT2CBjr4l2g.png\"></figure><ul>\n<li>Eğer bir containerı silersek ve daha sonra aynı image ile yeni container oluşturursak daha önce yaptığımız değişikliklerde containerın silinmesiyle gider. Fakat volume ile bu durumu değiştirebiliriz.</li>\n<li>Veya container silmeden sadece stop yaparak durdurup daha sonra çalıştırırsak eski dosyalar silinmez ve aynı dosyaları kullanabilir veya bulabiliriz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*IWCjW0QsMnzMJey0Ibx7Iw.png\"></figure><ul>\n<li>İki şekilde volume tanımlayabiliriz. Anonymous Volume veya Named volumes.</li>\n<li>Anonymous volumesları Dockerfile içinde aşağıda ki gibi veya docker run volume create komutunu kullanırken :’den önceki ilk tanımı yapmayarak</li>\n</ul>\n<a href=\"https://medium.com/media/b84fda36807764dfaa31335aff739a4a/href\">https://medium.com/media/b84fda36807764dfaa31335aff739a4a/href</a><ul><li>Ananymous volumeslar container silindikten sonra otomatik olarak silinir.</li></ul>\n<h4>docker volume -help</h4>\n<ul><li>Aşağıda docker volume ile yapabileceğimiz komutların bazılarını görüyorsunuz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/285/1*whZs7r1mTqcWimR_fXCt7A.png\"></figure><h4>docker volume ls</h4>\n<ul><li>Docker volumelerimizi listeler.</li></ul>\n<h4>docker volume create volumeName</h4>\n<ul><li>Docker volumesı oluştururuz.</li></ul>\n<h4>docker volume prune</h4>\n<ul><li>Kullanılmayan voluemleri siler.</li></ul>\n<h4>docker volume rm volumeName</h4>\n<ul><li>volume ismine göre volumelerimizi siler.</li></ul>\n<h4>docker volume inspect volumeName</h4>\n<ul><li>Oluşturduğumuz volume ait bilgileri görürüz yani inspect ederiz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*grgVtSNaEpzLvqPO9nt6Gg.png\"></figure><ul><li>Terminale gelip yeni temiz bir image buildi alıyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*jxbx5oqFsAIn_LDvIBM7lw.png\"></figure><h4><strong>docker run -v volumeName:/volumePathFromWorkdirOnImageFileSystem …</strong></h4>\n<ul><li>Yukarıda ise named yani isimlendirilmiş bir volume oluşturuyoruz, imagemizi container oluşturup çalıştırırken yapıyoruz bu işlemleri. İlk olarak volume için isim veriyoruz, ikinci olarak ise : işaretinden sonra imagemizdeki hangi pathdeki dosyaları bu volumede tutacağımız yolu belirliyoruz.</li></ul>\n<p><strong>docker run -v feedback-volume:/app/feedback --name feedback-container -p 3000:80 --rm -d feedback-node:latest</strong></p>\n<ul>\n<li>Bizim kendi örneğimizzden gidecek olursak,<br>1. -v ile feedback-volume adında bir volume oluşturuyoruz ve bu volumenin yolu olarakta : işaretinden sonra imagedeki WORKDIR’den volumede tutulacak konumu belirliyoruz.<br>2. --name ile oluşturulup çalıştırılacak containerımıza feedback-container ismini veriyoruz.<br>3. -p ile makinamızdaki 3000 portunu containerın çalıştırdığı imagenin 80 portuyla bind ediyoruz<br>4. --rm ile container stop olduğunda silinsin istiyoruz.<br>5. -d ile detach modda çalışsın istiyoruz. Bu bizi container başlattıktan sonra default olarak attach moddan kurtarır. Böylelikle node terminalinde kalmayız ve direk kendi terminalimize döneriz.<br>6. Ve son olarakda feedback-node:latest ile imageName ve tagine göre imagemizi seçiyoruz.</li>\n<li>Yukarıdaki kodu çalıştırıp detach moda geçtiğimizde<br>1. docker ps -a yaparak tüm containerlarımızı görüyorum ve ilk gördüğünüz gibi containerımız çalışıyor.<br>2. Daha sonra docker volume ls yaparak volumeleri listeliyorum. Ve gördüğünüz gibi yukarıda imagemizi containerla çalıştırırken oluşturduğumuz volume burada.<br>3. Daha sonra docker stop containerId mi yazarak çalışan containerımı durduruyorum ve --rm bu container otomatik olarak siliyor. Hatta 2 alt satırda docker ps -a yaptım bunu görmeniz için.<br>4. Daha sonra docker volume ls yapıyoruz ve volumemizin hala silinmediğini ve orada olduğunu görüyoruz. Containerın silinmesine ragmen. Buda bir daha yeni container oluştursak bu volumeyi kaybetmeyeceğimiz için uygulamamız sürekli her çalıştığında aynı verileri bulup saklayabileceği anlamına gelmektedir.<br>5. Ve en alt satırda ki gibi, containerımız silindikten sonra tekrar aynı image ile yeni container oluşturup çalıştırırken aynı isim ile volume’ye bağlanmalıyız.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*eYMi61st67zwFZFJqxpsag.png\"></figure><ul>\n<li>Container ve volume etkileşimini iyi anlamamız gerekmektedir.</li>\n<li>Container ilk açıldığında /app/data da eğer dosya yoksa volüme deki /some-path den alır. Fakat dosya varsa eğer o zaman containerdaki dosyalar volüme deki /some-path üzerine overwrite edilir yani yazılır.</li>\n<li>Fakat /app/code içinde ilk container çalıştığında dosya yoksa /some-other-path volumedeki dosyalar /app/code içine gönderilerek container her başladığında eklenir.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*XJ7O8s3xGcZDoMz2p8EP8Q.png\"></figure><h4>Sharing Source Code with a Container</h4>\n<ul>\n<li>Ve şimdi şöyle bir sistem yapalım. Lokalimizde proje dosyalarında herhangi bir değişiklik yaptığımız da bunun projeye anında yansımasını sağlayan bir yapı kuralım volumelerle.</li>\n<li>Aşağıda ki gibi projemizde bir değişiklik yaparsak bu hemen browserda bize yansımaz. Bunun için yeni bir volume tanımalıyız. Öyle bir şey yapacağız ki projedeki herhangi bir değişiklik immediately yani acil olarak containera yansıyacak.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*_BlYr8v1qzYSk8TWs0tzvw.png\"></figure><p><strong><em>NOTE</em></strong>: Tabi burada unutmamız gereken şey,<br>önceki volume tanımlamamız orada dataları toplayıp daha sonra uygulamamızın containerı çalışıp mount olduğunda burada voluemdaki dataları uygulamamıza kopyalamak,<br>burada ki volüme tanımlamamızda ki sebep ise uygulamamız açıldığında, şuan ki dizinin adında bir volüme oluşturup bunu anında uygulamamızın containerı çalıştığında oradaki WORKDIR’e yani /app’e göndermek.</p>\n<p>PATH Tanımlamaları</p>\n<ul>\n<li>İster absolute pathi almak için aşağıdaki gibi uzun adres tanımlayın<br><strong>E:\\Software\\worksheets\\docker\\examples\\volume-example\\final</strong>\n</li>\n<li>İsterseniz de aşağıdaki gibi sistemlere özgü kısa yolları kullanın<br><strong>macOS / Linux:</strong> -v $(pwd):/app<br><strong>Windows:</strong> -v “%cd%”:/app</li>\n<li>Veya image tercihine göre containerımızın virtual machinesinin çalıştıracağı imageye göre aşağıdaki şekillerde kullanabilirsiniz.</li>\n</ul>\n<p><strong>FROM node:14<br></strong>docker run -v feedback-volume:/app/feedback -v <strong>${pwd}</strong>:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</p>\n<p><strong>FROM node:14.16.0-alpine3.13<br></strong>docker run -v feedback-volume:/app/feedback -v <strong>$(pwd)</strong>:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</p>\n<p><strong>with absolute path<br>E:\\Software\\worksheets\\docker\\examples\\volume-example\\final<br></strong>Özel karakter olur diye “” bu isaret içinde yazmak en güvenilir yoludur volume pathi tanımlarken. Özel karakter yoksa kullanmayada gerek yoktur. Aslında aşağıda da kullanmasak da olurdu.<br>docker run -v feedback-volume:/app/feedback -v <strong>“Software\\worksheets\\docker\\examples\\volume-example\\final:/app” --</strong>name feedback-container -p 3000:80 --rm -d feedback-node:latest</p>\n<h4><strong>docker run -v /pathThatBindingWithVolume</strong></h4>\n<ul><li>Eger volumeName yazmasak yukarıda ki gibi, anonymous bir volume tanımlamış oluruz.</li></ul>\n<h4><strong>docker run -v bindedPathOnOurOS:/bindedPathOnVMOS</strong></h4>\n<p><strong>docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</strong></p>\n<ul>\n<li>Evet bunun için ikinci bir volume belirliyoruz -v ile. Birinci volume hatırlarsanız feedbackleri volumeda tutmak içindi.</li>\n<li>Ve bu volume’yi dynamic olarak <strong>node:14</strong> imagesini kullandığım için <strong>${ }</strong> arasina pwd yazarak current directorymizle bir volume oluşturuyoruz. Ve bu volumeyi imagedeki app klasörüyle bağlıyoruz. Böylelikle projede yani ${pwd} dizininde yaptığımız her değişiklik anında app klasörüne yansımış olacak.</li>\n<li>Bu şekilde docker run yaptığımızda uygulamamızın çalışıp ve bir container oluşturup ardından daha sonra hemen stop ederek containerın silindiğini göreceksiniz. Çünkü express hatası verecek aşağıda ki gibi.</li>\n</ul>\n<p><strong>docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 -d feedback-node:latest</strong></p>\n<ul>\n<li>Bunu gösterebilmek için ben --rm yi silerek yukarıdaki kodun aynısını çalıştıracağım. Böylelikle uygulamamız hata verdiğinde otomatik kapanmayacak ve container silinmeyecek. Bu şekildede biz containerın çalıştırdığı imagemizin terminale bastırdığı hatanın logunu alabileceğiz.</li>\n<li>Gördüğünüz gibi Express hatası alıyoruz. Sebebi ikinci volüme(<strong>-v ${pwd}:/app --name feedback-container</strong>) tanımlamamız yüzünden. Çünkü <strong>pwd</strong> deki kendi OS sistemimizdeki dizinde bizim node_modules klasörümüz yukarıda tanımladığımız volumenin bizim pwd dizinindeki tüm herşeyi /app ile overwrite etmesinden dolayı yok, yani uygulamamız npm install yapıyor imagenin Dockerfilesına göre ama daha sonra bu node_modules overwrite yüzünden siliniyor ve uygulama mounted olduğunda node_modules olmayan buradaki tüm klasörler ve dosyaları, imagemizin çalıştığı containerdaki WORKDIR deki /app dizinindeki tüm dosyalarla değiştir. Buda Dockerfile ile npm install yapıp yüklediğimiz node_modules de silinmiş oluyor.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*s2KBalno70zlOQQTj4o01Q.png\"></figure><ul><li>Bu sorunu gidermek için bir kaç farklı yöntem var. Ya bir user oluşturup, buna çeşitli yetkiler vererek halledebiliriz. Yada aşağıdaki gibi node_modules’u başka bir anonymous volume’a veririz ve silinmesini engelleriz. Ve bu şekilde yukarıdaki hatayı önlemiş oluruz.</li></ul>\n<p><strong>docker run -v feedback-volume:/app/feedback -v ${pwd}:/app -v /app/node_modules --name feedback-container -p 3000:80 -d --rm feedback-node:latest</strong></p>\n<ul>\n<li>Ve şimdi artık uygulamamızda yaptığımız her değişiklik anında çalışan containerdaki dosya sistemimize anında yansıyacaktır. Artık dosyada bir değişiklik yapıp bunu görebilirsiniz.</li>\n<li>Fakat yinede bir sorunumuz daha var yukarıdaki yaptığımız değişiklikler dosyalara aynı anda hemen yansır fakat bizim projemiz bu yansımayı hemen bize gösterir mi? Pages içindeki html sayfalarında yaparsak eğer bir f5 sornası yaptığımız değişikliği hemen görebiliriz. Fakat biz hatırlarsanız nodeda kullandığımız express serverını node server.js diyerek başlatıyoruz. Yani biz server.js içindeki bir fonksiyon içinde bir console.log yapacak olursak, node server.js ile bunu yaptığımız için değişiklik hemen yansımayacaktır, çünkü node serverını kapatıp tekrar node server.js dememiz gerekecektir içindeki o değişikliği yakalayabilmek için. Veya bunun için nodemon adında bir npm packagei çözüm sunar bize. O zaman buradada bu değişikliği aşağıdaki gibi package.jsona hemen ekliyoruz.</li>\n</ul>\n<p><a href=\"https://gist.github.com/mucahidyazar/ffc479cfbc0b4257ecb5e986604b17b8\">https://gist.github.com/mucahidyazar/ffc479cfbc0b4257ecb5e986604b17b8</a></p>\n<ul>\n<li>Ve yukarıda ki yaptığımız değişiklikten ötürü CMD yi artık node server.js yerine yukarıda tanımladığımız script ile kullanacağız.</li>\n<li>Anonymous volumeyide her seferinde terminalde yazmak yerine artık Dockerfileye aşağıdaki gibi ekliyoruz.</li>\n</ul>\n<a href=\"https://medium.com/media/e9239ae3b6d542fc0b59e1396f85cdf4/href\">https://medium.com/media/e9239ae3b6d542fc0b59e1396f85cdf4/href</a><ul>\n<li>Daha sonra imagemizi yeniden build alarak oluşturuyoruz.</li>\n<li>Ve artık terminale gelip aşağıdaki kodla imagemizi container oluşturarak çalıştırıyoruz.</li>\n</ul>\n<p><strong>docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 -d --rm feedback-node:latest</strong></p>\n<ul>\n<li>Aslında (<strong>${pwd}:/app</strong>) bunu yaparak Dockerfiledaki COPY . . nın işini bir nevi yine yapıyoruz yani Dockerfiledan onu kaldırsakta hiç bir şey olmaz. Fakat biz (<strong>${pwd}:/app</strong>) bunu developmentda yaptığımız için günün sonunda COPY . . ya bizim productionda yine ihtiyacımız olacak o yüzden kaldırmaya gerek yok yinede tutabiliriz.</li>\n<li>Ve şimdi server tarafında yaptığımız değişikliklerde anında yansıyacaktır nodemon sayesinde.</li>\n<li>Bu tarz sorunlar bize farklı uygulamalarda da çıkabilir bunları aşmak için bu tarz yöntemleri araştırıp bulmalıyız veya geliştirmeliyiz.</li>\n</ul>\n<h4>ro (read-only)<br>docker run -v volumeName:/projectPath:ro</h4>\n<ul><li>Yukarıda ki gibi tanımlayacağımız volumeleri sadece read-only yapabiliriz.</li></ul>\n<h3>ENVironment Variables &amp; ARGuments</h3>\n<h4>ENV</h4>\n<ul><li>Environment variablelari ise Dockerfile içerisinde asagidaki gibi ya aralarinda bir bosluk birakarak yada = ile tanimlayabiliriz ben = ile tanımlamayı tercih ediyorum.</li></ul>\n<a href=\"https://medium.com/media/2965ca455e97dbae8ae6de11f7793511/href\">https://medium.com/media/2965ca455e97dbae8ae6de11f7793511/href</a><ul><li>Ve daha sorna imagemizi oluşturup containerimızı imagemizle çalıştırdığımızda istersek bu environmentleri aşağıda ki gibi görebiliriz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*RzTwqJbwDXTqm2iywI8_IA.png\"></figure><ul><li>Veya shell ile çalıştırdığımız için istersek yazdırabiliriz de echo yaparak.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*UhdCNM6LQc_Nv0r4iJY8Uw.png\"></figure><h4>docker run --env/-e PORT=80 …</h4>\n<ul><li>Veya yukarıdaki tanımdaki veya aşağıdaki örnekteki gibi docker run yaparken de environment variablesları tanımlayabilirsiniz.<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app --<strong>env PORT=80</strong> feedback-image<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app <strong>-e PORT=80</strong> feedback-image<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app --<strong>env PORT=80</strong> --<strong>env ENDPOINT=https://www.google.com</strong> feedback-image</li></ul>\n<h4>docker run --env-file ./dev.env …</h4>\n<ul><li>Veya kendi OS sistemimizde terminaldeki konumumuza göre dev.env veya prod.env gibi dosyalarımızı --env-file komutuna tanımlatarak aslında birden fazla environment variable olan dosyamızdaki tüm environment variablesları tanımlatabiliriz.</li></ul>\n<h4>ARGuments</h4>\n<ul>\n<li>Argslar bizim aslında Dockerfile içinde tanımladığımız variableslardır diyebiliriz.</li>\n<li>Ve genellikle ENVlerin hemen üstüne tanımlamalıyız çünkü değiştiklerinde aşağısındaki layerların bir daha boş yere hesaplanmasını istemiyoruz.</li>\n</ul>\n<a href=\"https://medium.com/media/d63f877abc21de3ebd928cd788ac69ad/href\">https://medium.com/media/d63f877abc21de3ebd928cd788ac69ad/href</a><ul><li>Ve artık aşağıdaki gibi yeni bir build aldığımızda default port env ve expose port 80 olarak hesaplanarak image oluşturulur.</li></ul>\n<p><strong>docker build -t feedback-image .</strong></p>\n<ul>\n<li>Fakat istersekde sadece arg tanımımızı docker run da değiştirerek default portu ezerek yeni bir arg tanımlayabiliriz aşağıda ki gibi.</li>\n<li>Böylelikle bu buildimiz ise yeni Dockerfile içinde olan DEFAUULT_PORT argını yeni değeri 8000 ile tanımlamış oluruz.</li>\n</ul>\n<p>docker build -t feedback-image:defaultArg --build-arg <strong>DEFAULT_PORT=8000</strong> .</p>\n<h3>NETWORKING: (CROSS-) CONTAINER COMMUNICATION</h3>\n<ul><li>Öncelikle githubdan api-example örneğinin starter klasörünü vs codeumuzda indirip açıyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*qfmfMRnNZkIDJB3wg4-y-g.png\"></figure><ul><li>Bu örnekte containerımızla dış dünya arasındaki ilişkileri inceleyeceğiz. Burada 3 çeşit bağlantımız olabilir.</li></ul>\n<ol><li>Bir API’a istek atıyor olabileceğimiz durumlar. Bu örneğimizde starwars ile ilgili bir apia istek atıyoruz.</li></ol>\n<a href=\"https://medium.com/media/16bb38907548a9147f3bcd0c6b8e5d21/href\">https://medium.com/media/16bb38907548a9147f3bcd0c6b8e5d21/href</a><p>2. Local makinamızla kuracağımız communicationlar. Bu örneğimizde mongodb’ye kendi makinamızda bağlanıyoruz.</p>\n<a href=\"https://medium.com/media/3f6ece701108b4440ccaa63670cd7fa7/href\">https://medium.com/media/3f6ece701108b4440ccaa63670cd7fa7/href</a><p>3. Başka containerlarla olan communicationlar. Bu örneğimizde şuan yok ama ileride bunları da yapabiliyor olacağız.</p>\n<h4>API Communications</h4>\n<ul>\n<li>Api communicatinoslar için yapmamız gereken her hangi bir özel ayar yoktur.</li>\n<li>Yukarıdaki örnek için konuşacak olursam, app.listenı en yukarı alarak mongoose’yi tamamen iptal ediyorum çünkü şuanda bu şekilde dockerda çalıştırırsak imagemizi build alıp mongoose, localhost’a bağlanamayacağı için hata verecek ve app.listen serverımızı çalıştırmayacaktır.</li>\n<li>Aşağıdaki gibi yapıp build alıyoruz,</li>\n</ul>\n<p><strong>docker build -t api-image .</strong></p>\n<ul><li>Daha sorna run yapıyoruz</li></ul>\n<p><strong>docker run --rm --name api-container -p 3000:3000 api-image:latest</strong></p>\n<ul><li>Ve şimdi localhost:3000/movies veya localhost:3000/people ‘a gidersek swapi.dev apiına atyıp aldığımız responseleri, kendi responselerimiz olarak browserda göreceğiz. Yani hiçbir ayar yapmadan api isteklerini atıp alabiliyoruz.</li></ul>\n<a href=\"https://medium.com/media/e7669f3cf8d1eac10b48e9d0f56b08f2/href\">https://medium.com/media/e7669f3cf8d1eac10b48e9d0f56b08f2/href</a><h4>Your Host Machine Communications</h4>\n<ul>\n<li>Şimdi tekrar yukarıdaki satırı eski haline getiriyoruz.</li>\n<li>Tek yapmamız gereken localhost yerine host.docker.internal kullanmaktır. Bu o anki hostunuzun adresi ne ise onun tarifidir. Localhost ise localhost, www ile başlayan özel bir AWS hostu ise o hostu temsil eder.</li>\n<li>Ve şimdi tekrar aşağıdaki gibi yapıp build alıyoruz,</li>\n</ul>\n<p><strong>docker build -t api-image .</strong></p>\n<ul><li>Daha sorna run yapıyoruz</li></ul>\n<p><strong>docker run --rm --name api-container -p 3000:3000 api-image:latest</strong></p>\n<ul><li>Ve artık localhost’a attığımız favorites POST isteğinide postman vasıtasıyla atıp, localdeki mongo databasemize birşeyler kaydedebiliriz.</li></ul>\n<a href=\"https://medium.com/media/ac0338cd931d9facdd38ee061e473be7/href\">https://medium.com/media/ac0338cd931d9facdd38ee061e473be7/href</a><h4>Containers Communications</h4>\n<ul>\n<li>İlk önce mongo imagesini dockerhubdan indirtip makinamızda çalıştıralım.<br><strong>docker run --rm --name mongo-container -d mongo</strong>\n</li>\n<li>Daha sonra docker ps yaptığımızda göreceğiniz üzere mongo-container adında bir container çalışıyor.</li>\n<li>Daha sonra buna inspect yaparak bu containerın bilgilerini alıyoruz.<br><strong>docker inspect mongo-container</strong>\n</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*q-qyn4miehe4bEYdXmAzJw.png\"></figure><ul><li>Ve daha sonra çıkan bilgilerden, Networks’deki bridgeden IPAdress’i alıyoruz ve aşağıdaki gibi mongodb tanımına yazıyoruz.</li></ul>\n<a href=\"https://medium.com/media/5cbc87d57c7d1c2e8ace41001a0f7c4e/href\">https://medium.com/media/5cbc87d57c7d1c2e8ace41001a0f7c4e/href</a><ul><li>Ve şimdi tekrar uygulamamızın imagesini silip tekrar build alıyoruz ve run yapıyoruz. Göreceksiniz ki artık mongodb miz diğer containerın ip adresine bağlanacaktır. Ve hatta localhost:3000/favorites adresine istek attığınızda göreceksiniz ki boş bir array dönecek çünkü bu mongo imagesinin hostundaki databaseden dönen değerdir.</li></ul>\n<h3>Networks</h3>\n<ul><li>Containerları dahil edebilip birbirleriyle iletişim kurabilecekleri bir grup gibi düşünebilirsiniz burayı. Birden fazla containerı bir network oluşturup bu networke dahil ederiz run yaptığımız zaman ve daha sonra birbirlerine ulaşmak için tek yapmaları gereken birbir container isimlerini kuyllanmak olacaktır.</li></ul>\n<h4>docker network create networkName</h4>\n<ul><li>Containerların birbirleriyle iletişim kuracağı network oluşturur</li></ul>\n<h4>docker network ls</h4>\n<ul><li>Networkleri listeler.</li></ul>\n<h4>docker network rm networkName</h4>\n<ul>\n<li>network ismi ile networku siler.</li>\n<li>Yukarıda ki örneğimiz için önce çalışan containerlarımızı durduruyoruz.</li>\n<li>Ve aşağıdaki gibi bir network kuruyoruz.</li>\n</ul>\n<p><strong>docker network create api-network</strong></p>\n<ul><li>Ve şimdi mongo imagemizi çalıştırıp containerının bu networke dahil olmasını sağlıyoruz. Ve artık mongo imagemizin containerı api-network adında kurduğumuz networke girmiş oluyor.</li></ul>\n<p><strong>docker run --rm --name mongo-container -d --network api-network mongo</strong></p>\n<ul><li>Şimdi uygulamamızdaki app.js’e gelip mongodb bağlantı noktasını mongo imagesi için ayarladığımız container isimi olan mongo-container yapıyoruz aşağıdaki gibi.</li></ul>\n<a href=\"https://medium.com/media/4dcbd58497fb63730055428d6055efe3/href\">https://medium.com/media/4dcbd58497fb63730055428d6055efe3/href</a><ul><li>Ve şimdi bu uygulamamızın imagesinide silip yeniden build alıyoruz.</li></ul>\n<p><strong>docker build -t api-image .</strong></p>\n<ul><li>Ve şimdi uygulamamızı aşağıdaki gibi mongo imagesini run ederken yaptığımız gibi aynı networke dahil edip run yaptırıyoruz.</li></ul>\n<p><strong>docker run --rm --name api-container -p 3000:3000 --network api-network api-image:latest</strong></p>\n<ul><li>Ve artık imagemizde aynı networkde olduğu için diğer containerı container adıyla yani mongo-container ile tanıyım bulup başarılı bir şekilde diğer bir containerla iletişimi kurup isteklerimizi cevap verecektir.</li></ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f5d1ee8b815b\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["nodejs", "docker", "network", "volume", "networking"],
    "slug": "f5d1ee8b815b"
  },
  {
    "title": "Test - Docker - The core part (Image &amp; Container)",
    "pubDate": "2021-05-28 07:03:56",
    "link": "https://mucahidyazar.medium.com/docker-the-core-part-image-container-6b3f19013bcf?source=rss-23bff8df3108------2",
    "guid": "https://medium.com/p/6b3f19013bcf",
    "author": "Mucahid Yazar",
    "thumbnail": "https://cdn-images-1.medium.com/max/1024/0*JXT3zSoRCES-roVv.png",
    "description": "\n<ul>\n<li>Docker bizim containerları hazırlamak için kullandığımız tooldur.</li>\n<li>Docker kullanmamızın nedenlerinden birisi ise, biz kendi projemizi node.js’in belirli spesifik bir sürümü ile örneğin v13 ile yapıp, herhangi bir node.js uygulaması çalıştıran siteye yüklersek orası belki v12 node.js kullandığı için uygulamamız hata verebilir, fakat docker ile uygulamalarımızı standartlaştırarak containerlar oluşturur ve bu containerları docker destekleyen bir sunucuya(AWS gibi…) yüklersek, uygulamalarımız her zaman bizim belirlediğimiz standartlara göre çalışacaktır.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*JXT3zSoRCES-roVv.png\"></figure><h4>Install Docker</h4>\n<ul>\n<li>Önce Hyper-V ve Containers’ı Turn Wiondows feature on/of kısmından aktif ediyoruz.</li>\n<li>Sonra Dockerın sitesite giderek kullandığımız OS’e göre Dockerın kendisini yüklüyoruz.</li>\n</ul>\n<h4>docker … --help</h4>\n<ul><li>Başlamadan öcne bilmemiz gereken en önemli şeylerden birisi de, terminalde çalışırken tüm docker komutlarının detaylarını --help yaparak inceleyebiliriz.</li></ul>\n<p>docker images --help<br>docker image --help<br>docker container --help</p>\n<h3>IMAGES</h3>\n<h4>Dockerfile</h4>\n<ul><li>Her türlü uygulamayı içine sadece <strong>Dockerfile</strong> ekleyerek docker ile bir imageye çeviririz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*9MzAYkVjj5y_eAHBWqqGEg.png\"></figure><ul><li>Image uygulamamız için gerekli olan herşeyi içine alır.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*n32UJqQgigJbaGNaTtd1xg.png\"></figure><ul>\n<li>Ve biz bu imageyi dockera vererek containerla çalıştırmasını isteriz.</li>\n<li>Imagemiz hazır olduktan sonra registirye göndeririz. Burası docker hub yani github gibi bir yerdir herkes kullanabilir. Daha sonra registirydeki bu imagemizi buradan herhangi bir docker çalıştıran makinada uygulamamızı çalıştırabiliriz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*wdB2-ue1pojtL6IxcOLfgw.png\"></figure><ul><li>Ve ayrıca imageler aşağıdakileri de içerir.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*X-aLj6enapzLupfonKbqnA.png\"></figure><h4>.dockerignore</h4>\n<ul><li>Tabi ki de node_modules klasörünü docker imagesine koymak istemeyiz çünkü çok büyük boyutlarda olabilirler bunun içinde .dockerignore dosyası oluşturup içine istemediğimiz dosyaları ve klasörleri yazarız. Aşağıdaki gibi…</li></ul>\n<a href=\"https://medium.com/media/c1245081a5ce0ac679e41b0f0b536c94/href\">https://medium.com/media/c1245081a5ce0ac679e41b0f0b536c94/href</a><h3>CONTAINERS</h3>\n<ul><li>Containerı ise bir piknik sepeti gibi düşünebilirsiniz. Nasıl piknik yapmak için tek ihtiyacımız olan bir piknik sepeti ise, bir projede ihtiyacımız olan her şey bir container içinde olur.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*zdHud-iI8Hk4TpygW9r-OQ.png\"></figure><h4>Images vs Containers</h4>\n<ul>\n<li>Aynı image birden fazla container ile çalışabilir.</li>\n<li>Imageler kendilerine has environment variableslarına sahip olabilirler.</li>\n<li>Imageler uygulamamızı ve kodlarımızı taşır ve onların blueprintsleridir.</li>\n<li>Imagesler read ve only iken containerlar write, read ve execute accesine sahiptirler.</li>\n<li>Imagesler bir layerdır, containerlarda aslında onların parent layerlarıdır diyebiliriz.</li>\n<li>Birbirlerini etkilemeden aynı imageyi farklı bir çok container ile çalıştırabiliriz.</li>\n<li>Containerlar, imageler üzerinde yalıtılmış isolated edilmiş bir yazılım birimidir.</li>\n</ul>\n<h3>DOCKER BASIC EXAMPLE</h3>\n<ul>\n<li>Gelin ilk basit uygulamamızı birlikte dockerize edelim.</li>\n<li>Elimizde aşağıda ki gibi app.js dosyası olan ve log basan bir dosyamız var.</li>\n<li>İlk olarak Dockerfile adında bir dosya oluşturuyoruz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*UB37V5NVASGHuKAxeao-KQ.png\"></figure><ul>\n<li>Daha sonra FROM ile bu imagemizin çalıştıracağı imageyi ayarlıyoruz. app.js’i node.js ile çalıştıracağımız için, node.js’e sahip bir image layerını burada seçmemiz gerekiyor ki Docker bu imageyi alıp bizim çalıştırmasını istediğimiz node.js dosyasını yani app.js’i çalıştırabilsin.</li>\n<li>Ve daha sonra distrubitionu seçiyoruz. Alpine bir linux distrubitiondur. Bizim node imagesini direk kullanmak yerine node:alpine kullanmamızın nedeni, boyutu ve performans açısından direkt olarak node.js imagesinden daha performanslı olmasıdır.</li>\n</ul>\n<a href=\"https://medium.com/media/9246311f1e426c0821a3b2e273ecf5be/href\">https://medium.com/media/9246311f1e426c0821a3b2e273ecf5be/href</a><ul><li>Aşağıda ki resimde dockerhub’da aratarak bulduğum, aynı zamanda yukarıda da FROM ile kullandığımız <strong>node:alpine</strong> gibi bir image görüyorsunuz aslında.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/656/1*AKvtLFVB-c2g3iZwdHlcpQ.png\"></figure><ul>\n<li>Daha sonra COPY diyerek <strong>“.”</strong> ile tüm dosyalari kopyala yapıyoruz ve <strong>“/app”</strong> klasorüne kopyalansın diyoruz.</li>\n<li>Ve daha sonra CMD ile komutu çalıştır diyoruz. İlk önce bunu normalde kendi makinamızda çalıştırsaydık node app.js diyeceğimiz için burada da dockerın node ile calıştırmasını söylüyor ve dosyanın yerini veriyoruz. Kopyaladığımız dosyaları <strong>app </strong>adında bir klasöre atmıştık hatırlarsanız.</li>\n</ul>\n<a href=\"https://medium.com/media/e101c94f260f1e72023c522dfa5a4125/href\">https://medium.com/media/e101c94f260f1e72023c522dfa5a4125/href</a><ul><li>Veya WORKDIR ile bir çalışma yolu belirleyerek daha sonra node app.js de yapabiliriz CMD ile.</li></ul>\n<a href=\"https://medium.com/media/a40d42e0164b5d5818482404bb0f3771/href\">https://medium.com/media/a40d42e0164b5d5818482404bb0f3771/href</a><ul><li>Ver ilk Dockerfile’mızı oluşturduk. Şimdi imagemizi oluşturup çalıştırabiliriz. Fakat bu detaylara daha sonra geleceğim.</li></ul>\n<h3>Dockerfile</h3>\n<ul><li>Dockerfile içinde aşağıdaki alanlar bulunur. Tüm bu kısımları detaylıca birlikte göreceğiz merak etmeyin.</li></ul>\n<p><strong>FROM</strong> specify BASE iamge<br><strong>WORKDIR </strong>Working directory calisma dizini<br><strong>COPY</strong> kopyalamaya yarar<br><strong>ADD</strong> kopyalamya yarar<br><strong>RUN</strong> execute etmeye yarar kodlari<br><strong>ENV </strong>environment variables tanimlariz<br><strong>EXPOSE</strong> dockerin imageyi calistiracagi portu ayarlar<br><strong>USER</strong> uygulamayi calistiracak useri tanimlar<br><strong>CMD </strong>commandin execute edilmesini saglar her acildiginda<br><strong>ENTRYPOINT </strong>commandin execute edilmesini saglar her acildiginda</p>\n<a href=\"https://medium.com/media/5578329504ce2f0de117865059c0108c/href\">https://medium.com/media/5578329504ce2f0de117865059c0108c/href</a><h3>EXAMPLE of CREATE-REACT-APP</h3>\n<ul><li>Yukarıdaki bilgiler ışığında create-react-app ile daha complex bir uygulama oluşturup bunu dockerıze edebiliriz. Ben <strong>create-react-app react-app</strong> yapıyorum.</li></ul>\n<h4>FROM</h4>\n<ul><li>Dockerhub’da bir image buluyoruz FROM da kullanacağımız. Biz react projesini dockerıze edeceğimiz için bir node.js imagesi buluyoruz. Alpine sürümlerinin boyutları az olduğu için onları tercih ediyoruz.</li></ul>\n<a href=\"https://medium.com/media/9f08c2c138f22344dbe5263defffce6e/href\">https://medium.com/media/9f08c2c138f22344dbe5263defffce6e/href</a><ul><li>Terminali açıp Dockerfile’mızın olduğu konuma geliyoruz. Ve aşağıdaki kodları uygulayarak neler yaptığını görüyoruz.</li></ul>\n<h4><strong>docker build .</strong></h4>\n<ul>\n<li>Aslında şimdi Dockerfilemızı build alıp image oluşturarak, <strong>node:14.16.0-alpine3.13</strong> deki linux terminale bağlanabiliriz.</li>\n<li>Burada ki <strong>“.”</strong> ile ise Dockerfile mizin olduğu konumu söyleriz.</li>\n</ul>\n<h4><strong>docker images</strong></h4>\n<ul><li>Makinemizde oluşturduğumuz veya çektiğimiz tüm imageleri gösterir. (Intermediate imageler hariç)</li></ul>\n<h4><strong>docker images -a</strong></h4>\n<ul><li>Tüm imageleri gösterir.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*1vH5_r2FRBn_p6V1xCGSZg.png\"></figure><h4>docker image ls</h4>\n<ul><li>Tüm imageleri listeler. docker images ile aynı işlevi gerçekleştirir bir nevi.</li></ul>\n<h4>docker image prune</h4>\n<ul>\n<li>Kullanılmayan imageleri siler.</li>\n<li>Kullanilmayan imageleri sildikten sonra imageleri listelersek sadece kendi olusturdugumuz ve pull yaptigimiz imageleri goruruz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*XZURxiHLkr3ZRwTfNuK5qA.png\"></figure><h4>docker image prune -a</h4>\n<ul><li>Kullanılsın kullanımlasın tüm imageleri siler.</li></ul>\n<h4>docker rmi imageName:tag/imageId<br>docker image rm imageName:tag/imageId</h4>\n<ul><li>Prune ile silinmeyen yukarıda ki gibi imageleri silmek içinse asağıda ki gibi docker image dedikten sonra remove anlamına gelen rm ve image adınıveya idsini yazariz.<br><em>docker image rm react-app<br>docker image rm df3</em>\n</li></ul>\n<h4><strong>docker ps</strong></h4>\n<ul><li>Çalışan bütün containerları gösterir.</li></ul>\n<h4><strong>docker ps -a</strong></h4>\n<ul><li>Bütün containerları gösterir.</li></ul>\n<h4>docker container ls</h4>\n<ul><li>Tüm containerları listeler. docker ps -a ile aynı işlevi gerçekleştirir bir nevi.</li></ul>\n<h4>docker container prune</h4>\n<ul><li>Kullanılmayan containerları siler.</li></ul>\n<h4>docker rm containerName/containerId<br>docker container rm containerName/containerId</h4>\n<ul><li>prune ile silinmeyen containerları silmek içinse asağıda ki gibi docker container dedikten sonra remove anlamina gelen rm ve container adını veya idsini yazarız.<br><em>docker container rm react-app<br>docker container rm df3</em>\n</li></ul>\n<h4>docker rm -f containerName/containerId<br>docker container -f rm containerName/containerId</h4>\n<ul><li>Çalışan containerları force yaparak önce durdurur sonra siler. Yukarıda ki kodla çalışan containerları silemeyiz.</li></ul>\n<h4>docker stop containerId</h4>\n<ul><li>Bu şekilde de belirli bir container id ye sahip containerin çalışmasını durdururuz.</li></ul>\n<h4>docker start -i containerId</h4>\n<ul>\n<li>Bu şekilde de belirli bir container id ye sahip containerı çalıştırırız. Id’nin ilk 3 karakteri de yeterli olur. Veya id yerine containerName de yazabilirsiniz.</li>\n<li>-i terminal ile interact olmasını sağlar yani terminale bağlnamasını sağlar.</li>\n</ul>\n<h4>exit</h4>\n<ul><li>-it ile interactive bir şekilde başlattığımız containerlar Docker container sessionunu kapatır ve terminalden çıkar. Fakat containerı tamamen silmez bunu bizim yapmamız gerekiyor.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/479/1*RJZMxYXJOM3C99EpmommQQ.png\"></figure><h3>Naming/Tagging Images</h3>\n<ul><li>Developmentda tagsiz kullanmakta sorun yok ama productionda tagging kesinlikle yapmalıyız. Çünkü ileride yeni tagli versiyonda bir sorun çıkarsa eski tagi bilerek tekrar hemen dönebiliriz.</li></ul>\n<h4>docker build -t imageName .</h4>\n<ul><li>Imageleri listelediğimizde eğer imagelere sadece imageName verdiysek latest tagını görürüz default olarak.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*3sWhJ5YCII-qsSkL6pXhQg.png\"></figure><h4>docker build -t imageName:tag .</h4>\n<ul><li>Oluşturacağımız imagelere -t ile tag ekleyerek isimlendirebiliriz.</li></ul>\n<h4>docker build -t react-app:v0.0.01 .</h4>\n<ul><li>Yukarıda oluşturacağımız image için react-app isimlendirmesi yaptık ve tag olarakda <strong>v0.0.01</strong> olsun dedik.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*clxWvbzv5KYLgmCeia34YA.png\"></figure><ul>\n<li>Genel olarak latest tagini her zaman en son versiona sahip olan image olarak tutmalıyız. Ve latest tagindeki imageyi docker ile çalıştırtmalıyız.</li>\n<li>Tagleri hem dockerfile da yada hemde run timeda asagidaki gibi yazabiliriz.</li>\n<li>Tag verirken bir kac cesit tag verme turu vardir.<br>Versiyon numarası ile: docker build react-app:<strong>v0.0.01</strong> .<br>Sıralamalı : docker build react-app:<strong>0</strong> .</li>\n</ul>\n<h4>tag</h4>\n<p><strong>docker image tag imageId/imageName:tag imageId/imageName:tag</strong></p>\n<ul>\n<li>Bu kodla varolan bir imageyi kopyalayarak yeniden yeni bir isim ve tagle yeni bir image oluşturabiliriz. Veya varolan bir imageyi seçerek, başka bir varolan imagenin bu imageye dönüşmesini sağlayabiliriz. Örneğin yukarıdaki kodda ilk imageId ile seçtiğimiz image bizim için bir referans, daha sorna sında seçtiğimiz ise yeni oluşturtmak istediğimiz image olacak. Veya ikinci seçtiğimiz image adında bir image zaten varsa onu alıp bizim ilk seçtiğimiz imageye çevirtiriz.</li>\n<li>tagi kullanmadan önce aşağıda ilk olarak Dockerfile’a WORKDIR /app adında bir satır daha ekleyerek bir değişiklik yapıyorum.</li>\n</ul>\n<a href=\"https://medium.com/media/c6f3897deef779fe6ff646c1ae06d2ae/href\">https://medium.com/media/c6f3897deef779fe6ff646c1ae06d2ae/href</a><ul><li>Sonra build alarak v0.0.02 tagli yeni imagemi oluşturuyorum.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*sD8DocuiAxGUyxaTN7ez9g.png\"></figure><ul><li>Yukarıda göreceğiniz üzere yeni son version imagemin idsi latest versiondan farklı. Bunu düzeltmemiz gerekiyor.</li></ul>\n<p><strong>docker image tag 5af react-app:latest</strong></p>\n<ul><li>Ve aşağıda 5af id si ile başlayan imageyi seçiyoruz ve artık react-app:latest adında bir image yoksa bunu oluşturmasını veya varsa da bu imagenin artık 5af id li image ile aynısı olmasını istiyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*YRRtMWMQy5w5iSbKQYMPFg.png\"></figure><p><strong>docker image tag 5af react-app:v0.0.03</strong></p>\n<ul><li>Veya hiç olmayan bir image adı ve tagiyle yeni bir image kopyası oluşturabilirdik. tabi ben daha sonra bu v0.0.03'ü aşağıda ki kod ile kaldırıyorum.<br>docker image rm react-app:v0.0.03</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*K0OfmNAwOHb_PdktsOjpKQ.png\"></figure><h3>docker run</h3>\n<h4>docker run imageId/imageName</h4>\n<ul><li>Bu kodla oluşturduğumuz imageleri çalıştırabiliriz.</li></ul>\n<h4>docker run react-app<br>docker run react-app:v0.0.01<br>docker run react-app:latest<br>docker run 34870cf3b371<br>docker run 348</h4>\n<ul><li>Yukarıda bir imageyi genel olarak çalıştırabileceğiniz bir birinden farklı şekilde yöntemleri gösterdim. ister image adıyla, ister image adı ve versiyon numarası ile, ister id ile istersenizde idnizin 3 karakteri ile imagelerimizi çalıştırabiliriz.</li></ul>\n<p><strong><em>docker run node</em></strong></p>\n<ul><li>Bu şekilde çalıştırırsak <em>dockerhub </em>dan node imagesinin son güncel imagesini alıp, makinemize kurup, arka planda bir container oluşturup, node imagesini çalıştıracaktır.</li></ul>\n<h4>docker run -it imageId/imageName</h4>\n<ul><li>-it ile interactive diyerekde imagelerimizi çalıştırarak ardından terminale bağlanabiliriz.</li></ul>\n<h4><strong><em>docker run -it node</em></strong></h4>\n<ul>\n<li>Bu şekilde yaparsak -it ile interactive diyeceğimiz için docker node’un son imagesini indirip yeni bir container oluşturup, bu imageyi kullanarak node imagesini interactive olarak çalıştıracak ve terminale bağlanacaktır. Asagidaki gibi.</li>\n<li>Ve aşağıda göreceğiniz üzere node imagesini run yapip -it ile terminale bağlandığım zaman nodeun versionu 15.4.0, benim kendi makinemdeki ise 14.15.4. Yani burda çalışan container aslında bir sanal makine.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*locy2qoV7DhWlOAEcfSizg.png\"></figure><h4><strong>NAMING CONTAINERS<br>docker run -d --name fakeName imageId</strong></h4>\n<ul><li>Aynı containerı farklı bir isim ile çalıştırmak böylelikle aynı containerı aynı anda 2 kere çalıştırabiliyor olacağız.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*O1UYfpxcBvVgIQPKCcLO5Q.png\"></figure><ul><li>Ve şimdi 2 containerımız var bunlardan birisi blue-sky</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*grV8WBxTSgMgauT5zNnlQQ.png\"></figure><h4>docker run --rm imageName</h4>\n<p>· İmagenin çalıştırıldığı container durdurulduğunda, containerın otomatik olarak silinmesini sağlar.</p>\n<h4><strong>docker build -it react-app .</strong></h4>\n<ul><li>Ve şimdi eğer aşağıda ki gibi docker run yapip -it yani interactive şeklinde oluşturduğumuz imagemizi çalıştırırsak sanal docker makinasında çalışan bir node terminalini çalıştırmış olacağız çünkü “FROM”a “node”u vermiştik hatırlıyorsanız.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*QXLeWzudH7ivjnt1wzmK4g.png\"></figure><ul><li>Eğer bu şekilde başlatmayı denersekte hata alırız çünkü alpine linux imagesi bash ile birlikte gelmez, shell ile gelir. O yüzden boyutu azdır.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*9_cb7HDN35WewxTnpoENkg.png\"></figure><ul><li>Fakat sh ile shelli çalıştırsaydık hem linux dosya sistemini görebilirdik hem de node versiyonumuzu görebilirdik çalışan docker makinamızda.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*ifTMOV6osXi4Yis0J0nBVQ.png\"></figure><h4>COPY / ADD - WORKDIR</h4>\n<ul>\n<li>Şimdi uygulama dosyalarımızı imageye kopyalamamız gerekiyor.</li>\n<li>WORKDIR ile çalışma dizinini /app yapıyoruz. Bu şekilde containerımızı çalıştırdığımızda /app dizininde uygulamamız ayarlanıp başlatılacak.</li>\n<li>COPY ile tüm package ile başlayan dosyalar ve README.md dosyasını /app/ klasörüne kopyalıyoruz.</li>\n<li>Veya dilersek 2. COPY deki gibi . ile tüm dosyaları seçerek /app/ klasörüne kopyalayabiliriz.</li>\n<li>Veya . ile tüm dosyaları seçerek ikinci nokta ile de olduğumuz klasçre yani /app/’e kopyalayabiliriz. Buradaki 2. COPY deki birinci . bizim Dockerfilenin bulunduğu dizini, ikinci . ise imagenin WORKDIR’ini temsil eder yani /app/ dizinini.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*JodsZ68wYWwmVMWa9pSu0w.png\"></figure><ul><li>ADD ile ise bir link ekleyebiliriz veya file.zip gibi sıkıştırılmış dosyalariı açarak istediğimiz yere çıkartabiliriz.</li></ul>\n<a href=\"https://medium.com/media/b1b272c8aff4a40430142261d88f0795/href\">https://medium.com/media/b1b272c8aff4a40430142261d88f0795/href</a><h4>RUN</h4>\n<ul>\n<li>Dockerı yukarida ki haliyle çalıştırdığımızda dependenciesler yüklü olmadığı için sorun olacaktır. O yüzden dependenciesleri imagemizi çalıştırdıktan sonra yükletmeliyiz aşağıda ki gibi.</li>\n<li>Aşağıdaki gibi RUN komutuyla npm komutumuzu çalıştırarak gerekli dependenciesleri yükleyebiliriz.</li>\n</ul>\n<a href=\"https://medium.com/media/4ccd389cbde83b34373e3cdacec491ee/href\">https://medium.com/media/4ccd389cbde83b34373e3cdacec491ee/href</a><ul><li>Aşağıdaki gibi 2 tane komut da çalıştırabiliriz fakat apt komutu FORM daki imagemizden gelen alpine surumu linuxde olmadığı için hata alırız.</li></ul>\n<a href=\"https://medium.com/media/9aa58e0a7facb65242ff6be4926e11b0/href\">https://medium.com/media/9aa58e0a7facb65242ff6be4926e11b0/href</a><h4>ENV</h4>\n<ul><li>Environment variableları ise aşağıda ki gibi ya aralarında bir boşluk bırakarak yada = ile tanımlayabiliriz ben = ile tanımlamayı tercih ediyorum.</li></ul>\n<a href=\"https://medium.com/media/28afc9ee0d68bb9b19223e460821de29/href\">https://medium.com/media/28afc9ee0d68bb9b19223e460821de29/href</a><ul><li>Ve daha sorna imagemizi oluşturup containerimızı shellde interactive olarak imagemizi çalıştırdığımız da istersek bu environmentlerı aşağıda ki gibi görebiliriz..</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*RzTwqJbwDXTqm2iywI8_IA.png\"></figure><ul><li>Veya shell ile çalıştırdığımız için istersek yazdırabiliriz de echo yaparak.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*UhdCNM6LQc_Nv0r4iJY8Uw.png\"></figure><h4>EXPOSE</h4>\n<ul><li>Expose ile port exposing işlemlerimizi yapabiliriz. Dockerda port atadığımızda çalışan port containerda çalışır host üzerinde çalışmaz bunu anlamamız gerekir.</li></ul>\n<a href=\"https://medium.com/media/e364c674b3ed851aad158059c109695a/href\">https://medium.com/media/e364c674b3ed851aad158059c109695a/href</a><ul><li>En son oluşturduğumuz Dockerfile bir üstteki Dockerfile’dır. Gelin bunu build alalım ve <strong>npm start</strong> ile birlikte çalıştıralım ve react-app uygulamamızı çalıştırıp, -it ilede interactive olarak bağlanarak uygulamamızın çalıştığından emin olalım.</li></ul>\n<h4>docker run react:app:latest npm start</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*uqoXu4_XDBaexmKf7RDVyw.png\"></figure><ul><li>Direk npm start komutunu yukarıda ki gibi yazarak run time terminal kodlarımızı burada da çalıştırarak react-app uygulamamızı sanal makinamız üzerinde çalıştırabiliriz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*H_lyDQN_6h5T7Nh7I59KAw.png\"><figcaption>Burada çalışan localhost:3000 kullandığınız sistemdeki 3000 değildir. Bu containerın ait olduğu sanal sistem üzerinde uygulamamızın çalıştığı porttur. Bu portu daha sorna göstereceğim işlemlerle kendi işletim sistemimizdeki porta bind etmeyi öğreneceğiz.</figcaption></figure><h4><strong>CMD</strong></h4>\n<ul>\n<li>Sürekli yukarıda ki gibi containerı başlatırken npm start yapmak güzel değildir. İşte bunun için docker bunun yerine bize CMD keyini vermiş bu komutlarımızı burada aşağıda ki gibi Dockerfile içinde tanımlayabiliriz.</li>\n<li>CMD kodunu sadece bir kere yazabiliriz 2. Bir CMD komutu olursa hangisi en sonda olursa o sadece çalışır.</li>\n</ul>\n<a href=\"https://medium.com/media/eb7d570eb1099a20dc87b39385242e5b/href\">https://medium.com/media/eb7d570eb1099a20dc87b39385242e5b/href</a><ul>\n<li>CMD’leri 2 şekilde tanımlayabiliriz.</li>\n<li>Shell form şeklinde yukarıda ki gibi,</li>\n<li>Execute form şeklinde array içinde string gibi<br>(Benim tavsiyem her zaman execute form yapısında olanı kullanmanızdır.)</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/147/1*HwQm6pvg8uOxto-DdFAWlg.png\"></figure><p><strong>CMD vs RUN</strong></p>\n<ul>\n<li>RUN build-time talimatıdır yani build-time da çalışır.</li>\n<li>CMD ise run-time talimatıdır yani containerımızı çalıştırırken çalışır.</li>\n</ul>\n<h4>ENTRYPOINT</h4>\n<ul><li>CMD ile yaptıkları işlemde, kullanımları da aslında bire bir aynıdır. Yine 2 şekilde tanımlanır. Yani shell form veya execute form şeklinde.</li></ul>\n<a href=\"https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href\">https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href</a><p><strong>ENTRYPOINT vs CMD</strong></p>\n<ul><li>Eğer CMD tanımladıktan sonra aşağıda ki gibi containerı çalıştırırken farklı bir command eklersek bu komut, Dockerfile içindeki CMD deki komutu ezer fakat ENTRYPOINT deki komutu ezemez.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*xE7VrAOqhjN4gt5fL13EPw.png\"></figure><ul><li>Veya illa da ezdireceksek aşağıda ki gibi --entrypoint şeklinde tanımlamamız gerekiyor.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*HGHa6XJOLLjgvB9cI8BsBg.png\"></figure><a href=\"https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href\">https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href</a><h4>LAYERS</h4>\n<ul><li>Yukarıda ki en son bıraktığımız Dockerfilemıza bakarak, Layerlar Dockerfile ile oluşturacağımız imageler içerisinde ki katmanlardır. Docker ilk başta node imagesini alır ve bir layera koyar. Node imagesi ise kendi içinde bir kaç layerdır. Kalan kodlarda ki her bir satırda aslında farklı bir kaç layer oluşturur.</li></ul>\n<h4>docker history imageId/imageName</h4>\n<ul><li>Layerları görmek için aşağıda ki kodu yazıyoruz. Ve burada gmrdüğünüz her satır bir layerdır aslında.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*rUAkGQAtPym-bJOQRZq7Bw.png\"></figure><h4>CACHING</h4>\n<ul>\n<li>Image oluşturulurken ilk başta cache verisi olmadığı için kullanılamaz. Fakat ne zaman dosyalarımızda bir değişiklik olursa ve tekrar build alırsak o zaman bazı layerlar cacheden alınır bazıları ise yeniden oluşturulur. Docker bunu yaparken değişiklik olan kısıma kadar olan tüm heryeri cachelediği veriden alır, kalan kısımları tekrar hesaplayarak yeni build oluşturur.</li>\n<li>Caching yapısını daha iyi görebilmek için ilk önce tüm imagelerimizi siliyoruz. Eğer çalışan bir container varsa imageyi silemeyiz o yüzden önce tüm containerları siliyoruz daha sonra tüm imageleri siliyoruz.</li>\n<li>Ve en son Dockerfilemızı hatırlıyoruz aşağıda ki gibiydi.</li>\n</ul>\n<a href=\"https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href\">https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href</a><ul><li>Şimdi ilk image buildini alıyoruz. Gördüğünüz gibi bazı layerları şimdi ilk defa cacheliyorum zaten başındada CACHED diye yazıyor bunlar. Ve zamanıda görüyorsunuz npm install yapmak 79 saniyemizi almış. Hiç istemeyeceğimiz bir şey.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*WT6xfHQNPh957KjY4Ebc8w.png\"></figure><ul><li>Hiçbir değişiklik yapmadan gelin şimdi v0.0.01 adında yeni bir tag ile yeni bir build alalım. Aşağıda göreceğiniz üzere 1.5 saniye almış en uzun işlem çünkü npm installı tekrar yapmadı ve CACHED olmuş veriyi kullandı hiçbir değişiklik olmadığı için.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*jLrM-UjQuBlloMkvYrXcDw.png\"></figure><ul><li>Daha iyi farkı görmek adına bir tane ünlem işareti ekleyip bir değişiklik yapalım react-app uygulamamız içindeki App.js içine ve sonra gelin v0.0.02 buildinin ne kadar süreceğini gözlemleyelim. Gördüğünüz gibi yine 76 saniye npm install yapıyor. Dosyamızdaki bir karakter değişikliğinden ötürü.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*9osLzbiBcVlOJpPQqLGjIw.png\"></figure><ul><li>Yukarıdaki gibi durumlar için biz ne kadar değişiklik yaparsak yapalım, aşağıdaki gibi kendi yöntemlerimizi geliştirerek bu gibi uzun süren işlemleri her defasından cacheden kullanarak önlememiz gerekmektedir.</li></ul>\n<a href=\"https://medium.com/media/1e6845b4f300379c86324586452d9d79/href\">https://medium.com/media/1e6845b4f300379c86324586452d9d79/href</a><ul>\n<li>Bu durumda biz Dockerfile içinde package.jsonumuzu ilk önce /app dizinine kopyalıyorum ve daha sonra npm install işlemini yapıyorum. Ve bu yüzden docker diğer dosyaları daha almadığı için değişiklik olup olmadığını bilmeyecek ve 3. ve 4. satırdaki COPY ve RUN işlemlerini her defasında cachelediği veriden kullanacak. Tabi package.json içinde bir değişiklik olmazsa.</li>\n<li>Ve şimdi tekrar tüm containerslarımızı ve imagelerimizi silip temizledikten sonra yeniden bir temiz bir build alıyoruz. Terminaldeki ilk buildi görüyorsunuz 92 saniye sürmüş. Daha sonra App.js içine gidip “t” adında ekstra bir karakter daha ekliyorum ve yeni bir image oluşturuyorum v0.0.01 tagi ile. Daha sonra göreceğiniz docker CACHED olmuş verileri kullanarak diğer imageyi sadece 1.2 saniyede oluşturuyor.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*gYePpZSjGUiz_AhrNvCa3Q.png\"></figure><h3>Port Binding (-p)</h3>\n<h4>docker run -p ourOSPort:dockerPort imageId/imageName:tag</h4>\n<ul><li>-p ile çalıştırdığımız containerın portunu kendi makinamızdaki port ile binding yani bağlama işlemlerini yapabiliriz.</li></ul>\n<h4>docker run -p 8000:80 imageId/imageName:tag</h4>\n<ul><li>Yukarıda -p ile containerımızın çalıştığı hosttaki 80 portunu alıyoruz ve bunu bizim OS deki 8000 portuna bağlıyoruz. Burada ki 80 aynı zamanda bizim Dockerfile daki EXPOSE portumuzdur.</li></ul>\n<h3>Attach (-a) ve Detach(-d) Mods</h3>\n<ul><li>Attach mod, imagemizi docker run ile container oluşturup çalıştırdığımızda terminalin çalıştırdığımız imagenin terminalinde durduğu moddur. docker run komutu default olarak attached modda çalışır.</li></ul>\n<h4>docker run -p 8000:80 -d imageId</h4>\n<ul>\n<li>d ile docker run yaparsak containerımızı detach modda başlatırız ve bu şekilde aşağıdaki resimdeki gibi imagenin terminaline düşmeyiz ve halen kendi terminalimizde oluruz.</li>\n<li>Default olarak -d eklemeden bir container çalıştırırsak containerımız, attached mod olarak çalışır.</li>\n</ul>\n<h4>docker attach containerId</h4>\n<ul><li>Eger -d ile detach modda başlatsanız bile daha sornadan <strong>docker</strong> <strong>attach containerId</strong> ile çalışan containerınızı restart atmadan attach moda geçerek imagenizin terminaline bağlanabilirsiniz.</li></ul>\n<h4>docker logs containerId</h4>\n<ul><li>Belirtilen çalışan containerin terminalinin o ana kadar ki loglarını basar.</li></ul>\n<h4>docker logs -f containerId</h4>\n<ul><li>-f ekleyerek loğları terminal izler gibi canlı izleyebiliriz. -f follow anlamındadır.</li></ul>\n<h4>docker exec</h4>\n<ul><li>Çalışan docker containerında komut çalıştırmamızı sağlar. Mesela aşağıda c1 diye identifier ettiğimiz yani isimlendirdiğimiz containerda ls komutunu çalıştırarak imagenin WORKDIR indeki yani app/ klasöründe ki dosyaları görüyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*3Y5HOyw-vbyaxp2KxAtTCQ.png\"></figure><ul><li>Veya istersek aşağıda ki gibi -it ile interactive olarak canlı olarak, çalışan containerın terminaline bağlanıp kod yazabiliriz ve daha sonrada exit ile terminalden çıkabiliriz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*ZhJPDKg2fV6mbIMtj9xSvw.png\"></figure><p><strong>docker run vs docker exec</strong></p>\n<ul><li>Run containerı başlatırken, exec çalışan bir containera baglanır.</li></ul>\n<p><strong>docker run vs docker start</strong></p>\n<ul><li>docker run yeni bir container oluşturarak containerı çalıştırır. Docker start ise sadece daha önce stop edilmiş bir containerı çalıştırır.</li></ul>\n<h3>COPYING FILES BETWEEN HOST AND CONTAINER</h3>\n<ul>\n<li>Aşağıda önce containerlarimızı listeliyoruz.</li>\n<li>Daha sonra çalışan birine interactive oluyoruz ve log.txt adında bir dosya oluşturuyoruz ve exit yaparak container terminalinden çıkıyoruz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*uuNDIO1Ax0edygmr6MBtaQ.png\"></figure><h4>docker cp containerId:/path/fileName.txt ourPath</h4>\n<ul><li>Daha sonra ana makinamızda yani işletim sistemimizdeki terminalde, docker cp yaparak container idmizi verdikten sonra : yaparak pathimizi dosya adıyla birlikte yazıyoruz ve o dosyayı bulup “.” ile bulunduğumuz dizine kopyalamasını söylüyoruz. Gördüğünüz gibi daha sonra ls ile container içinde tanımlanan dosyayı listeleyebiliyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*a-WteNcvctQB5r4Ryxk6dg.png\"></figure><ul><li>Veya istersek ana makinamızda secret.txt adında bir dosya oluştururuz</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*bMuV7qncTkSe-IEHj2tTtQ.png\"></figure><ul><li>ve bunu çalışan containera aşağıda ki gibi atabiliriz.</li></ul>\n<h4><strong>docker cp filename containerId:/path</strong></h4>\n<ul>\n<li>Ve cp yaparak kopyalanacak dosyayı seçeriz daha sonra container id ve pathi aşağıda ki örnekte resimdeki gibi yazarız.</li>\n<li>Daha sorna listelediğimizde gördüğünüz gibi dosyamızın oraya kopyalandığını görebiliriz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*bMqVOWuSesFbU-0JRHdimA.png\"></figure><h3>IMPORTING and EXPORTING IMAGES</h3>\n<ul><li>Bazen imagelerimizi ana makinamıza export etmek yani indirmek veya ana makinamızda indirilmiş imageleri dockera import etmek yani yüklemek isteyebiliriz.</li></ul>\n<h4>SAVE<br>docker image save -o outputFileName imageId/imageName:tag</h4>\n<ul><li>-o ile output alacağımız çıktı dosya ismini belirliyoruz ve daha sonra hangi taglı image olduğunu söylüyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*6Sp8tvmQT2B3tgpSbVkpDw.png\"></figure><ul><li>Ve aldığımız output zipli dosyasının içi aşağıda ki gibi linux sisteminde bir docker image dosyası elde ediyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*oYdmRUcmtKp4oFMMJRP6vA.png\"></figure><h4>LOAD<br>docker image load -i react-app.tar</h4>\n<ul><li>Load ornegini gosterecegimiz icin ilk localdeki imagemizi asagidaki gibi siliyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*JJbAJ1lbQc7uJXyUtGxHIA.png\"></figure><ul>\n<li>Sonra imagemizi load ile aşağıda ki gibi yüklüyoruz.</li>\n<li>-i import demektir.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*4xWzCn__U1Zo4YQ8uLPfjA.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6b3f19013bcf\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<ul>\n<li>Docker bizim containerları hazırlamak için kullandığımız tooldur.</li>\n<li>Docker kullanmamızın nedenlerinden birisi ise, biz kendi projemizi node.js’in belirli spesifik bir sürümü ile örneğin v13 ile yapıp, herhangi bir node.js uygulaması çalıştıran siteye yüklersek orası belki v12 node.js kullandığı için uygulamamız hata verebilir, fakat docker ile uygulamalarımızı standartlaştırarak containerlar oluşturur ve bu containerları docker destekleyen bir sunucuya(AWS gibi…) yüklersek, uygulamalarımız her zaman bizim belirlediğimiz standartlara göre çalışacaktır.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*JXT3zSoRCES-roVv.png\"></figure><h4>Install Docker</h4>\n<ul>\n<li>Önce Hyper-V ve Containers’ı Turn Wiondows feature on/of kısmından aktif ediyoruz.</li>\n<li>Sonra Dockerın sitesite giderek kullandığımız OS’e göre Dockerın kendisini yüklüyoruz.</li>\n</ul>\n<h4>docker … --help</h4>\n<ul><li>Başlamadan öcne bilmemiz gereken en önemli şeylerden birisi de, terminalde çalışırken tüm docker komutlarının detaylarını --help yaparak inceleyebiliriz.</li></ul>\n<p>docker images --help<br>docker image --help<br>docker container --help</p>\n<h3>IMAGES</h3>\n<h4>Dockerfile</h4>\n<ul><li>Her türlü uygulamayı içine sadece <strong>Dockerfile</strong> ekleyerek docker ile bir imageye çeviririz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*9MzAYkVjj5y_eAHBWqqGEg.png\"></figure><ul><li>Image uygulamamız için gerekli olan herşeyi içine alır.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*n32UJqQgigJbaGNaTtd1xg.png\"></figure><ul>\n<li>Ve biz bu imageyi dockera vererek containerla çalıştırmasını isteriz.</li>\n<li>Imagemiz hazır olduktan sonra registirye göndeririz. Burası docker hub yani github gibi bir yerdir herkes kullanabilir. Daha sonra registirydeki bu imagemizi buradan herhangi bir docker çalıştıran makinada uygulamamızı çalıştırabiliriz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*wdB2-ue1pojtL6IxcOLfgw.png\"></figure><ul><li>Ve ayrıca imageler aşağıdakileri de içerir.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*X-aLj6enapzLupfonKbqnA.png\"></figure><h4>.dockerignore</h4>\n<ul><li>Tabi ki de node_modules klasörünü docker imagesine koymak istemeyiz çünkü çok büyük boyutlarda olabilirler bunun içinde .dockerignore dosyası oluşturup içine istemediğimiz dosyaları ve klasörleri yazarız. Aşağıdaki gibi…</li></ul>\n<a href=\"https://medium.com/media/c1245081a5ce0ac679e41b0f0b536c94/href\">https://medium.com/media/c1245081a5ce0ac679e41b0f0b536c94/href</a><h3>CONTAINERS</h3>\n<ul><li>Containerı ise bir piknik sepeti gibi düşünebilirsiniz. Nasıl piknik yapmak için tek ihtiyacımız olan bir piknik sepeti ise, bir projede ihtiyacımız olan her şey bir container içinde olur.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*zdHud-iI8Hk4TpygW9r-OQ.png\"></figure><h4>Images vs Containers</h4>\n<ul>\n<li>Aynı image birden fazla container ile çalışabilir.</li>\n<li>Imageler kendilerine has environment variableslarına sahip olabilirler.</li>\n<li>Imageler uygulamamızı ve kodlarımızı taşır ve onların blueprintsleridir.</li>\n<li>Imagesler read ve only iken containerlar write, read ve execute accesine sahiptirler.</li>\n<li>Imagesler bir layerdır, containerlarda aslında onların parent layerlarıdır diyebiliriz.</li>\n<li>Birbirlerini etkilemeden aynı imageyi farklı bir çok container ile çalıştırabiliriz.</li>\n<li>Containerlar, imageler üzerinde yalıtılmış isolated edilmiş bir yazılım birimidir.</li>\n</ul>\n<h3>DOCKER BASIC EXAMPLE</h3>\n<ul>\n<li>Gelin ilk basit uygulamamızı birlikte dockerize edelim.</li>\n<li>Elimizde aşağıda ki gibi app.js dosyası olan ve log basan bir dosyamız var.</li>\n<li>İlk olarak Dockerfile adında bir dosya oluşturuyoruz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*UB37V5NVASGHuKAxeao-KQ.png\"></figure><ul>\n<li>Daha sonra FROM ile bu imagemizin çalıştıracağı imageyi ayarlıyoruz. app.js’i node.js ile çalıştıracağımız için, node.js’e sahip bir image layerını burada seçmemiz gerekiyor ki Docker bu imageyi alıp bizim çalıştırmasını istediğimiz node.js dosyasını yani app.js’i çalıştırabilsin.</li>\n<li>Ve daha sonra distrubitionu seçiyoruz. Alpine bir linux distrubitiondur. Bizim node imagesini direk kullanmak yerine node:alpine kullanmamızın nedeni, boyutu ve performans açısından direkt olarak node.js imagesinden daha performanslı olmasıdır.</li>\n</ul>\n<a href=\"https://medium.com/media/9246311f1e426c0821a3b2e273ecf5be/href\">https://medium.com/media/9246311f1e426c0821a3b2e273ecf5be/href</a><ul><li>Aşağıda ki resimde dockerhub’da aratarak bulduğum, aynı zamanda yukarıda da FROM ile kullandığımız <strong>node:alpine</strong> gibi bir image görüyorsunuz aslında.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/656/1*AKvtLFVB-c2g3iZwdHlcpQ.png\"></figure><ul>\n<li>Daha sonra COPY diyerek <strong>“.”</strong> ile tüm dosyalari kopyala yapıyoruz ve <strong>“/app”</strong> klasorüne kopyalansın diyoruz.</li>\n<li>Ve daha sonra CMD ile komutu çalıştır diyoruz. İlk önce bunu normalde kendi makinamızda çalıştırsaydık node app.js diyeceğimiz için burada da dockerın node ile calıştırmasını söylüyor ve dosyanın yerini veriyoruz. Kopyaladığımız dosyaları <strong>app </strong>adında bir klasöre atmıştık hatırlarsanız.</li>\n</ul>\n<a href=\"https://medium.com/media/e101c94f260f1e72023c522dfa5a4125/href\">https://medium.com/media/e101c94f260f1e72023c522dfa5a4125/href</a><ul><li>Veya WORKDIR ile bir çalışma yolu belirleyerek daha sonra node app.js de yapabiliriz CMD ile.</li></ul>\n<a href=\"https://medium.com/media/a40d42e0164b5d5818482404bb0f3771/href\">https://medium.com/media/a40d42e0164b5d5818482404bb0f3771/href</a><ul><li>Ver ilk Dockerfile’mızı oluşturduk. Şimdi imagemizi oluşturup çalıştırabiliriz. Fakat bu detaylara daha sonra geleceğim.</li></ul>\n<h3>Dockerfile</h3>\n<ul><li>Dockerfile içinde aşağıdaki alanlar bulunur. Tüm bu kısımları detaylıca birlikte göreceğiz merak etmeyin.</li></ul>\n<p><strong>FROM</strong> specify BASE iamge<br><strong>WORKDIR </strong>Working directory calisma dizini<br><strong>COPY</strong> kopyalamaya yarar<br><strong>ADD</strong> kopyalamya yarar<br><strong>RUN</strong> execute etmeye yarar kodlari<br><strong>ENV </strong>environment variables tanimlariz<br><strong>EXPOSE</strong> dockerin imageyi calistiracagi portu ayarlar<br><strong>USER</strong> uygulamayi calistiracak useri tanimlar<br><strong>CMD </strong>commandin execute edilmesini saglar her acildiginda<br><strong>ENTRYPOINT </strong>commandin execute edilmesini saglar her acildiginda</p>\n<a href=\"https://medium.com/media/5578329504ce2f0de117865059c0108c/href\">https://medium.com/media/5578329504ce2f0de117865059c0108c/href</a><h3>EXAMPLE of CREATE-REACT-APP</h3>\n<ul><li>Yukarıdaki bilgiler ışığında create-react-app ile daha complex bir uygulama oluşturup bunu dockerıze edebiliriz. Ben <strong>create-react-app react-app</strong> yapıyorum.</li></ul>\n<h4>FROM</h4>\n<ul><li>Dockerhub’da bir image buluyoruz FROM da kullanacağımız. Biz react projesini dockerıze edeceğimiz için bir node.js imagesi buluyoruz. Alpine sürümlerinin boyutları az olduğu için onları tercih ediyoruz.</li></ul>\n<a href=\"https://medium.com/media/9f08c2c138f22344dbe5263defffce6e/href\">https://medium.com/media/9f08c2c138f22344dbe5263defffce6e/href</a><ul><li>Terminali açıp Dockerfile’mızın olduğu konuma geliyoruz. Ve aşağıdaki kodları uygulayarak neler yaptığını görüyoruz.</li></ul>\n<h4><strong>docker build .</strong></h4>\n<ul>\n<li>Aslında şimdi Dockerfilemızı build alıp image oluşturarak, <strong>node:14.16.0-alpine3.13</strong> deki linux terminale bağlanabiliriz.</li>\n<li>Burada ki <strong>“.”</strong> ile ise Dockerfile mizin olduğu konumu söyleriz.</li>\n</ul>\n<h4><strong>docker images</strong></h4>\n<ul><li>Makinemizde oluşturduğumuz veya çektiğimiz tüm imageleri gösterir. (Intermediate imageler hariç)</li></ul>\n<h4><strong>docker images -a</strong></h4>\n<ul><li>Tüm imageleri gösterir.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*1vH5_r2FRBn_p6V1xCGSZg.png\"></figure><h4>docker image ls</h4>\n<ul><li>Tüm imageleri listeler. docker images ile aynı işlevi gerçekleştirir bir nevi.</li></ul>\n<h4>docker image prune</h4>\n<ul>\n<li>Kullanılmayan imageleri siler.</li>\n<li>Kullanilmayan imageleri sildikten sonra imageleri listelersek sadece kendi olusturdugumuz ve pull yaptigimiz imageleri goruruz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*XZURxiHLkr3ZRwTfNuK5qA.png\"></figure><h4>docker image prune -a</h4>\n<ul><li>Kullanılsın kullanımlasın tüm imageleri siler.</li></ul>\n<h4>docker rmi imageName:tag/imageId<br>docker image rm imageName:tag/imageId</h4>\n<ul><li>Prune ile silinmeyen yukarıda ki gibi imageleri silmek içinse asağıda ki gibi docker image dedikten sonra remove anlamına gelen rm ve image adınıveya idsini yazariz.<br><em>docker image rm react-app<br>docker image rm df3</em>\n</li></ul>\n<h4><strong>docker ps</strong></h4>\n<ul><li>Çalışan bütün containerları gösterir.</li></ul>\n<h4><strong>docker ps -a</strong></h4>\n<ul><li>Bütün containerları gösterir.</li></ul>\n<h4>docker container ls</h4>\n<ul><li>Tüm containerları listeler. docker ps -a ile aynı işlevi gerçekleştirir bir nevi.</li></ul>\n<h4>docker container prune</h4>\n<ul><li>Kullanılmayan containerları siler.</li></ul>\n<h4>docker rm containerName/containerId<br>docker container rm containerName/containerId</h4>\n<ul><li>prune ile silinmeyen containerları silmek içinse asağıda ki gibi docker container dedikten sonra remove anlamina gelen rm ve container adını veya idsini yazarız.<br><em>docker container rm react-app<br>docker container rm df3</em>\n</li></ul>\n<h4>docker rm -f containerName/containerId<br>docker container -f rm containerName/containerId</h4>\n<ul><li>Çalışan containerları force yaparak önce durdurur sonra siler. Yukarıda ki kodla çalışan containerları silemeyiz.</li></ul>\n<h4>docker stop containerId</h4>\n<ul><li>Bu şekilde de belirli bir container id ye sahip containerin çalışmasını durdururuz.</li></ul>\n<h4>docker start -i containerId</h4>\n<ul>\n<li>Bu şekilde de belirli bir container id ye sahip containerı çalıştırırız. Id’nin ilk 3 karakteri de yeterli olur. Veya id yerine containerName de yazabilirsiniz.</li>\n<li>-i terminal ile interact olmasını sağlar yani terminale bağlnamasını sağlar.</li>\n</ul>\n<h4>exit</h4>\n<ul><li>-it ile interactive bir şekilde başlattığımız containerlar Docker container sessionunu kapatır ve terminalden çıkar. Fakat containerı tamamen silmez bunu bizim yapmamız gerekiyor.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/479/1*RJZMxYXJOM3C99EpmommQQ.png\"></figure><h3>Naming/Tagging Images</h3>\n<ul><li>Developmentda tagsiz kullanmakta sorun yok ama productionda tagging kesinlikle yapmalıyız. Çünkü ileride yeni tagli versiyonda bir sorun çıkarsa eski tagi bilerek tekrar hemen dönebiliriz.</li></ul>\n<h4>docker build -t imageName .</h4>\n<ul><li>Imageleri listelediğimizde eğer imagelere sadece imageName verdiysek latest tagını görürüz default olarak.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*3sWhJ5YCII-qsSkL6pXhQg.png\"></figure><h4>docker build -t imageName:tag .</h4>\n<ul><li>Oluşturacağımız imagelere -t ile tag ekleyerek isimlendirebiliriz.</li></ul>\n<h4>docker build -t react-app:v0.0.01 .</h4>\n<ul><li>Yukarıda oluşturacağımız image için react-app isimlendirmesi yaptık ve tag olarakda <strong>v0.0.01</strong> olsun dedik.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*clxWvbzv5KYLgmCeia34YA.png\"></figure><ul>\n<li>Genel olarak latest tagini her zaman en son versiona sahip olan image olarak tutmalıyız. Ve latest tagindeki imageyi docker ile çalıştırtmalıyız.</li>\n<li>Tagleri hem dockerfile da yada hemde run timeda asagidaki gibi yazabiliriz.</li>\n<li>Tag verirken bir kac cesit tag verme turu vardir.<br>Versiyon numarası ile: docker build react-app:<strong>v0.0.01</strong> .<br>Sıralamalı : docker build react-app:<strong>0</strong> .</li>\n</ul>\n<h4>tag</h4>\n<p><strong>docker image tag imageId/imageName:tag imageId/imageName:tag</strong></p>\n<ul>\n<li>Bu kodla varolan bir imageyi kopyalayarak yeniden yeni bir isim ve tagle yeni bir image oluşturabiliriz. Veya varolan bir imageyi seçerek, başka bir varolan imagenin bu imageye dönüşmesini sağlayabiliriz. Örneğin yukarıdaki kodda ilk imageId ile seçtiğimiz image bizim için bir referans, daha sorna sında seçtiğimiz ise yeni oluşturtmak istediğimiz image olacak. Veya ikinci seçtiğimiz image adında bir image zaten varsa onu alıp bizim ilk seçtiğimiz imageye çevirtiriz.</li>\n<li>tagi kullanmadan önce aşağıda ilk olarak Dockerfile’a WORKDIR /app adında bir satır daha ekleyerek bir değişiklik yapıyorum.</li>\n</ul>\n<a href=\"https://medium.com/media/c6f3897deef779fe6ff646c1ae06d2ae/href\">https://medium.com/media/c6f3897deef779fe6ff646c1ae06d2ae/href</a><ul><li>Sonra build alarak v0.0.02 tagli yeni imagemi oluşturuyorum.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*sD8DocuiAxGUyxaTN7ez9g.png\"></figure><ul><li>Yukarıda göreceğiniz üzere yeni son version imagemin idsi latest versiondan farklı. Bunu düzeltmemiz gerekiyor.</li></ul>\n<p><strong>docker image tag 5af react-app:latest</strong></p>\n<ul><li>Ve aşağıda 5af id si ile başlayan imageyi seçiyoruz ve artık react-app:latest adında bir image yoksa bunu oluşturmasını veya varsa da bu imagenin artık 5af id li image ile aynısı olmasını istiyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*YRRtMWMQy5w5iSbKQYMPFg.png\"></figure><p><strong>docker image tag 5af react-app:v0.0.03</strong></p>\n<ul><li>Veya hiç olmayan bir image adı ve tagiyle yeni bir image kopyası oluşturabilirdik. tabi ben daha sonra bu v0.0.03'ü aşağıda ki kod ile kaldırıyorum.<br>docker image rm react-app:v0.0.03</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*K0OfmNAwOHb_PdktsOjpKQ.png\"></figure><h3>docker run</h3>\n<h4>docker run imageId/imageName</h4>\n<ul><li>Bu kodla oluşturduğumuz imageleri çalıştırabiliriz.</li></ul>\n<h4>docker run react-app<br>docker run react-app:v0.0.01<br>docker run react-app:latest<br>docker run 34870cf3b371<br>docker run 348</h4>\n<ul><li>Yukarıda bir imageyi genel olarak çalıştırabileceğiniz bir birinden farklı şekilde yöntemleri gösterdim. ister image adıyla, ister image adı ve versiyon numarası ile, ister id ile istersenizde idnizin 3 karakteri ile imagelerimizi çalıştırabiliriz.</li></ul>\n<p><strong><em>docker run node</em></strong></p>\n<ul><li>Bu şekilde çalıştırırsak <em>dockerhub </em>dan node imagesinin son güncel imagesini alıp, makinemize kurup, arka planda bir container oluşturup, node imagesini çalıştıracaktır.</li></ul>\n<h4>docker run -it imageId/imageName</h4>\n<ul><li>-it ile interactive diyerekde imagelerimizi çalıştırarak ardından terminale bağlanabiliriz.</li></ul>\n<h4><strong><em>docker run -it node</em></strong></h4>\n<ul>\n<li>Bu şekilde yaparsak -it ile interactive diyeceğimiz için docker node’un son imagesini indirip yeni bir container oluşturup, bu imageyi kullanarak node imagesini interactive olarak çalıştıracak ve terminale bağlanacaktır. Asagidaki gibi.</li>\n<li>Ve aşağıda göreceğiniz üzere node imagesini run yapip -it ile terminale bağlandığım zaman nodeun versionu 15.4.0, benim kendi makinemdeki ise 14.15.4. Yani burda çalışan container aslında bir sanal makine.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*locy2qoV7DhWlOAEcfSizg.png\"></figure><h4><strong>NAMING CONTAINERS<br>docker run -d --name fakeName imageId</strong></h4>\n<ul><li>Aynı containerı farklı bir isim ile çalıştırmak böylelikle aynı containerı aynı anda 2 kere çalıştırabiliyor olacağız.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*O1UYfpxcBvVgIQPKCcLO5Q.png\"></figure><ul><li>Ve şimdi 2 containerımız var bunlardan birisi blue-sky</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*grV8WBxTSgMgauT5zNnlQQ.png\"></figure><h4>docker run --rm imageName</h4>\n<p>· İmagenin çalıştırıldığı container durdurulduğunda, containerın otomatik olarak silinmesini sağlar.</p>\n<h4><strong>docker build -it react-app .</strong></h4>\n<ul><li>Ve şimdi eğer aşağıda ki gibi docker run yapip -it yani interactive şeklinde oluşturduğumuz imagemizi çalıştırırsak sanal docker makinasında çalışan bir node terminalini çalıştırmış olacağız çünkü “FROM”a “node”u vermiştik hatırlıyorsanız.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*QXLeWzudH7ivjnt1wzmK4g.png\"></figure><ul><li>Eğer bu şekilde başlatmayı denersekte hata alırız çünkü alpine linux imagesi bash ile birlikte gelmez, shell ile gelir. O yüzden boyutu azdır.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*9_cb7HDN35WewxTnpoENkg.png\"></figure><ul><li>Fakat sh ile shelli çalıştırsaydık hem linux dosya sistemini görebilirdik hem de node versiyonumuzu görebilirdik çalışan docker makinamızda.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*ifTMOV6osXi4Yis0J0nBVQ.png\"></figure><h4>COPY / ADD - WORKDIR</h4>\n<ul>\n<li>Şimdi uygulama dosyalarımızı imageye kopyalamamız gerekiyor.</li>\n<li>WORKDIR ile çalışma dizinini /app yapıyoruz. Bu şekilde containerımızı çalıştırdığımızda /app dizininde uygulamamız ayarlanıp başlatılacak.</li>\n<li>COPY ile tüm package ile başlayan dosyalar ve README.md dosyasını /app/ klasörüne kopyalıyoruz.</li>\n<li>Veya dilersek 2. COPY deki gibi . ile tüm dosyaları seçerek /app/ klasörüne kopyalayabiliriz.</li>\n<li>Veya . ile tüm dosyaları seçerek ikinci nokta ile de olduğumuz klasçre yani /app/’e kopyalayabiliriz. Buradaki 2. COPY deki birinci . bizim Dockerfilenin bulunduğu dizini, ikinci . ise imagenin WORKDIR’ini temsil eder yani /app/ dizinini.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*JodsZ68wYWwmVMWa9pSu0w.png\"></figure><ul><li>ADD ile ise bir link ekleyebiliriz veya file.zip gibi sıkıştırılmış dosyalariı açarak istediğimiz yere çıkartabiliriz.</li></ul>\n<a href=\"https://medium.com/media/b1b272c8aff4a40430142261d88f0795/href\">https://medium.com/media/b1b272c8aff4a40430142261d88f0795/href</a><h4>RUN</h4>\n<ul>\n<li>Dockerı yukarida ki haliyle çalıştırdığımızda dependenciesler yüklü olmadığı için sorun olacaktır. O yüzden dependenciesleri imagemizi çalıştırdıktan sonra yükletmeliyiz aşağıda ki gibi.</li>\n<li>Aşağıdaki gibi RUN komutuyla npm komutumuzu çalıştırarak gerekli dependenciesleri yükleyebiliriz.</li>\n</ul>\n<a href=\"https://medium.com/media/4ccd389cbde83b34373e3cdacec491ee/href\">https://medium.com/media/4ccd389cbde83b34373e3cdacec491ee/href</a><ul><li>Aşağıdaki gibi 2 tane komut da çalıştırabiliriz fakat apt komutu FORM daki imagemizden gelen alpine surumu linuxde olmadığı için hata alırız.</li></ul>\n<a href=\"https://medium.com/media/9aa58e0a7facb65242ff6be4926e11b0/href\">https://medium.com/media/9aa58e0a7facb65242ff6be4926e11b0/href</a><h4>ENV</h4>\n<ul><li>Environment variableları ise aşağıda ki gibi ya aralarında bir boşluk bırakarak yada = ile tanımlayabiliriz ben = ile tanımlamayı tercih ediyorum.</li></ul>\n<a href=\"https://medium.com/media/28afc9ee0d68bb9b19223e460821de29/href\">https://medium.com/media/28afc9ee0d68bb9b19223e460821de29/href</a><ul><li>Ve daha sorna imagemizi oluşturup containerimızı shellde interactive olarak imagemizi çalıştırdığımız da istersek bu environmentlerı aşağıda ki gibi görebiliriz..</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*RzTwqJbwDXTqm2iywI8_IA.png\"></figure><ul><li>Veya shell ile çalıştırdığımız için istersek yazdırabiliriz de echo yaparak.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/288/1*UhdCNM6LQc_Nv0r4iJY8Uw.png\"></figure><h4>EXPOSE</h4>\n<ul><li>Expose ile port exposing işlemlerimizi yapabiliriz. Dockerda port atadığımızda çalışan port containerda çalışır host üzerinde çalışmaz bunu anlamamız gerekir.</li></ul>\n<a href=\"https://medium.com/media/e364c674b3ed851aad158059c109695a/href\">https://medium.com/media/e364c674b3ed851aad158059c109695a/href</a><ul><li>En son oluşturduğumuz Dockerfile bir üstteki Dockerfile’dır. Gelin bunu build alalım ve <strong>npm start</strong> ile birlikte çalıştıralım ve react-app uygulamamızı çalıştırıp, -it ilede interactive olarak bağlanarak uygulamamızın çalıştığından emin olalım.</li></ul>\n<h4>docker run react:app:latest npm start</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*uqoXu4_XDBaexmKf7RDVyw.png\"></figure><ul><li>Direk npm start komutunu yukarıda ki gibi yazarak run time terminal kodlarımızı burada da çalıştırarak react-app uygulamamızı sanal makinamız üzerinde çalıştırabiliriz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*H_lyDQN_6h5T7Nh7I59KAw.png\"><figcaption>Burada çalışan localhost:3000 kullandığınız sistemdeki 3000 değildir. Bu containerın ait olduğu sanal sistem üzerinde uygulamamızın çalıştığı porttur. Bu portu daha sorna göstereceğim işlemlerle kendi işletim sistemimizdeki porta bind etmeyi öğreneceğiz.</figcaption></figure><h4><strong>CMD</strong></h4>\n<ul>\n<li>Sürekli yukarıda ki gibi containerı başlatırken npm start yapmak güzel değildir. İşte bunun için docker bunun yerine bize CMD keyini vermiş bu komutlarımızı burada aşağıda ki gibi Dockerfile içinde tanımlayabiliriz.</li>\n<li>CMD kodunu sadece bir kere yazabiliriz 2. Bir CMD komutu olursa hangisi en sonda olursa o sadece çalışır.</li>\n</ul>\n<a href=\"https://medium.com/media/eb7d570eb1099a20dc87b39385242e5b/href\">https://medium.com/media/eb7d570eb1099a20dc87b39385242e5b/href</a><ul>\n<li>CMD’leri 2 şekilde tanımlayabiliriz.</li>\n<li>Shell form şeklinde yukarıda ki gibi,</li>\n<li>Execute form şeklinde array içinde string gibi<br>(Benim tavsiyem her zaman execute form yapısında olanı kullanmanızdır.)</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/147/1*HwQm6pvg8uOxto-DdFAWlg.png\"></figure><p><strong>CMD vs RUN</strong></p>\n<ul>\n<li>RUN build-time talimatıdır yani build-time da çalışır.</li>\n<li>CMD ise run-time talimatıdır yani containerımızı çalıştırırken çalışır.</li>\n</ul>\n<h4>ENTRYPOINT</h4>\n<ul><li>CMD ile yaptıkları işlemde, kullanımları da aslında bire bir aynıdır. Yine 2 şekilde tanımlanır. Yani shell form veya execute form şeklinde.</li></ul>\n<a href=\"https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href\">https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href</a><p><strong>ENTRYPOINT vs CMD</strong></p>\n<ul><li>Eğer CMD tanımladıktan sonra aşağıda ki gibi containerı çalıştırırken farklı bir command eklersek bu komut, Dockerfile içindeki CMD deki komutu ezer fakat ENTRYPOINT deki komutu ezemez.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*xE7VrAOqhjN4gt5fL13EPw.png\"></figure><ul><li>Veya illa da ezdireceksek aşağıda ki gibi --entrypoint şeklinde tanımlamamız gerekiyor.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*HGHa6XJOLLjgvB9cI8BsBg.png\"></figure><a href=\"https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href\">https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href</a><h4>LAYERS</h4>\n<ul><li>Yukarıda ki en son bıraktığımız Dockerfilemıza bakarak, Layerlar Dockerfile ile oluşturacağımız imageler içerisinde ki katmanlardır. Docker ilk başta node imagesini alır ve bir layera koyar. Node imagesi ise kendi içinde bir kaç layerdır. Kalan kodlarda ki her bir satırda aslında farklı bir kaç layer oluşturur.</li></ul>\n<h4>docker history imageId/imageName</h4>\n<ul><li>Layerları görmek için aşağıda ki kodu yazıyoruz. Ve burada gmrdüğünüz her satır bir layerdır aslında.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*rUAkGQAtPym-bJOQRZq7Bw.png\"></figure><h4>CACHING</h4>\n<ul>\n<li>Image oluşturulurken ilk başta cache verisi olmadığı için kullanılamaz. Fakat ne zaman dosyalarımızda bir değişiklik olursa ve tekrar build alırsak o zaman bazı layerlar cacheden alınır bazıları ise yeniden oluşturulur. Docker bunu yaparken değişiklik olan kısıma kadar olan tüm heryeri cachelediği veriden alır, kalan kısımları tekrar hesaplayarak yeni build oluşturur.</li>\n<li>Caching yapısını daha iyi görebilmek için ilk önce tüm imagelerimizi siliyoruz. Eğer çalışan bir container varsa imageyi silemeyiz o yüzden önce tüm containerları siliyoruz daha sonra tüm imageleri siliyoruz.</li>\n<li>Ve en son Dockerfilemızı hatırlıyoruz aşağıda ki gibiydi.</li>\n</ul>\n<a href=\"https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href\">https://medium.com/media/f2b0baaa122f978653d309c7cae197ec/href</a><ul><li>Şimdi ilk image buildini alıyoruz. Gördüğünüz gibi bazı layerları şimdi ilk defa cacheliyorum zaten başındada CACHED diye yazıyor bunlar. Ve zamanıda görüyorsunuz npm install yapmak 79 saniyemizi almış. Hiç istemeyeceğimiz bir şey.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*WT6xfHQNPh957KjY4Ebc8w.png\"></figure><ul><li>Hiçbir değişiklik yapmadan gelin şimdi v0.0.01 adında yeni bir tag ile yeni bir build alalım. Aşağıda göreceğiniz üzere 1.5 saniye almış en uzun işlem çünkü npm installı tekrar yapmadı ve CACHED olmuş veriyi kullandı hiçbir değişiklik olmadığı için.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*jLrM-UjQuBlloMkvYrXcDw.png\"></figure><ul><li>Daha iyi farkı görmek adına bir tane ünlem işareti ekleyip bir değişiklik yapalım react-app uygulamamız içindeki App.js içine ve sonra gelin v0.0.02 buildinin ne kadar süreceğini gözlemleyelim. Gördüğünüz gibi yine 76 saniye npm install yapıyor. Dosyamızdaki bir karakter değişikliğinden ötürü.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*9osLzbiBcVlOJpPQqLGjIw.png\"></figure><ul><li>Yukarıdaki gibi durumlar için biz ne kadar değişiklik yaparsak yapalım, aşağıdaki gibi kendi yöntemlerimizi geliştirerek bu gibi uzun süren işlemleri her defasından cacheden kullanarak önlememiz gerekmektedir.</li></ul>\n<a href=\"https://medium.com/media/1e6845b4f300379c86324586452d9d79/href\">https://medium.com/media/1e6845b4f300379c86324586452d9d79/href</a><ul>\n<li>Bu durumda biz Dockerfile içinde package.jsonumuzu ilk önce /app dizinine kopyalıyorum ve daha sonra npm install işlemini yapıyorum. Ve bu yüzden docker diğer dosyaları daha almadığı için değişiklik olup olmadığını bilmeyecek ve 3. ve 4. satırdaki COPY ve RUN işlemlerini her defasında cachelediği veriden kullanacak. Tabi package.json içinde bir değişiklik olmazsa.</li>\n<li>Ve şimdi tekrar tüm containerslarımızı ve imagelerimizi silip temizledikten sonra yeniden bir temiz bir build alıyoruz. Terminaldeki ilk buildi görüyorsunuz 92 saniye sürmüş. Daha sonra App.js içine gidip “t” adında ekstra bir karakter daha ekliyorum ve yeni bir image oluşturuyorum v0.0.01 tagi ile. Daha sonra göreceğiniz docker CACHED olmuş verileri kullanarak diğer imageyi sadece 1.2 saniyede oluşturuyor.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*gYePpZSjGUiz_AhrNvCa3Q.png\"></figure><h3>Port Binding (-p)</h3>\n<h4>docker run -p ourOSPort:dockerPort imageId/imageName:tag</h4>\n<ul><li>-p ile çalıştırdığımız containerın portunu kendi makinamızdaki port ile binding yani bağlama işlemlerini yapabiliriz.</li></ul>\n<h4>docker run -p 8000:80 imageId/imageName:tag</h4>\n<ul><li>Yukarıda -p ile containerımızın çalıştığı hosttaki 80 portunu alıyoruz ve bunu bizim OS deki 8000 portuna bağlıyoruz. Burada ki 80 aynı zamanda bizim Dockerfile daki EXPOSE portumuzdur.</li></ul>\n<h3>Attach (-a) ve Detach(-d) Mods</h3>\n<ul><li>Attach mod, imagemizi docker run ile container oluşturup çalıştırdığımızda terminalin çalıştırdığımız imagenin terminalinde durduğu moddur. docker run komutu default olarak attached modda çalışır.</li></ul>\n<h4>docker run -p 8000:80 -d imageId</h4>\n<ul>\n<li>d ile docker run yaparsak containerımızı detach modda başlatırız ve bu şekilde aşağıdaki resimdeki gibi imagenin terminaline düşmeyiz ve halen kendi terminalimizde oluruz.</li>\n<li>Default olarak -d eklemeden bir container çalıştırırsak containerımız, attached mod olarak çalışır.</li>\n</ul>\n<h4>docker attach containerId</h4>\n<ul><li>Eger -d ile detach modda başlatsanız bile daha sornadan <strong>docker</strong> <strong>attach containerId</strong> ile çalışan containerınızı restart atmadan attach moda geçerek imagenizin terminaline bağlanabilirsiniz.</li></ul>\n<h4>docker logs containerId</h4>\n<ul><li>Belirtilen çalışan containerin terminalinin o ana kadar ki loglarını basar.</li></ul>\n<h4>docker logs -f containerId</h4>\n<ul><li>-f ekleyerek loğları terminal izler gibi canlı izleyebiliriz. -f follow anlamındadır.</li></ul>\n<h4>docker exec</h4>\n<ul><li>Çalışan docker containerında komut çalıştırmamızı sağlar. Mesela aşağıda c1 diye identifier ettiğimiz yani isimlendirdiğimiz containerda ls komutunu çalıştırarak imagenin WORKDIR indeki yani app/ klasöründe ki dosyaları görüyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*3Y5HOyw-vbyaxp2KxAtTCQ.png\"></figure><ul><li>Veya istersek aşağıda ki gibi -it ile interactive olarak canlı olarak, çalışan containerın terminaline bağlanıp kod yazabiliriz ve daha sonrada exit ile terminalden çıkabiliriz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*ZhJPDKg2fV6mbIMtj9xSvw.png\"></figure><p><strong>docker run vs docker exec</strong></p>\n<ul><li>Run containerı başlatırken, exec çalışan bir containera baglanır.</li></ul>\n<p><strong>docker run vs docker start</strong></p>\n<ul><li>docker run yeni bir container oluşturarak containerı çalıştırır. Docker start ise sadece daha önce stop edilmiş bir containerı çalıştırır.</li></ul>\n<h3>COPYING FILES BETWEEN HOST AND CONTAINER</h3>\n<ul>\n<li>Aşağıda önce containerlarimızı listeliyoruz.</li>\n<li>Daha sonra çalışan birine interactive oluyoruz ve log.txt adında bir dosya oluşturuyoruz ve exit yaparak container terminalinden çıkıyoruz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*uuNDIO1Ax0edygmr6MBtaQ.png\"></figure><h4>docker cp containerId:/path/fileName.txt ourPath</h4>\n<ul><li>Daha sonra ana makinamızda yani işletim sistemimizdeki terminalde, docker cp yaparak container idmizi verdikten sonra : yaparak pathimizi dosya adıyla birlikte yazıyoruz ve o dosyayı bulup “.” ile bulunduğumuz dizine kopyalamasını söylüyoruz. Gördüğünüz gibi daha sonra ls ile container içinde tanımlanan dosyayı listeleyebiliyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*a-WteNcvctQB5r4Ryxk6dg.png\"></figure><ul><li>Veya istersek ana makinamızda secret.txt adında bir dosya oluştururuz</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*bMuV7qncTkSe-IEHj2tTtQ.png\"></figure><ul><li>ve bunu çalışan containera aşağıda ki gibi atabiliriz.</li></ul>\n<h4><strong>docker cp filename containerId:/path</strong></h4>\n<ul>\n<li>Ve cp yaparak kopyalanacak dosyayı seçeriz daha sonra container id ve pathi aşağıda ki örnekte resimdeki gibi yazarız.</li>\n<li>Daha sorna listelediğimizde gördüğünüz gibi dosyamızın oraya kopyalandığını görebiliriz.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*bMqVOWuSesFbU-0JRHdimA.png\"></figure><h3>IMPORTING and EXPORTING IMAGES</h3>\n<ul><li>Bazen imagelerimizi ana makinamıza export etmek yani indirmek veya ana makinamızda indirilmiş imageleri dockera import etmek yani yüklemek isteyebiliriz.</li></ul>\n<h4>SAVE<br>docker image save -o outputFileName imageId/imageName:tag</h4>\n<ul><li>-o ile output alacağımız çıktı dosya ismini belirliyoruz ve daha sonra hangi taglı image olduğunu söylüyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*6Sp8tvmQT2B3tgpSbVkpDw.png\"></figure><ul><li>Ve aldığımız output zipli dosyasının içi aşağıda ki gibi linux sisteminde bir docker image dosyası elde ediyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*oYdmRUcmtKp4oFMMJRP6vA.png\"></figure><h4>LOAD<br>docker image load -i react-app.tar</h4>\n<ul><li>Load ornegini gosterecegimiz icin ilk localdeki imagemizi asagidaki gibi siliyoruz.</li></ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*JJbAJ1lbQc7uJXyUtGxHIA.png\"></figure><ul>\n<li>Sonra imagemizi load ile aşağıda ki gibi yüklüyoruz.</li>\n<li>-i import demektir.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*4xWzCn__U1Zo4YQ8uLPfjA.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6b3f19013bcf\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["nodejs", "react", "javascript", "dockerize", "docker"],
    "slug": "6b3f19013bcf"
  }
]
