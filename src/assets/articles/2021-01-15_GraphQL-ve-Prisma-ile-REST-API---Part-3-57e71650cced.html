<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>GraphQL ve Prisma ile REST API — Part 3</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">GraphQL ve Prisma ile REST API — Part 3</h1>
</header>
<section data-field="subtitle" class="p-summary">
RELATION &amp; CUSTOM RESOLVERS (parent)
</section>
<section data-field="body" class="e-content">
<section name="080e" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="eff1" id="eff1" class="graf graf--h3 graf--leading graf--title">GraphQL ve Prisma ile REST API — Part 3</h3><figure name="af89" id="af89" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*Om-WMtACMu2kTPBoOviaiQ.jpeg" data-width="1100" data-height="550" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Om-WMtACMu2kTPBoOviaiQ.jpeg"></figure><p name="69e7" id="69e7" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">RELATION &amp; CUSTOM RESOLVERS (parent)</strong></p><p name="8ede" id="8ede" class="graf graf--p graf-after--p">GraphQL’de datalar arasında ki relation’u Custom resolvers’lar ile sağlarız. Tabi burada işin içine Prisma ve farklı servislesle birlikte kullanımlar girince değişebilir ama şuan ki yapımız da Realation kurmak için bu yöntemi izleyeceğiz. Ve bir önce ki yazımda dediğim gibi parent argumentini burada kullanacağız ve sizde parent’ın nasıl kullanıldığına dair daha iyi bir fikire sahip olmuş olacaksınız.</p><p name="b832" id="b832" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Ne yapacağız?</strong></p><p name="11f0" id="11f0" class="graf graf--p graf-after--p">Tüm postsları almak istediğimizde artık sadece belirli bir user’a ait tüm postsları alacağız veya filtreleyeceğiz. Bunu istersek direk posts querysi içinde postlarda olan author kısmındaki idyi kullanarak yapabiliriz. Ama bunun yerine GraphQL için daha uygun olan Custom resolverslar oluşturarak GraphQL servisimize dahil edeceğiz ve içinde resolverın hangi sorgulamada ne yapacağınız söyleyeceğiz ve kalan herşeyi GraphQL servisi bizim için gerçekleştirecek.</p><p name="7394" id="7394" class="graf graf--p graf-after--p">resolvers klasörü içinde User.js adında bir dosya açıyoruz ve aşağıda ki kodları yazdıktan sonra export ediyoruz.</p><figure name="29ab" id="29ab" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/9a227eeb3c60f13f8da0214b6b056133.js"></script><figcaption class="imageCaption">Burada GraphQL query sorgularında users query sini çalıştırdığımızda bize users içinde o user’a air postlarıda dönüyor olacaktır artık. Ve user içindeki posts’ları sorgularken User’a aıt bu yazdığımız custom Resolver’ı görecek ve içine girip posts larla alakalı bir query varmı ona bakacaktır. Ve burada posts keyini görünce içine girip içeride istenilen şeyi gerçekleştirecektir. Ve burada parent, hangi user sorgulandığında GraphQL servisi buraya giriyorsa, parent o user’ın kendisi olacaktır. O yüzden parent.id diyerek aslında user’ın id sini alıyoruz. Biraz karışık olduğu için daha detaylı bir örnek verecek olursam, diyelim ki mucahidyazar adlı username’e sahıp user’ı query’de user’ı kullanarak sorguluyoruz. GraphQL User’larla ilgili her işlem yaptığında bu custom resolverin içine giriyor. Ve bu custom resolverın içine her girdiğinde parent mucahidyazar oluyor.</figcaption></figure><p name="fdd1" id="fdd1" class="graf graf--p graf-after--figure">Tabi Custom resolver’ın daha çalışması için bunu index.js içinde import edip aşağıda ki gibi resolvers olarak eklememiz gerekiyor. Hatta eklemeden önce sizde benim gibi içi boş da olsa Comment.js ve Post.js adında da 2 tane daha custom resolver oluşturun ve bu şekilde benim gibi aşağıdaki gibi import edip ekleyin.</p><figure name="bc33" id="bc33" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/a0e2f8a2d1498ed61ce62870ad5da7c2.js"></script></figure><p name="4d24" id="4d24" class="graf graf--p graf-after--figure">Ve artık aşağıda ki gibi herhangi bir user ile ilgili sorgu yaptığımızda, ve bu sorguda posts’ları istiyorsak eğer, GraphQL User resolverına girip o user için oradaki gerekli postslarla alakalı bir işlem varmı bakacak ve bize sonuçları o şekilde dönecektir.</p><figure name="53f1" id="53f1" class="graf graf--figure graf--iframe graf-after--p graf--trailing"><script src="https://gist.github.com/mucahidyazar/8adae44517678aced967c4af97c6fe9c.js"></script></figure></div></div></section><section name="1692" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="5b11" id="5b11" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">SUBSCRIPTION</strong></p><p name="6969" id="6969" class="graf graf--p graf-after--p">GraphQL’deki anlaması en güç konulardan bir diğeridir aslında. Fakat mantık olarak WebSocket’ler gibi olduklarını söyleyebiliriz. GraphQL bizim için belirli bir sorguyu izler watch eder ve değişiklik gördüğünde bizim belirlediğimiz şeyleri return eder bize.</p><p name="200e" id="200e" class="graf graf--p graf-after--p">İlk önce subscription yapımızı index.js içerisinde de oluşturalım. Bunun için PubSub’ı import ediyoruz graphql-yoga paketinden. daha önce dediğim gibi graphql-yoga paketi bizim için bir çok işi çok daha kolay hale getirir subscription işlemleride bunlardan birisidir.</p><figure name="e562" id="e562" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/7e0429dbca6f7573bfcd8511f18b2f77.js"></script></figure><p name="8433" id="8433" class="graf graf--p graf-after--figure">daha sonra pubsub adında bir değişken oluşturup import ettiğimiz bu PubSub ile new PubSub oluşturuyoruz.</p><figure name="2287" id="2287" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/d599e6f844d5766d824c90008ebb60a8.js"></script></figure><p name="bd16" id="bd16" class="graf graf--p graf-after--figure">ve index.js içinde en son olarak da aşağıdaki gibi GraphQLServer içinde context’e bu pubsub’ı gönderiyoruz. Subscription.js içinde buna erişebilmek için.</p><figure name="97cb" id="97cb" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/3c70315f5fe89a046d8ba82b44b02d0f.js"></script><figcaption class="imageCaption">Ve son olarak bütün index.js dosyamızın içerisi böyle oluyor GraphQL serimizde.</figcaption></figure><p name="0249" id="0249" class="graf graf--p graf-after--figure">Ve schema.graphql dosyamizda asagidaki gibi type Subscription ‘i olusturuyoruz.Ve bunun icinde de kullanmak icin bir geri donen subscription item i olusturuyoruz count gibi. İstersek buradaki count() icinde argumentde kullanabiliriz ama burada gerekmiyor.</p><figure name="0144" id="0144" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/c0a78708e56bd3d1b45fe516f9fc4765.js"></script></figure><p name="f4d6" id="f4d6" class="graf graf--p graf-after--figure">daha sonra resolvers içinde daha önce oluşturduğumuz Subscription.js dosyasına gelip aşağıdakileri ekliyoruz içine count subscriptionu için.</p><figure name="b96d" id="b96d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/0b32a05d18137aaabd3535d7838b7579.js"></script><figcaption class="imageCaption">Burada adım adım ne ne için anlatmaya çalıştım kod satırı içinde siz silebilirsiniz isterseniz.</figcaption></figure><p name="d6ce" id="d6ce" class="graf graf--p graf-after--figure">Ve şimdi graphql playgroundumuzu açıp aşağıda ki gibi bir subscription sorgusu yaptığımızda saniyede bir artan countu saniyelik olarak takip ettiğimiz bir subscription oluşturmuş olacağız.</p><figure name="ffde" id="ffde" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/ab0f085b0bfd31a9b503f79faf3ec1e8.js"></script></figure><p name="fb5f" id="fb5f" class="graf graf--p graf-after--figure">Subscriptionların hava kalmasını istemiyorum. Gelin bir başka örnek yapalım ve bu daha bir gerçek hayat projelerine uygun bir örnek olsun. Peki ne yapıyoruz. Oluşturulan silinen ve güncellenen her postu dinlediğimiz bir subscription oluşturalım.</p><p name="3e98" id="3e98" class="graf graf--p graf-after--p">Ilk once tekrardan schema.graphql’e aşağıdakileri ekliyoruz.</p><figure name="eaf2" id="eaf2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/4b899c475889f1ed37bee7e021af89f9.js"></script></figure><p name="d279" id="d279" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Enum</strong></p><p name="a624" id="a624" class="graf graf--p graf-after--p">Yukarıda farkedeceğiniz üzere enum oluşturup MutationType yaptık bu enumun adını. Ve dinleyeceğimiz post subscriptionunun bu enumu atadığımız PostSubscriptionPayload döneceğini söyledik. enumu ise bunun içerisindeki mutation için atadık. Yani dönecek PostSubscriptionPayload ın mutation’u bu enumun içerisindeki 3 değerden birisinin string halinde dönmesi gerektiğini söyler. Bu 3 değer harici hiçbirşeyi dönderemeyiz PostSubscriptionPayload içindeki mutation için. (Kısa bir bilgi enumlar arka tarafta çalışırken ilk sıradaki CREATED aslında 1 olarak bilinerek hafızada tutulur. Konumuzun dışına çıkmaya gerek yok şuan çok önemli değil bizim için.)</p><p name="0529" id="0529" class="graf graf--p graf-after--p">Post için subscriptionumuzu schema.graphql içinde oluşturduğumuza göre gelelim Subscription resolverı içinde yapmamız gereken işleme. Aşağıdaki gibi resolversdaki Subscription.js içine gelip post adında subscriptionumuzu oluşturuyoruz. ve contextden aldığımız pubsub ile asyncIterator metodunu çalıştırıp post adında bir kanal oluşturuyoruz. Artık tek yapmamız gereken mutationlarımızda postlarımızı CREATE UPDATE ve DELETE yaptığımız yerlerde bu kanallara bağlanıp PostSubscriptionPayload typeında bir değer dönmek.</p><figure name="deb9" id="deb9" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/728c55d921029034dc860ae94720662c.js"></script></figure><p name="f3f0" id="f3f0" class="graf graf--p graf-after--figure">Öncelikle ben CREATED işlemini ayrıntılı olarak açıklayacağım UPDATED ve DELETED’de aynı mantıkla olacağı için onları açıklamayacağım. Kaynak kodlarını paylaşacağım repoda bularak onlarıda inceleyebilirsiniz.</p><figure name="6b14" id="6b14" class="graf graf--figure graf--iframe graf-after--p graf--trailing"><script src="https://gist.github.com/mucahidyazar/55dcadcf2d484263a3a71add1cf766bd.js"></script><figcaption class="imageCaption">Eğer oluşturulan post publish edilmiş ise context’den gelen pubsub u kullanarak oluşturdugumuz kanala bağlanıyoruz ve subscripitionda döneceğimiz type da değimizi dönüyoruz örnekte ki gibi.</figcaption></figure></div></div></section><section name="972e" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="e6db" id="e6db" class="graf graf--p graf--leading graf--trailing">Ve evet GraphQL serimizin burada sonuna gelmiş bulunmaktayız. Genel olarak en önemli gördüğüm özellikleri burada size anlatmaya çalıştım. Umarım sizler için güzel bir bilgi kaynağı ve hafıza tazeleme olmuştur. Bundan sonra ki kısımda oluşturduğumuz bu yapıyı Prisma ile bağlama kısmına değinmek istiyorum. Sizler bu yapıyı daha fazla geliştirerek daha fazla pratik yapabilirsiniz ki bunu tavsiye ederim. Prisma kısmı ile biraz daha karmaşık bir yapıya dönüşüyor aslında. Ve şimdiler de Prisma 2 de çıkmış durumda bizim kuracağımız GraphQL yapısı Prisma 1 ile olacak. Ama sizler tabiki Prisma ile bunu yapmak zorunda değilsinizde isterseniz bu örnekte gönderdiğimiz db yerinden mongo db bağlantınızı göndererek GraphQL ve MongoDB yide bir birine bağlayabilir Authentication ve CRUD işlemlerinizi rahatlıkla yapabilirsiniz. Bir sonra ki yazımda görüşmek üzere hoşçakalın ve sağlıkla kalın diliyorum.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mucahidyazar" class="p-author h-card">Mucahid Yazar</a> on <a href="https://medium.com/p/57e71650cced"><time class="dt-published" datetime="2021-01-15T06:02:53.880Z">January 15, 2021</time></a>.</p><p><a href="https://medium.com/@mucahidyazar/graphql-ve-prisma-ile-rest-api-part-3-57e71650cced" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 24, 2022.</p></footer></article></body></html>