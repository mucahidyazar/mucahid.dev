<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>React Hooks: The Hard Parts</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">React Hooks: The Hard Parts</h1>
</header>
<section data-field="subtitle" class="p-summary">
Bu yazımda React’ın anlaması güç kısımlarından, parçalarından bazı kısımları sizlere anlatacağım. Konularımız:
</section>
<section data-field="body" class="e-content">
<section name="e6f4" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8c34" id="8c34" class="graf graf--h3 graf--leading graf--title">React Hooks: The Hard Parts</h3><figure name="3750" id="3750" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*7BpRVozLZlUv2UKT" data-width="750" data-height="375" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*7BpRVozLZlUv2UKT"></figure><p name="a147" id="a147" class="graf graf--p graf-after--figure">Bu yazımda React’ın anlaması güç kısımlarından, parçalarından bazı kısımları sizlere anlatacağım. Konularımız:</p><ul class="postList"><li name="5edb" id="5edb" class="graf graf--li graf-after--p">useCallback</li><li name="acda" id="acda" class="graf graf--li graf-after--li">useMemo</li><li name="c211" id="c211" class="graf graf--li graf-after--li">useRef</li><li name="2a7e" id="2a7e" class="graf graf--li graf-after--li">useLayoutEffect</li><li name="b5bd" id="b5bd" class="graf graf--li graf-after--li">React.memo</li></ul><h3 name="25bf" id="25bf" class="graf graf--h3 graf-after--li">useCallback</h3><p name="dc1f" id="dc1f" class="graf graf--p graf-after--h3">React öğrenirken öğrenmesi en zor hookslardan birisi useCallback idi. Ne yapacağını umarım size düzgünce anlatabilirim.</p><p name="a3a2" id="a3a2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">useCallback </strong>ne yapardan önce size aşağıda size basit bir <strong class="markup--strong markup--p-strong">App.js</strong> göstermek istiyorum.</p><figure name="41ec" id="41ec" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/5b6025a7103e4a894ee10f6d5514f17e.js"></script></figure><p name="b576" id="b576" class="graf graf--p graf-after--figure">Yukarıda ki componentda <strong class="markup--strong markup--p-strong">handleClick’e </strong>her tıklandığın da <strong class="markup--strong markup--p-strong">age </strong>artar ve props olarak verildiği <strong class="markup--strong markup--p-strong">&lt;Age /&gt;</strong> componentında “Today I am xx Years of Age” metni güncellenir. Ve <strong class="markup--strong markup--p-strong">age </strong>her değiştiğinde <strong class="markup--strong markup--p-strong">&lt;App /&gt;</strong>, <strong class="markup--strong markup--p-strong">&lt;Age /&gt;</strong> ve <strong class="markup--strong markup--p-strong">&lt;Instructions /&gt;</strong> componentı yenilenir. <strong class="markup--strong markup--p-strong">&lt;Instructions /&gt;</strong>componentını <strong class="markup--strong markup--p-strong">React.memo</strong> ile kullandığımız halde <strong class="markup--strong markup--p-strong">age </strong>her güncellendiğinde props’u memo tarafından memorize edilmiş olmasına rağmen tekrar render edilir.</p><h4 name="7c83" id="7c83" class="graf graf--h4 graf-after--p">Peki niye?</h4><p name="1c65" id="1c65" class="graf graf--p graf-after--h4">Javascriptte her obje bellekte bir referans değerine sahiptir. Örnek veriyorum biz bir Obje veya Array veya bir fonksiyon oluşturduğumuzda bunların hepsi bellekte bir referans değerleri ile tutuluyorlar.</p><p name="a5f4" id="a5f4" class="graf graf--p graf-after--p">Yukarıda ki <strong class="markup--strong markup--p-strong">age</strong> statesi ile hiçbir allakası olmayan <strong class="markup--strong markup--p-strong">React.memo</strong> ile memorize edilmiş <strong class="markup--strong markup--p-strong">&lt;Instructions /&gt; </strong>componentinin render edilme sebebi de, yukarıda bahsettiğim referans değeri her renderda değişen <strong class="markup--strong markup--p-strong">doSomething </strong>fonksiyonudur. <strong class="markup--strong markup--p-strong">age </strong>statesi her arttığında <strong class="markup--strong markup--p-strong">&lt;App /&gt;</strong> yeniden render edilir ve <strong class="markup--strong markup--p-strong">doSomething </strong>yeni bir referans koduna sahip bir fonksiyon olarak yeniden oluşur. Ve yeni referans koduna sahip bu props <strong class="markup--strong markup--p-strong">&lt;Instructions /&gt;</strong> componentına atandığında <strong class="markup--strong markup--p-strong">React.memo</strong> yeni bir props atandığını düşünerek tekrar <strong class="markup--strong markup--p-strong">&lt;Instructions /&gt;</strong> componentinin yeniden render edilmesini sağlar.</p><h4 name="e4c9" id="e4c9" class="graf graf--h4 graf-after--p">Peki <strong class="markup--strong markup--h4-strong">useCallback </strong>ne yapar?</h4><ul class="postList"><li name="4c03" id="4c03" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">useCallaback </strong>2 argument alır. <strong class="markup--strong markup--li-strong">Birincisi </strong>memorize edeceği <strong class="markup--strong markup--li-strong">fonksiyon</strong>, <strong class="markup--strong markup--li-strong">ikincisi </strong>hangi değerler değiştiğinde bu fonksiyonun yeniden oluşturulacağını belirten bir <strong class="markup--strong markup--li-strong">array</strong>. Bu array içinde, hangi değerler olarak bahsettiğim değerleri arrayin bir elemanı olarak vereceksiniz.</li><li name="7a19" id="7a19" class="graf graf--li graf-after--li">Örnek olarak aşağıda yukarıda ki örnekten giderek <strong class="markup--strong markup--li-strong">doSomething </strong>fonksiyonunu <strong class="markup--strong markup--li-strong">useCallback </strong>ile <strong class="markup--strong markup--li-strong">memorize </strong>ediyoruz. 2. argument olarakda <strong class="markup--strong markup--li-strong">someValue</strong>’yu veriyoruz. Buradaki <strong class="markup--strong markup--li-strong">someValue </strong>state’de olan bir değer olabilirdi veya bu componente pushlanmış bir propsda olabilirdi. Ve ne zaman bu <strong class="markup--strong markup--li-strong">someValue </strong>değişirse <strong class="markup--strong markup--li-strong">useCallback</strong>, memoryde yeni bir referans koduna sahip <strong class="markup--strong markup--li-strong">doSomething </strong>fonksiyonu oluşturur. Ve <strong class="markup--strong markup--li-strong">&lt;Instructions /&gt;</strong> componenti o zaman yeniden render edilir. Eğer <strong class="markup--strong markup--li-strong">someValue </strong>değişmez ise <strong class="markup--strong markup--li-strong">age </strong>statesinin değişip <strong class="markup--strong markup--li-strong">&lt;App /&gt;</strong>’i rerender etmesi hiçbir zaman <strong class="markup--strong markup--li-strong">useCallback </strong>içinde ki <strong class="markup--strong markup--li-strong">doSomething </strong>fonksiyonunu yeniden yeniden oluşturtamaz. Ve <strong class="markup--strong markup--li-strong">doSomethıng </strong>her seferınde yeniden oluşmadığı için <strong class="markup--strong markup--li-strong">&lt;Insturctions /&gt;</strong> componenti tekrar tekrar render edilmez. İşte <strong class="markup--strong markup--li-strong">useCallback </strong>bize bu avantajı sağlar.</li></ul><figure name="0b1e" id="0b1e" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/78fc490a0333bc5ba51704b64749a141.js"></script></figure><ul class="postList"><li name="aefd" id="aefd" class="graf graf--li graf-after--figure">Yukarıda ki örneği birde aşağıda ki kaynaktan incelemenizi tavsiye ederim.</li></ul><h3 name="e7ab" id="e7ab" class="graf graf--h3 graf-after--li">useMemo</h3><ul class="postList"><li name="4f4f" id="4f4f" class="graf graf--li graf-after--h3">Bir fonksiyondan dönen objectleri memorize eder. useCallback memorize edilmiş fonksiyon return ederken useMemo memorize edilmiş object return döner bize.</li><li name="31ba" id="31ba" class="graf graf--li graf-after--li">Kullanım şekli: const memoizedValue = useMemo(functionThatReturnsValue, arrayDepencies)</li><li name="c91f" id="c91f" class="graf graf--li graf-after--li"><a href="https://reactjs.org/docs/hooks-reference.html#usememo" data-href="https://reactjs.org/docs/hooks-reference.html#usememo" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Documentation</a></li></ul><p name="721c" id="721c" class="graf graf--p graf-after--li">Aşağıda useMemo kullanmadığımız basit bir yapımız var. Bir inputumuz var ve inputa birşeyler yazdığımızda text statesi değişecek ve App komple render edilecektir. Ve App her render edildiğinde List ve içindeki ListItem componentleride rerender yani yeniden render edilecektir.</p><figure name="bc01" id="bc01" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/40a97cc97beb8806d7f86df7f4ccea9d.js"></script></figure><h4 name="aefb" id="aefb" class="graf graf--h4 graf-after--figure">Peki useMemo ne yapar?</h4><ul class="postList"><li name="cdc2" id="cdc2" class="graf graf--li graf-after--h4">useMemo işte burada inputa birşey yazdığımız da App rerender oluyor ama List ve ListItem hiçbir şey değişmemesine rağmen niye yeniden rerender ediliyor, onun çözümünü bize sağlıyor.</li><li name="86d8" id="86d8" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">useMemo </strong>içine 2 argument alır. <strong class="markup--strong markup--li-strong">Birincisi </strong>bir object veya array return eden bir fonksiyon, <strong class="markup--strong markup--li-strong">ikincisi </strong>hangi değerler değiştiğinde bu return edilecek objectin yeniden hesaplanıp ve oluşturulacağını belirten bir <strong class="markup--strong markup--li-strong">array</strong>.</li><li name="afc5" id="afc5" class="graf graf--li graf-after--li">Aslında yukarıda ki örneğe eklememiz gereken tek şey aşağıda ki gibi useMemo ile filteredUser değişkenimizdeki değeri useMemo ile sarmaktır. Dependencies olarakda search veriyoruz çünkü inputa değerler girildikten sonra butona tıklanıp ne zaman aranmak istenirse o zaman, filteredUsers’ın tekrar hesaplanıp oluşturulmasını ve List ve ListItem’ın o tekrar yeniden hesaplanma sonrası oluşturulmasını istiyoruz.</li></ul><figure name="885a" id="885a" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/40a97cc97beb8806d7f86df7f4ccea9d.js"></script></figure><ul class="postList"><li name="1e6f" id="1e6f" class="graf graf--li graf-after--figure">Aşağıda ise useMemo örneği için tüm kod örneğini bırakıyorum.</li></ul><figure name="9c79" id="9c79" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/40a97cc97beb8806d7f86df7f4ccea9d.js"></script></figure><h3 name="54ee" id="54ee" class="graf graf--h3 graf-after--figure">useRef</h3><ul class="postList"><li name="e912" id="e912" class="graf graf--li graf-after--h3">state ile en büyük farklarından birisi state değiştiğin de sayfa rerender edilir fakat useRef de bu olmaz.</li><li name="d9c2" id="d9c2" class="graf graf--li graf-after--li">useRef içine argument olarak initial bir value tanımlarız ve bu initial value’yi .current ile yakalarız.</li></ul><figure name="3ed3" id="3ed3" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/b3b5e8304c4bd574a3126ca9dc25ae37.js"></script><figcaption class="imageCaption">Burada butona tıkladığımızda inputa focus olduğumuz bir örnek görüyoruz.</figcaption></figure><ul class="postList"><li name="000f" id="000f" class="graf graf--li graf-after--figure">Aşağıda bir mesaj penceresinde durmandan gelen mesajların penceresinin useRef ile kontrol edilerek, pencerenin yeni mesajlar geldikçe sürekli aşağı otomatikmen scroll olmasını sağladığımız bir yapı kuruyoruz.</li><li name="be25" id="be25" class="graf graf--li graf-after--li">Aşağıda mesajların olduğu dive ref vererek divi seçiyoruz bir nevi. Daha sonra bu ref’in current yani şimdiki scrollTop değerini alıyoruz ve şimdi ki scrollHeight değerine eşitliyoruz. Böylece her yeni mesajda scrollumuz otomatikmen aşağıya kayacaktır.</li></ul><figure name="e593" id="e593" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/bae7b8b104937d1326875765797e05d2.js"></script></figure><h3 name="e335" id="e335" class="graf graf--h3 graf-after--figure">useLayoutEffect</h3><ul class="postList"><li name="3e32" id="3e32" class="graf graf--li graf-after--h3">useEffect ile kullanımı aynıdır.</li><li name="2b7b" id="2b7b" class="graf graf--li graf-after--li">Örnek kullanımı: useLayoutEffect(effectFunction, arrayDependencies)</li><li name="5451" id="5451" class="graf graf--li graf-after--li"><a href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" data-href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Documentation</a></li></ul><figure name="bd5f" id="bd5f" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*se_HM4rIijdYQwHJ" data-width="1600" data-height="1600" src="https://cdn-images-1.medium.com/max/800/0*se_HM4rIijdYQwHJ"></figure><h4 name="5ab9" id="5ab9" class="graf graf--h4 graf-after--figure">useEffect vs useLayoutEffect</h4><ul class="postList"><li name="6504" id="6504" class="graf graf--li graf-after--h4">Aralarında ki en büyük fark useEffect render bittikten sonra çalışırken, useLayouteffect render bitmeden çalışır. Tabi çoğu durumda renderdan sonra işlerin yapılmasını istediğimiz için genellikle useEffect kullanımı yeterli olur.</li><li name="5105" id="5105" class="graf graf--li graf-after--li">Ama bazı durumlarda useeffectle yaptığımız bazı çalışmalar bize side effektler doğurur. Bu side effektleri kullanıcının görmemesi için useLayoutEffect ile render işleminden önce useLayoutEffect ile çalıştırır ve kullanabiliriz.</li></ul><figure name="95f5" id="95f5" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/d60eb3da6a4bfb1a63d8edf12e3fb1ec.js"></script></figure><h3 name="e368" id="e368" class="graf graf--h3 graf-after--figure"><strong class="markup--strong markup--h3-strong">React.memo()</strong></h3><ul class="postList"><li name="a704" id="a704" class="graf graf--li graf-after--h3">Bir componenti wrap eden yani saran HOC(Higher Order Component)’dır.</li><li name="ab91" id="ab91" class="graf graf--li graf-after--li">Görevi componentda olan propsları memorize eder ve bu componentdeki propslar değişmediği sürece, wrap ettiği componentin rerender edilmemesini sağlar.</li></ul><figure name="dd6f" id="dd6f" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/c37c89fcc8438db91b1e55935d762065.js"></script></figure><ul class="postList"><li name="3eb9" id="3eb9" class="graf graf--li graf-after--figure">Yukarıda ki componentda one ve two propsu değişmediği sürece Counts componenti asla rerender olmayacaktır. one ve two propslarını number dönen bir props olarak düşünebilirsiniz.</li></ul><h3 name="e9c0" id="e9c0" class="graf graf--h3 graf-after--li">Yardımcı Kaynaklar</h3><div name="3a5c" id="3a5c" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://react-hooks-cheatsheet.com/" data-href="https://react-hooks-cheatsheet.com/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://react-hooks-cheatsheet.com/"><strong class="markup--strong markup--mixtapeEmbed-strong">React Hooks Cheatsheets</strong><br><em class="markup--em markup--mixtapeEmbed-em">A cheatsheet with live editable examples 💪</em>react-hooks-cheatsheet.com</a><a href="https://react-hooks-cheatsheet.com/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="443137d1ed358214468a409aa49ba761" data-thumbnail-img-id="0*LxemkLtyF5ZfxcpN" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*LxemkLtyF5ZfxcpN);"></a></div><div name="fe54" id="fe54" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://tr.reactjs.org/docs/hooks-reference.html" data-href="https://tr.reactjs.org/docs/hooks-reference.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://tr.reactjs.org/docs/hooks-reference.html"><strong class="markup--strong markup--mixtapeEmbed-strong">Hook&#39;ların API Kaynağı - React</strong><br><em class="markup--em markup--mixtapeEmbed-em">Hook&#39;lar React 16.8&#39;deki yeni bir eklentidir. Bir sınıf yazmadan state ve diğer React özelliklerini kullanmanıza olanak…</em>tr.reactjs.org</a><a href="https://tr.reactjs.org/docs/hooks-reference.html" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="db5f4b3fd56de15765be034032b8ee77" data-thumbnail-img-id="0*Cp4eiPfOvhRjqbR4" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Cp4eiPfOvhRjqbR4);"></a></div><div name="32de" id="32de" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://tsafaelmali.medium.com/react-memoization-nedir-reactta-nas%C4%B1l-kullan%C4%B1l%C4%B1r-453035a3630f" data-href="https://tsafaelmali.medium.com/react-memoization-nedir-reactta-nas%C4%B1l-kullan%C4%B1l%C4%B1r-453035a3630f" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://tsafaelmali.medium.com/react-memoization-nedir-reactta-nas%C4%B1l-kullan%C4%B1l%C4%B1r-453035a3630f"><strong class="markup--strong markup--mixtapeEmbed-strong">React — Memoization Nedir ? React’ta Nasıl Kullanılır ?</strong><br><em class="markup--em markup--mixtapeEmbed-em">Merhaba arkadaşlar bugün sizlere React’ta optimizasyonu arttırmak için kullanılan React.memo, useMemo ve useCallback…</em>tsafaelmali.medium.com</a><a href="https://tsafaelmali.medium.com/react-memoization-nedir-reactta-nas%C4%B1l-kullan%C4%B1l%C4%B1r-453035a3630f" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="0fa0f77e118f94aea6813ac71f2508e3" data-thumbnail-img-id="1*dsDGP0ZaFt6L-oM8izMhLQ.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*dsDGP0ZaFt6L-oM8izMhLQ.png);"></a></div><div name="a0b0" id="a0b0" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://aykutkardas.medium.com/react-memo-usememo-ve-usecallback-nedir-31ccbdcb76c6" data-href="https://aykutkardas.medium.com/react-memo-usememo-ve-usecallback-nedir-31ccbdcb76c6" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://aykutkardas.medium.com/react-memo-usememo-ve-usecallback-nedir-31ccbdcb76c6"><strong class="markup--strong markup--mixtapeEmbed-strong">React.memo, useMemo ve useCallback Nedir?</strong><br><em class="markup--em markup--mixtapeEmbed-em">Bu özellikleri açıklamaya başlamadan önce Memoization ne olduğundan bahsetmekte yarar var.</em>aykutkardas.medium.com</a><a href="https://aykutkardas.medium.com/react-memo-usememo-ve-usecallback-nedir-31ccbdcb76c6" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="2d26ce4f16e08d526df1f3eefae568e2" data-thumbnail-img-id="0*Z7jYalOM-lJ3IvLA" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Z7jYalOM-lJ3IvLA);"></a></div><div name="530b" id="530b" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://blog.hackages.io/react-hooks-usecallback-and-usememo-8d5bb2b67231" data-href="https://blog.hackages.io/react-hooks-usecallback-and-usememo-8d5bb2b67231" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://blog.hackages.io/react-hooks-usecallback-and-usememo-8d5bb2b67231"><strong class="markup--strong markup--mixtapeEmbed-strong">React Hooks: useCallback and useMemo</strong><br><em class="markup--em markup--mixtapeEmbed-em">In this blog post, I will introduce the React Hooks ‘useCallback’ and ‘useMemo’. These Hooks prevent unnecessary…</em>blog.hackages.io</a><a href="https://blog.hackages.io/react-hooks-usecallback-and-usememo-8d5bb2b67231" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="e13d59a0f1f1dcabdbab3835bc359662" data-thumbnail-img-id="1*2wDZ1mo7_MHr2Qr2iZCNHg.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*2wDZ1mo7_MHr2Qr2iZCNHg.png);"></a></div><div name="3a1e" id="3a1e" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://www.robinwieruch.de/react-usememo-hook" data-href="https://www.robinwieruch.de/react-usememo-hook" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.robinwieruch.de/react-usememo-hook"><strong class="markup--strong markup--mixtapeEmbed-strong">How to useMemo in React - RWieruch</strong><br><em class="markup--em markup--mixtapeEmbed-em">React&#39;s useMemo Hook can be used to optimize the computation costs of your React function components. We will go…</em>www.robinwieruch.de</a><a href="https://www.robinwieruch.de/react-usememo-hook" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="06aabbbfcefd0c35db6f1d4b0e59ed7d" data-thumbnail-img-id="0*g6wKCKs5fL--YCSe" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*g6wKCKs5fL--YCSe);"></a></div><div name="dcda" id="dcda" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a href="https://blog.logrocket.com/useeffect-vs-uselayouteffect/" data-href="https://blog.logrocket.com/useeffect-vs-uselayouteffect/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://blog.logrocket.com/useeffect-vs-uselayouteffect/"><strong class="markup--strong markup--mixtapeEmbed-strong">useEffect vs. useLayoutEffect in plain, approachable language - LogRocket Blog</strong><br><em class="markup--em markup--mixtapeEmbed-em">Before you dismiss this as another &quot;basic&quot; React article, I suggest you slow down for a bit. Assuming you really…</em>blog.logrocket.com</a><a href="https://blog.logrocket.com/useeffect-vs-uselayouteffect/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="42662b9e7aade041775af768a366fedf" data-thumbnail-img-id="0*wTlKU4fpuLsVIaYh" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*wTlKU4fpuLsVIaYh);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mucahidyazar" class="p-author h-card">Mucahid Yazar</a> on <a href="https://medium.com/p/8f563b9c0b80"><time class="dt-published" datetime="2021-05-21T07:03:18.528Z">May 21, 2021</time></a>.</p><p><a href="https://medium.com/@mucahidyazar/react-hooks-the-hard-parts-8f563b9c0b80" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 24, 2022.</p></footer></article></body></html>