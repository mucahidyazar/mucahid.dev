<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>React Query — You do not need a Global State Manager</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">React Query — You do not need a Global State Manager</h1>
</header>
<section data-field="subtitle" class="p-summary">
Today I won’t give you something that you can’t find in the documentation of @tanstack/react-query. So you can find more detail on the…
</section>
<section data-field="body" class="e-content">
<section name="df6e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="35fb" id="35fb" class="graf graf--h3 graf--leading graf--title">React Query — You do not need a Global State Manager</h3><figure name="df50" id="df50" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*dnFeqbKCI3OlAKjLNb4Gqg.png" data-width="1920" data-height="1080" src="https://cdn-images-1.medium.com/max/800/1*dnFeqbKCI3OlAKjLNb4Gqg.png"></figure><p name="395d" id="395d" class="graf graf--p graf-after--figure">Today I won’t give you something that you can’t find in the documentation of <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query. So you can find more detail on the documentation. I’ll give you most use cases with examples and some of my experience with <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query.</p><p name="7025" id="7025" class="graf graf--p graf-after--p">What is React Query in a nutshell?</p><ul class="postList"><li name="9613" id="9613" class="graf graf--li graf-after--p">2 hooks + 1 utility</li><li name="31f5" id="31f5" class="graf graf--li graf-after--li">5 kb</li><li name="0713" id="0713" class="graf graf--li graf-after--li">ready-to-use</li><li name="162c" id="162c" class="graf graf--li graf-after--li">highly configurable</li></ul><p name="92d7" id="92d7" class="graf graf--p graf-after--li">You can use <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query and your global state management together. And with <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query you can fetch, cache, and update data in your React and React Native applications all without touching any “global state”. So time to replace some of your state management logic with <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query.</p><p name="c2dc" id="c2dc" class="graf graf--p graf-after--p">Why should you use <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query in your project?</p><ul class="postList"><li name="cbe0" id="cbe0" class="graf graf--li graf-after--p">You can’t mess it up. Yes if you use global state management and you don’t have enough experiences in react you can easily knot your project. But with react-query, you can’t do that even if you want it :)</li><li name="68e5" id="68e5" class="graf graf--li graf-after--li">It gives us the power of best practices of fetching with its own states, (like isLoading, isError, error, etc…)</li><li name="d6d8" id="d6d8" class="graf graf--li graf-after--li">Powerful cache and stale system.</li><li name="0063" id="0063" class="graf graf--li graf-after--li">Provide shorter codes. So at the end of the day, you will delete lots of line codes in your codebase.</li></ul><p name="99ce" id="99ce" class="graf graf--p graf-after--li">I wanna show my notes on react-query. So let’s look at some key use cases.</p><h3 name="f73e" id="f73e" class="graf graf--h3 graf-after--p">Installation</h3><pre name="8e51" id="8e51" class="graf graf--pre graf-after--h3"><code class="markup--code markup--pre-code">yarn add @tanstack/react-query @tanstack/react-query/devtools axios</code></pre><h3 name="5866" id="5866" class="graf graf--h3 graf-after--pre">Setup</h3><ul class="postList"><li name="d583" id="d583" class="graf graf--li graf-after--h3">I will go with a next app. And you can also use a free API. (<a href="https://apilist.fun/" data-href="https://apilist.fun/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">apilist.fun</a>)</li><li name="5e64" id="5e64" class="graf graf--li graf-after--li">You should import QueryClientProvider, and QueryClient to your main App file and wrap your component with QueryClientProvider like below.</li><li name="332c" id="332c" class="graf graf--li graf-after--li">Then you should create a queryClient with QueryClient like below and you should give this queryClient to QueryClientProvider.</li><li name="e333" id="e333" class="graf graf--li graf-after--li">And to see dev tools we should import ReactQueryDevtools and write it inside the QueryClientProvider. And set it in a position to see it.</li></ul><pre name="e3ae" id="e3ae" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">import &#39;../styles/globals.css&#39;<br>import type {AppProps} from &#39;next/app&#39;<br>import {QueryClientProvider, QueryClient} from &#39;@tanstack/react-query&#39;<br>import {ReactQueryDevtools} from &#39;@tanstack/react-query/devtools&#39;</code></pre><pre name="2180" id="2180" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function MyApp({Component, pageProps}: AppProps) {<br>  const queryClient = new QueryClient()</code></pre><pre name="26a5" id="26a5" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;QueryClientProvider {...pageProps} client={queryClient}&gt;<br>      &lt;Component {...pageProps} /&gt;<br>      &lt;ReactQueryDevtools initialIsOpen={false} position=&quot;bottom-right&quot; /&gt;<br>    &lt;/QueryClientProvider&gt;<br>  )<br>}<br>export default MyApp</code></pre><h3 name="c3ba" id="c3ba" class="graf graf--h3 graf-after--pre">APIs</h3><h3 name="9c59" id="9c59" class="graf graf--h3 graf-after--h3">useQuery</h3><h3 name="7490" id="7490" class="graf graf--h3 graf-after--h3">Basic Fetch</h3><p name="66ec" id="66ec" class="graf graf--p graf-after--h3">We can use useQuery hook to fetch datas like below. it will return us lots of things. Like data, isLoading, error.</p><pre name="b73f" id="b73f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQuery} from &#39;@tanstack/react-query&#39;<br>import Link from &#39;next/link&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="e7dc" id="e7dc" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const Home: NextPage = () =&gt; {<br>  const {data, isLoading, error} = useQuery(<br>    [&#39;users&#39;,]<br>    async () =&gt; {<br>      return await axios.get(&#39;http://localhost:4000/users&#39;)<br>    },<br>  )</code></pre><pre name="13bf" id="13bf" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>      &lt;div&gt;<br>        {isLoading &amp;&amp; &lt;&gt;Loading...&lt;/&gt;}<br>        {error &amp;&amp; &lt;&gt;Error: {error.message}&lt;/&gt;}<br>        {data?.data.map(item =&gt; (<br>          &lt;p key={item.id}&gt;{item.name}&lt;/p&gt;<br>        ))}<br>      &lt;/div&gt;<br>  )<br>}</code></pre><pre name="7719" id="7719" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default Home</code></pre><h3 name="c6e4" id="c6e4" class="graf graf--h3 graf-after--pre">Advanced Fetch</h3><h4 name="c00a" id="c00a" class="graf graf--h4 graf-after--h3">isFetching</h4><p name="5c7d" id="5c7d" class="graf graf--p graf-after--h4">You can see the fetching moment by isFetching like below.</p><h4 name="5d29" id="5d29" class="graf graf--h4 graf-after--p">refetch</h4><p name="3140" id="3140" class="graf graf--p graf-after--h4">Or you can refetch with your action. You can give this utility to a onClick or anything that you want to trigger by.</p><pre name="5831" id="5831" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQuery} from &#39;@tanstack/react-query&#39;<br>import Link from &#39;next/link&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="084b" id="084b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const Home: NextPage = () =&gt; {<br>  const {data, isLoading, error, isFetching, refetch} = useQuery(<br>    [&#39;users&#39;],<br>    async () =&gt; {<br>      return await axios.get(&#39;http://localhost:4000/users&#39;)<br>    }<br>  )</code></pre><pre name="eec4" id="eec4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;nav&gt;<br>        &lt;Link href={`/`}&gt;Home&lt;/Link&gt;<br>        &lt;Link href={`/users`}&gt;Users&lt;/Link&gt;<br>        &lt;Link href={`/users-rq`}&gt;Users-RQ&lt;/Link&gt;<br>        &lt;Link href={`/users-rq-ssr`}&gt;Users-RQ-SSR&lt;/Link&gt;<br>      &lt;/nav&gt;</code></pre><pre name="c98d" id="c98d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      &lt;div&gt;<br>        {isLoading &amp;&amp; &lt;&gt;Loading...&lt;/&gt;}<br>        {isFetching &amp;&amp; &lt;&gt;Fetching...&lt;/&gt;}<br>        {error &amp;&amp; &lt;&gt;Error: {error.message}&lt;/&gt;}<br>        {data?.data.map(item =&gt; (<br>          &lt;p key={item.id}&gt;{item.name}&lt;/p&gt;<br>        ))}<br>        &lt;button onClick={refetch}&gt;Fetch Users&lt;/button&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="2170" id="2170" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default Home</code></pre><h4 name="5f9e" id="5f9e" class="graf graf--h4 graf-after--pre">Info About Times</h4><p name="8ae4" id="8ae4" class="graf graf--p graf-after--h4">1000 =&gt; 1 second 5000 =&gt; 5 seconds 5000000 =&gt; 5 minutes</p><h4 name="3d20" id="3d20" class="graf graf--h4 graf-after--p">cacheTime</h4><p name="0005" id="0005" class="graf graf--p graf-after--h4">default =&gt; 5000000 / 5 minutes It will cache the data for 5 seconds if you write 5000 like me.</p><h4 name="2e80" id="2e80" class="graf graf--h4 graf-after--p">staleTime</h4><p name="4b4f" id="4b4f" class="graf graf--p graf-after--h4">default =&gt; 0 / 0 seconds Your data that you fetch will be stale data after 4 seconds</p><h4 name="8994" id="8994" class="graf graf--h4 graf-after--p">refetchOnMount</h4><p name="97d7" id="97d7" class="graf graf--p graf-after--h4">default =&gt; true other options =&gt; “always” | false</p><h4 name="180b" id="180b" class="graf graf--h4 graf-after--p">refetchOnWindowFocus</h4><p name="cc5c" id="cc5c" class="graf graf--p graf-after--h4">default =&gt; true other options =&gt; “always” | false Focus = We are doing something outside of the browser or outside of our app tab then we are returning to our app tab. This will fetch the data again if you focus your app again. For example, if you open another app or another tab then if you come back to your app page, it will fetch the data again.</p><pre name="1d72" id="1d72" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQuery} from &#39;@tanstack/react-query&#39;<br>import Link from &#39;next/link&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="1da0" id="1da0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const Home: NextPage = () =&gt; {<br>  const {data, isLoading, error, isFetching, refetch} = useQuery(<br>    [&#39;users&#39;],<br>    async () =&gt; {<br>      return await axios.get(&#39;http://localhost:4000/users&#39;)<br>    },<br>    {<br>      cacheTime: 5000,<br>      staleTime: 4000,<br>      refetchOnMount: true,<br>      refetchOnWindowFocus: true<br>    },<br>  )</code></pre><pre name="a1c0" id="a1c0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;nav&gt;<br>        &lt;Link href={`/`}&gt;Home&lt;/Link&gt;<br>        &lt;Link href={`/users`}&gt;Users&lt;/Link&gt;<br>        &lt;Link href={`/users-rq`}&gt;Users-RQ&lt;/Link&gt;<br>        &lt;Link href={`/users-rq-ssr`}&gt;Users-RQ-SSR&lt;/Link&gt;<br>      &lt;/nav&gt;</code></pre><pre name="1770" id="1770" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      &lt;div&gt;<br>        {isLoading &amp;&amp; &lt;&gt;Loading...&lt;/&gt;}<br>        {isFetching &amp;&amp; &lt;&gt;Fetching...&lt;/&gt;}<br>        {error &amp;&amp; &lt;&gt;Error: {error.message}&lt;/&gt;}<br>        {data?.data.map(item =&gt; (<br>          &lt;p key={item.id}&gt;{item.name}&lt;/p&gt;<br>        ))}<br>        &lt;button onClick={refetch}&gt;Fetch Users&lt;/button&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="555f" id="555f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default Home</code></pre><h4 name="0aad" id="0aad" class="graf graf--h4 graf-after--pre">refetchOnWindowFocus and staleTime</h4><pre name="5415" id="5415" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">staleTime: 10000,<br>refetchOnWindowFocus: true,</code></pre><p name="0767" id="0767" class="graf graf--p graf-after--pre">If we use this together and if the data is not stale, we will not fetch data again, even if we pass <code class="markup--code markup--p-code">refetchOnWindowFocus: true</code>. <em class="markup--em markup--p-em">refetchOnWindowFocus</em> will fetch if your data is a staled data.</p><p name="bdd7" id="bdd7" class="graf graf--p graf-after--p">Of course you can get over this problem if you need. Just pass “always” as value. like below…</p><pre name="e485" id="e485" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">staleTime: 10000,<br>refetchOnWindowFocus: &quot;always&quot;,</code></pre><h4 name="e925" id="e925" class="graf graf--h4 graf-after--pre">refetchInterval (Polling)</h4><p name="5319" id="5319" class="graf graf--p graf-after--h4">default =&gt; false This will fetch data on every timespan which you wrote below.</p><h4 name="e9bd" id="e9bd" class="graf graf--h4 graf-after--p">refetchIntervalInBackground</h4><p name="5e5f" id="5e5f" class="graf graf--p graf-after--h4">default =&gt; false This will fetch data even if your focus is not on your app tab or browser either</p><pre name="da8c" id="da8c" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQuery} from &#39;@tanstack/react-query&#39;<br>import Link from &#39;next/link&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="ae01" id="ae01" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const Home: NextPage = () =&gt; {<br>  const {data, isLoading, error, isFetching, refetch} = useQuery(<br>    [&#39;users&#39;],<br>    async () =&gt; {<br>      return await axios.get(&#39;http://localhost:4000/users&#39;)<br>    },<br>    {<br>      refetchInterval: 2000,<br>      refetchIntervalInBackground: true,<br>    },<br>  )</code></pre><pre name="1407" id="1407" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;nav&gt;<br>        &lt;Link href={`/`}&gt;Home&lt;/Link&gt;<br>        &lt;Link href={`/users`}&gt;Users&lt;/Link&gt;<br>        &lt;Link href={`/users-rq`}&gt;Users-RQ&lt;/Link&gt;<br>        &lt;Link href={`/users-rq-ssr`}&gt;Users-RQ-SSR&lt;/Link&gt;<br>      &lt;/nav&gt;</code></pre><pre name="b3ba" id="b3ba" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      &lt;div&gt;<br>        {isLoading &amp;&amp; &lt;&gt;Loading...&lt;/&gt;}<br>        {isFetching &amp;&amp; &lt;&gt;Fetching...&lt;/&gt;}<br>        {error &amp;&amp; &lt;&gt;Error: {error.message}&lt;/&gt;}<br>        {data?.data.map(item =&gt; (<br>          &lt;p key={item.id}&gt;{item.name}&lt;/p&gt;<br>        ))}<br>        &lt;button onClick={refetch}&gt;Fetch Users&lt;/button&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="eb87" id="eb87" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default Home</code></pre><h4 name="e29b" id="e29b" class="graf graf--h4 graf-after--pre">onSuccess &amp; onError</h4><p name="f394" id="f394" class="graf graf--p graf-after--h4">You can pass a callback function for onSuccess and onError. Also if the fetching is successful you will get the data if it has an error you will get the error.</p><h4 name="15ad" id="15ad" class="graf graf--h4 graf-after--p">select</h4><p name="5d18" id="5d18" class="graf graf--p graf-after--h4">You can use select to modify your return data. As you see below before I was using data.data.map but after select, I can use just data.map</p><pre name="1a6c" id="1a6c" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQuery} from &#39;@tanstack/react-query&#39;<br>import Link from &#39;next/link&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="30b5" id="30b5" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const Home: NextPage = () =&gt; {<br>  const onSuccess = data =&gt; {<br>    console.log(&quot;You&#39;ve got data: &quot;, data)<br>  }</code></pre><pre name="2474" id="2474" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const onError = error =&gt; {<br>    console.log(&quot;You&#39;ve got an error: &quot;, error)<br>  }</code></pre><pre name="667f" id="667f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const {data, isLoading, error, isFetching, refetch} = useQuery(<br>    [&#39;users&#39;],<br>    async () =&gt; {<br>      return await axios.get(&#39;http://localhost:4000/users&#39;)<br>    },<br>    {<br>      onSuccess,<br>      onError,<br>      select: data =&gt; data.data,<br>    },<br>  )</code></pre><pre name="a6b7" id="a6b7" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;nav&gt;<br>        &lt;Link href={`/`}&gt;Home&lt;/Link&gt;<br>        &lt;Link href={`/users`}&gt;Users&lt;/Link&gt;<br>        &lt;Link href={`/users-rq`}&gt;Users-RQ&lt;/Link&gt;<br>        &lt;Link href={`/users-rq-ssr`}&gt;Users-RQ-SSR&lt;/Link&gt;<br>      &lt;/nav&gt;</code></pre><pre name="6fb9" id="6fb9" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      &lt;div&gt;<br>        {isLoading &amp;&amp; &lt;&gt;Loading...&lt;/&gt;}<br>        {isFetching &amp;&amp; &lt;&gt;Fetching...&lt;/&gt;}<br>        {error &amp;&amp; &lt;&gt;Error: {error.message}&lt;/&gt;}<br>        {/* before select =&gt; {data?.data.map(item =&gt; ( */}<br>        {data?.map(item =&gt; (<br>          &lt;p key={item.id}&gt;{item.name}&lt;/p&gt;<br>        ))}<br>        &lt;button onClick={refetch}&gt;Fetch Users&lt;/button&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="d3fd" id="d3fd" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default Home</code></pre><h4 name="ceab" id="ceab" class="graf graf--h4 graf-after--pre">Multiple Places with the Same useQuery</h4><p name="8046" id="8046" class="graf graf--p graf-after--h4">If you need to use the same useQuery multiple components or multiple pages, you can create a utility with the same useQuery logic and you can use it anywhere you want.</p><p name="4d1d" id="4d1d" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">/hooks/useUsersData.js</em></p><pre name="83f2" id="83f2" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import {useQuery} from &#39;@tanstack/react-query&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="7ade" id="7ade" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export const useUsersData = ({config}) =&gt; {<br>  return useQuery(<br>    [&#39;users&#39;],<br>    async () =&gt; {<br>      return await axios.get(&#39;http://localhost:4000/users&#39;)<br>    },<br>    {<br>      ...config,<br>    },<br>  )<br>}</code></pre><p name="892e" id="892e" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">/pages/xxx.js</em></p><pre name="06fb" id="06fb" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import Link from &#39;next/link&#39;<br>import {useUsersData} from &#39;../../src/hooks&#39;</code></pre><pre name="9c8b" id="9c8b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const Home: NextPage = () =&gt; {<br>  const onSuccess = data =&gt; {<br>    console.log(&quot;You&#39;ve got data: &quot;, data)<br>  }</code></pre><pre name="e1ef" id="e1ef" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const onError = error =&gt; {<br>    console.log(&quot;You&#39;ve got an error: &quot;, error)<br>  }</code></pre><pre name="743f" id="743f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const {data, isLoading, error, isFetching, refetch} = useUsersData({<br>    onSuccess,<br>    onError,<br>    select: data =&gt; data.data,<br>  })</code></pre><pre name="c9e1" id="c9e1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;nav&gt;<br>        &lt;Link href={`/`}&gt;Home&lt;/Link&gt;<br>        &lt;Link href={`/users`}&gt;Users&lt;/Link&gt;<br>        &lt;Link href={`/users-rq`}&gt;Users-RQ&lt;/Link&gt;<br>        &lt;Link href={`/users-rq-ssr`}&gt;Users-RQ-SSR&lt;/Link&gt;<br>      &lt;/nav&gt;</code></pre><pre name="69ac" id="69ac" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      &lt;div&gt;<br>        {isLoading &amp;&amp; &lt;&gt;Loading...&lt;/&gt;}<br>        {isFetching &amp;&amp; &lt;&gt;Fetching...&lt;/&gt;}<br>        {error &amp;&amp; &lt;&gt;Error: {error.message}&lt;/&gt;}<br>        {/* before select =&gt; {data?.data.map(item =&gt; ( */}<br>        {data?.map(item =&gt; (<br>          &lt;p key={item.id}&gt;{item.name}&lt;/p&gt;<br>        ))}<br>        &lt;button onClick={refetch}&gt;Fetch Users&lt;/button&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="c949" id="c949" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default Home</code></pre><h4 name="54cb" id="54cb" class="graf graf--h4 graf-after--pre">How useQuery cache in Dynamic Pages like /users/1, /users/2</h4><p name="386d" id="386d" class="graf graf--p graf-after--h4">As you know when we create [id].js file in next js for dynamic pages. It is similar in pure react too. So the page is the same file. So how can useQuery understand the previous cache is from /1 or /2. We will see how <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query handle this with useQuery.</p><p name="5e04" id="5e04" class="graf graf--p graf-after--p">First let’s create a dynamic page under the /users <em class="markup--em markup--p-em">/pages/users/[id].js</em></p><pre name="c8d2" id="c8d2" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQuery} from &#39;@tanstack/react-query&#39;<br>import Link from &#39;next/link&#39;<br>import axios from &#39;axios&#39;<br>import {useUsersData} from &#39;../../src/hooks&#39;<br>import {useRouter} from &#39;next/router&#39;</code></pre><pre name="3c2e" id="3c2e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const Users: NextPage = () =&gt; {<br>  const router = useRouter()</code></pre><pre name="a094" id="a094" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const {id} = router.query</code></pre><pre name="0835" id="0835" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const {data, isLoading, error} = useUsersData(id, {<br>    select: data =&gt; data.data,<br>  })</code></pre><pre name="4c11" id="4c11" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;nav&gt;<br>        &lt;Link href={`/`}&gt;Home&lt;/Link&gt;<br>        &lt;Link href={`/users`}&gt;Users&lt;/Link&gt;<br>        &lt;Link href={`/users-rq`}&gt;Users-RQ&lt;/Link&gt;<br>        &lt;Link href={`/users-rq-ssr`}&gt;Users-RQ-SSR&lt;/Link&gt;<br>      &lt;/nav&gt;</code></pre><pre name="a3a3" id="a3a3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      &lt;div&gt;<br>        {isLoading &amp;&amp; &lt;&gt;Loading...&lt;/&gt;}<br>        {error &amp;&amp; &lt;&gt;Error: {error.message}&lt;/&gt;}<br>        &lt;div&gt;Id: {id}&lt;/div&gt;<br>        &lt;div&gt;Name: {data?.name}&lt;/div&gt;<br>        &lt;div&gt;Alter Ego: {data?.alterEgo}&lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="0407" id="0407" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default Users</code></pre><p name="0808" id="0808" class="graf graf--p graf-after--pre">Now let’s create our useQuery hooks. As you see below we pass an array as its first argument. one is ‘users’ the second one is a dynamic value. In this way, <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query understands cache correctly. If we don’t do this and if we pass just ‘users’ instead of an array, then when we open /users/1 <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query will cache this, then when we open /users/2, <a href="https://twitter.com/tanstack" data-href="https://twitter.com/tanstack" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">@tanstack</a>/react-query will show use the cache of /users/1. So it is an unwanted side-effect that we don’t want. So we can handle it like below.</p><pre name="ba56" id="ba56" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import {useQuery} from &#39;@tanstack/react-query&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="7ad1" id="7ad1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export const useUsersData = (userId, config) =&gt; {<br>  return useQuery(<br>    [&#39;users&#39;, userId],<br>    async () =&gt; {<br>      return await axios.get(`http://localhost:4000/users/${userId}`)<br>    },<br>    {<br>      ...config,<br>    },<br>  )<br>}</code></pre><p name="a524" id="a524" class="graf graf--p graf-after--pre">Or we can handle it like below with queryKey.</p><pre name="98d3" id="98d3" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const fetchUsers = async ({queryKey}) =&gt; {<br>  // queryKey === [&#39;users&#39;, userId]<br>  const userId = queryKey[1]</code></pre><pre name="bf64" id="bf64" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return await axios.get(`http://localhost:4000/users/${userId}`)<br>}</code></pre><pre name="be77" id="be77" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export const useUsersDataWithQueryKey = (userId, config) =&gt; {<br>  return useQuery([&#39;users&#39;, userId], fetchUsers, {<br>    ...config,<br>  })<br>}</code></pre><h4 name="a442" id="a442" class="graf graf--h4 graf-after--pre">Dynamic Multiple Requests</h4><p name="c6e7" id="c6e7" class="graf graf--p graf-after--h4">Or we can fetch multiple requests as dynamic. Ex: with props like below</p><pre name="3ed1" id="3ed1" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQueries} from &#39;@tanstack/react-query&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="8b98" id="8b98" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const fetchUser = async (id: string) =&gt; {<br>  return await axios.get(`http://localhost:4000/users/${id}`)<br>}</code></pre><pre name="7ce0" id="7ce0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const DynamicParallelQueries: NextPage = ({userIds = [1, 3]}) =&gt; {<br>  const [{data: userOne}, {data: userThree}] = useQueries(<br>    userIds.map(id =&gt; ({<br>      queryKey: [&#39;user&#39;, id],<br>      queryFn: async () =&gt; fetchUser(id),<br>    })),<br>  )</code></pre><pre name="bea8" id="bea8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>      &lt;div&gt;<br>        &lt;p&gt;Users&lt;/p&gt;<br>        &lt;p&gt;UserOne Name: {userOne?.data.username}&lt;/p&gt;<br>        &lt;p&gt;UserThree Name: {userThree?.data.username}&lt;/p&gt;<br>      &lt;/div&gt;<br>  )<br>}</code></pre><pre name="fd1f" id="fd1f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default DynamicParallelQueries</code></pre><h4 name="02a3" id="02a3" class="graf graf--h4 graf-after--pre">Dependent Query Fetching</h4><p name="5a3a" id="5a3a" class="graf graf--p graf-after--h4">As you can see below we can fetch dependent query fetching together. We can wait request with useQuery thanks to enabled.</p><pre name="c31f" id="c31f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQuery} from &#39;@tanstack/react-query&#39;<br>import Link from &#39;next/link&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="38ec" id="38ec" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const fetchUserByEmail = async (email: string) =&gt; {<br>  return await axios.get(`http://localhost:4000/users/${email}`)<br>}</code></pre><pre name="1159" id="1159" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const fetchCoursesByEmail = async () =&gt; {<br>  return await axios.get(`http://localhost:4000/courses`)<br>}</code></pre><pre name="12e9" id="12e9" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const DependentQueries: NextPage = ({email = &#39;mucahidyazar@gmail.com&#39;}) =&gt; {<br>  const {data: userData} = useQuery([&#39;user&#39;, email], () =&gt;<br>    fetchUserByEmail(email),<br>  )<br>  const user = userData?.data<br>  const userId = user?.id</code></pre><pre name="6869" id="6869" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const {data: coursesData} = useQuery(<br>    [&#39;courses&#39;, userId],<br>    () =&gt; fetchCoursesByEmail(),<br>    {<br>      enabled: !!userId,<br>      select: data =&gt;<br>        data?.data?.filter(course =&gt; course.author === user?.username),<br>    },<br>  )<br><br></code></pre><pre name="5f1a" id="5f1a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        &lt;p&gt;User Id: {userId}&lt;/p&gt;<br>        {email}</code></pre><pre name="14ec" id="14ec" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">        &lt;p&gt;Courses&lt;/p&gt;<br>        {coursesData?.map(item =&gt; (<br>          &lt;div key={item.id}&gt;<br>            &lt;p&gt;Author: {item.id}&lt;/p&gt;<br>            &lt;p&gt;{item.title}&lt;/p&gt;<br>          &lt;/div&gt;<br>        ))}<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="6462" id="6462" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default DependentQueries</code></pre><h4 name="425f" id="425f" class="graf graf--h4 graf-after--pre">useQueryClient().getQueryData &amp; initialData</h4><p name="4d93" id="4d93" class="graf graf--p graf-after--h4">useQueryClient =&gt; we can create a query client with useQueryClient hook. And we can use its getQueryData to get the data that it fetched before. initialData =&gt; we can use initialData key to return an initial value with useQuery hooks.</p><p name="8c54" id="8c54" class="graf graf--p graf-after--p">In this example, we send a request to get all users before this request below which is “users”. Then we click one of the users to see its detail and we send another useQuery with “user” key. But we don’t want to see loading, we want to see data instead of that. Then we can use “getQueryData” of queryClient. like below.</p><pre name="34c3" id="34c3" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import {useQuery, useQueryClient} from &#39;@tanstack/react-query&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="85d7" id="85d7" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export const useUserData = (userId, config) =&gt; {<br>  const queryClient = useQueryClient()</code></pre><pre name="b409" id="b409" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return useQuery(<br>    [&#39;user&#39;, userId],<br>    async () =&gt; {<br>      return await axios.get(`http://localhost:4000/users/${userId}`)<br>    },<br>    {<br>      ...config,<br>      initialData: () =&gt; {<br>        const user = queryClient<br>          .getQueryData(&#39;users&#39;)<br>          ?.data?.find(item =&gt; item.id == userId)</code></pre><pre name="4ad1" id="4ad1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">        if (user) {<br>          return {<br>            data: user,<br>          }<br>        } else {<br>          return undefined<br>        }<br>      },<br>    },<br>  )<br>}</code></pre><h4 name="2dd4" id="2dd4" class="graf graf--h4 graf-after--pre">Pagination &amp; keepPreviousData and Avoiding Layout Shift</h4><p name="5795" id="5795" class="graf graf--p graf-after--h4">Pagination is as simple as below. We just keep a state to know page number and increment and decrement it. I wrote hardcoded it but you can get it from your database dynamically.</p><h4 name="1255" id="1255" class="graf graf--h4 graf-after--p">keepPreviousData</h4><p name="e3a6" id="e3a6" class="graf graf--p graf-after--h4">default =&gt; false we can use “keepPreviousData” key using old data. We can avoid layout shifting thanks to “keepPreviousData”. We just need to turn on “keepPreviousData” to true. And by this way, we will keep and show previous data until we fetch the new data on the page. For example below we fetch the first page and we show 3 colors on 1. page. But when we click next we will still show the first page items until we fetch the items of the 2. page.</p><pre name="a8c1" id="a8c1" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useQuery} from &#39;@tanstack/react-query&#39;<br>import axios from &#39;axios&#39;<br>import {useState} from &#39;react&#39;</code></pre><pre name="5dd0" id="5dd0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const PaginatedQueries: NextPage = () =&gt; {<br>  const [page, setPage] = useState(1)<br>  const {data, isLoading, isError, error} = useQuery(<br>    [&#39;colors&#39;, page],<br>    async () =&gt; {<br>      return await axios.get(<br>        `http://localhost:4000/colors?_limit=3&amp;_page=${page}`,<br>      )<br>    },<br>    {<br>      keepPreviousData: true,<br>    },<br>  )</code></pre><pre name="b79e" id="b79e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  if (isLoading) {<br>    return &lt;&gt;Loading...&lt;/&gt;<br>  }<br>  if (isError) {<br>    return &lt;&gt;Error: {error?.message}&lt;/&gt;<br>  }</code></pre><pre name="17ab" id="17ab" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;p&gt;Colors&lt;/p&gt;<br>      {data?.data.map(item =&gt; (<br>        &lt;p key={item.id}&gt;{item.label}&lt;/p&gt;<br>      ))}<br>      &lt;button onClick={() =&gt; setPage(prev =&gt; prev - 1)} disabled={page &lt; 2}&gt;<br>        Prev<br>      &lt;/button&gt;<br>      &lt;button onClick={() =&gt; setPage(prev =&gt; prev + 1)} disabled={page &gt; 2}&gt;<br>        Next<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="8e4f" id="8e4f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default PaginatedQueries</code></pre><h4 name="6c21" id="6c21" class="graf graf--h4 graf-after--pre">useInfiniteQuery &amp; hasNextPage &amp; fetchNextPage</h4><p name="f5a2" id="f5a2" class="graf graf--p graf-after--h4">useInfiniteQuery =&gt; We can use “useInfiniteQuery” to implement and fetch infinite loading to our page. fetchNextPage =&gt; When we use this hook we can also use “fetchNextPage” to trigger the load more button. hasNextPage =&gt; “hasNextPage” will give us that we have a next page or not. We will return its return with “getNextPageParam” option.</p><pre name="2666" id="2666" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import type {NextPage} from &#39;next&#39;<br>import {useInfiniteQuery} from &#39;@tanstack/react-query&#39;<br>import axios from &#39;axios&#39;</code></pre><pre name="b550" id="b550" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const fetchColors = async ({pageParam = 1}) =&gt; {<br>  // pageParam =&gt; 1, 2, 3, ...<br>  return await axios.get(<br>    `http://localhost:4000/colors?_limit=3&amp;_page=${pageParam}`,<br>  )<br>}</code></pre><pre name="b097" id="b097" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const InfiniteQueries: NextPage = () =&gt; {<br>  const {data, isLoading, isError, error, hasNextPage, fetchNextPage} =<br>    useInfiniteQuery([&#39;colors&#39;], fetchColors, {<br>      getNextPageParam: (_lastPage, pages) =&gt; {<br>        if (pages.length &lt; 3) {<br>          return pages.length + 1<br>        } else {<br>          return undefined<br>        }<br>      },<br>    })</code></pre><pre name="8000" id="8000" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  if (isLoading) {<br>    return &lt;&gt;Loading...&lt;/&gt;<br>  }<br>  if (isError) {<br>    return &lt;&gt;Error: {error?.message}&lt;/&gt;<br>  }</code></pre><pre name="1f1e" id="1f1e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;p&gt;Colors&lt;/p&gt;<br>      {data?.pages.map((group, index) =&gt; (<br>        &lt;p key={index}&gt;<br>          {group.data.map(item =&gt; (<br>            &lt;div key={item.id}&gt;{item.label}&lt;/div&gt;<br>          ))}<br>        &lt;/p&gt;<br>      ))}<br>      &lt;button onClick={fetchNextPage} disabled={!hasNextPage}&gt;<br>        show more<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="deb0" id="deb0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default InfiniteQueries</code></pre><h3 name="b5ed" id="b5ed" class="graf graf--h3 graf-after--pre">useMutation</h3><h3 name="c0e8" id="c0e8" class="graf graf--h3 graf-after--h3">mutate &amp; POST Requests</h3><p name="f0d1" id="f0d1" class="graf graf--p graf-after--h3">We can use mutate for post requests and we can use them like below.</p><h4 name="091c" id="091c" class="graf graf--h4 graf-after--p">queryClient.invalidateQueries</h4><p name="5e3c" id="5e3c" class="graf graf--p graf-after--h4">We can mark the query as stale and we can tell it should be re-fetched again. So below when we add a user with useMutation hook then we can create a “queryClient” and use “invalidateQueries” method inside of its onSuccess case. We can call it and we can say the users’ data is stale you should re-fetch it.</p><pre name="793b" id="793b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import axios from &#39;axios&#39;<br>import type {NextPage} from &#39;next&#39;<br>import Link from &#39;next/link&#39;<br>import {useEffect, useState} from &#39;react&#39;<br>import {useMutation, useQuery, useQueryClient} from &#39;@tanstack/react-query&#39;</code></pre><pre name="131b" id="131b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const Home: NextPage = () =&gt; {<br>  const [email, setEmail] = useState()<br>  const [password, setPassword] = useState()</code></pre><pre name="9b8d" id="9b8d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const {<br>    data: usersData,<br>    isLoading,<br>    isError,<br>    error,<br>    refetch,<br>  } = useQuery([&#39;users&#39;], async () =&gt; {<br>    return await axios.get(&#39;http://localhost:4000/users&#39;)<br>  })</code></pre><pre name="0698" id="0698" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const addUser = async user =&gt; {<br>    return axios.post(&#39;http://localhost:4000/users&#39;, user)<br>  }</code></pre><pre name="a259" id="a259" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const queryClient = useQueryClient()<br>  const {<br>    mutate,<br>    isError: mutateIsError,<br>    error: mutateError,<br>    isLoading: mutateIsLoading,<br>  } = useMutation(addUser, {<br>    onSuccess: () =&gt; {<br>      queryClient.invalidateQueries(&#39;users&#39;)<br>    },<br>  })</code></pre><pre name="ff71" id="ff71" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const handleAddUserClick = () =&gt; {<br>    const user = {<br>      email,<br>      password,<br>    }<br>    mutate(user)<br>  }</code></pre><pre name="5b7b" id="5b7b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  if (isLoading) return &lt;&gt;Loading...&lt;/&gt;<br>  if (isError) return &lt;&gt;Error: {error.message}&lt;/&gt;</code></pre><pre name="eeab" id="eeab" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return (<br>    &lt;div&gt;<br>      &lt;nav&gt;<br>        &lt;Link href={`/`}&gt;Home&lt;/Link&gt;<br>        &lt;Link href={`/users`}&gt;Users&lt;/Link&gt;<br>        &lt;Link href={`/users-rq`}&gt;Users-RQ&lt;/Link&gt;<br>        &lt;Link href={`/users-rq-ssr`}&gt;Users-RQ-SSR&lt;/Link&gt;<br>      &lt;/nav&gt;<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          &lt;input<br>            type=&quot;text&quot;<br>            value={email}<br>            onChange={e =&gt; setEmail(e.target.value)}<br>          /&gt;<br>          &lt;input<br>            type=&quot;text&quot;<br>            value={password}<br>            onChange={e =&gt; setPassword(e.target.value)}<br>          /&gt;<br>          &lt;button onClick={handleAddUserClick}&gt;Add User&lt;/button&gt;<br>        &lt;/div&gt;<br>        {usersData?.data?.map(item =&gt; (<br>          &lt;p key={item.id}&gt;{item.id}&lt;/p&gt;<br>        ))}<br>        &lt;button onClick={refetch}&gt;Refetch&lt;/button&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>}</code></pre><pre name="3bc1" id="3bc1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">export default Home</code></pre><h4 name="861c" id="861c" class="graf graf--h4 graf-after--pre">setQueryData</h4><p name="d198" id="d198" class="graf graf--p graf-after--h4">Instead of using “invalidateQueries” like above, we can use “setQueryData” to get updated data. with “invalidateQueries” we can send a new fetch request and get updated data again. Instead of this we can use “setQueryData” and manipulate the “query” of “users”. In this way, we do not need to send an extra one more request to get new data.</p><pre name="9028" id="9028" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">    onSuccess: data =&gt; {<br>      // queryClient.invalidateQueries(&#39;users&#39;)<br>      queryClient.setQueryData(&#39;users&#39;, oldQueryData =&gt; {<br>        return {<br>          ...oldQueryData,<br>          data: [...oldQueryData.data, data.data],<br>        }<br>      })<br>    }</code></pre><h4 name="9a87" id="9a87" class="graf graf--h4 graf-after--pre">refetchQueries</h4><p name="73ea" id="73ea" class="graf graf--p graf-after--h4">Or if we need to fetch these data from more than one place, then we need to fetch the data for all of them. So we can use “refetchQueries” to update them all.</p><pre name="b885" id="b885" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">     onSuccess: data =&gt; {<br>      // queryClient.invalidateQueries(&#39;users&#39;)<br>      // queryClient.setQueryData(&#39;users&#39;, oldQueryData =&gt; {<br>      //   return {<br>      //     ...oldQueryData,<br>      //     data: [...oldQueryData.data, data.data],<br>      //  }<br>      // })<br>      queryClient.refetchQueries(&quot;users&quot;)<br>    }</code></pre><h4 name="3f0c" id="3f0c" class="graf graf--h4 graf-after--pre">Optimistic Updates</h4><p name="a652" id="a652" class="graf graf--p graf-after--h4">Source =&gt; <a href="https://react-query.tanstack.com/guides/optimistic-updates#_top" data-href="https://react-query.tanstack.com/guides/optimistic-updates#_top" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">react-query.tanstack.com/guides/optimistic-..</a></p><ul class="postList"><li name="012c" id="012c" class="graf graf--li graf-after--p">We can immediately update the user interface with new data. (with this =&gt; queryClient.setQueryData(‘users’, old =&gt; […old, newUser]))</li><li name="5018" id="5018" class="graf graf--li graf-after--li">Then we can send our request, if we have an error we can get back the new data from UI and show the previous data. (with onError =&gt; queryClient.setQueryData(‘users’, context.previousUsers))</li><li name="dea8" id="dea8" class="graf graf--li graf-after--li">And we always re-fetch if the request succeeds or fails.</li></ul><p name="cd01" id="cd01" class="graf graf--p graf-after--li">And these steps give us an optimistic update.</p><pre name="cfb1" id="cfb1" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const queryClient = useQueryClient()<br>  const {<br>    mutate,<br>    isError: mutateIsError,<br>    error: mutateError,<br>    isLoading: mutateIsLoading,<br>  } = useMutation(newUser, {<br>    //! onMutate =&gt; runs before the mutation is sent to the server<br>    onMutate: async newUser =&gt; {<br>      // we will cancel the queries because of we dont want they overwrite us<br>      // Cancel any outgoing refetches (so they don&#39;t overwrite our optimistic update)<br>      await queryClient.cancelQueries(&#39;users&#39;)</code></pre><pre name="b20f" id="b20f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      // Snapshot the previous value<br>      const previousUsers = queryClient.getQueryData(&#39;users&#39;)</code></pre><pre name="ef41" id="ef41" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      // Optimistically update to the new value<br>      queryClient.setQueryData(&#39;users&#39;, old =&gt; [...old, newUser])</code></pre><pre name="e7a0" id="e7a0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">      // Return a context object with the snapshotted value<br>      return {previousUsers}<br>    },</code></pre><pre name="7fd1" id="7fd1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    // If the mutation fails, use the context returned from onMutate to roll back<br>    onError: (_error, _user, context) =&gt; {<br>      queryClient.setQueryData(&#39;users&#39;, context.previousUsers)<br>    },</code></pre><pre name="00bf" id="00bf" class="graf graf--pre graf-after--pre graf--trailing"><code class="markup--code markup--pre-code">    // Always refetch after error or success:<br>    onSettled: () =&gt; {<br>      queryClient.invalidateQueries(&#39;users&#39;)<br>    },<br>  })</code></pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mucahidyazar" class="p-author h-card">Mucahid Yazar</a> on <a href="https://medium.com/p/8ed08a7242b"><time class="dt-published" datetime="2022-08-05T07:03:33.562Z">August 5, 2022</time></a>.</p><p><a href="https://medium.com/@mucahidyazar/react-query-you-do-not-need-a-global-state-manager-8ed08a7242b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 24, 2022.</p></footer></article></body></html>