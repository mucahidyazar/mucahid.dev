<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Docker - The neccesarry part (Volume &amp; Network &amp; Environment)</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Docker - The neccesarry part (Volume &amp; Network &amp; Environment)</h1>
</header>
<section data-field="subtitle" class="p-summary">
Bu kısımda sizlerle datalarımızı makinada saklamanın yolları yani host ve kullandığımız OS sistemi arasındaki dosya paylaşımlarını…
</section>
<section data-field="body" class="e-content">
<section name="a5b4" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7bd6" id="7bd6" class="graf graf--h3 graf--leading graf--title">Docker - The neccesarry part (Volume &amp; Network &amp; Environment)</h3><p name="42d0" id="42d0" class="graf graf--p graf-after--h3">Bu kısımda sizlerle datalarımızı makinada saklamanın yolları yani host ve kullandığımız OS sistemi arasındaki dosya paylaşımlarını, containerlar arası network oluşturup birbirleriyle iletişim kurmalarını, ve projelerimizin olmazsa olmazı environment variable tanımlamalarını öğreneceğiz.</p><figure name="2832" id="2832" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*Xd83Y1MygzaJ-WQK.png" data-width="720" data-height="448" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*Xd83Y1MygzaJ-WQK.png"></figure><h3 name="353c" id="353c" class="graf graf--h3 graf-after--figure">Volume</h3><p name="474f" id="474f" class="graf graf--p graf-after--h3">Volumelar bizim datalarımızı containerımızın çalıştığı sanal makinamız üzerindeki sistemde saklamamıza yarayan yapılardır. Mesela bir web projemiz olduğunu düşünün bu projemizde yüklediğimiz resimlerin veya formlarla eklediğimiz metinlerin, containerı çalıştırdığımız makinada tutulmasını istiyoruz. Ve volumelarda depoladığımız için, containerımız ne zaman çalışıp aktif olduğunda bu depolanmış dataların tekrar uygulamamız üzerinde erişimine sahip olmuş oluyor ve datalarımızı kaybetmemiş oluyoruz.</p><figure name="47b9" id="47b9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NPh1MKLAVfIZeFQr8QsWYg.png" data-width="480" data-height="252" src="https://cdn-images-1.medium.com/max/800/1*NPh1MKLAVfIZeFQr8QsWYg.png"></figure><p name="68f6" id="68f6" class="graf graf--p graf-after--figure"><a href="https://github.com/mucahidyazar/docker" data-href="https://github.com/mucahidyazar/docker" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://github.com/mucahidyazar/docker</a></p><ul class="postList"><li name="0819" id="0819" class="graf graf--li graf-after--p">Yukarıdaki linkten gerekli repoyu indiriyoruz.<br>git clone <a href="https://github.com/mucahidyazar/docker.git" data-href="https://github.com/mucahidyazar/docker.git" class="markup--anchor markup--li-anchor" rel="nofollow noopener noopener" target="_blank">https://github.com/mucahidyazar/docker.git</a></li><li name="1603" id="1603" class="graf graf--li graf-after--li">Ve tutorials branchine geçiyoruz.<br>git checkout tutorials</li><li name="3884" id="3884" class="graf graf--li graf-after--li">Be burada volume-example adlı dizine geliyoruz. Burada 2 klasör var. 1. si starter yani başlangıç klasörü, diğeri fnished yani bitiş dosyalarımız.</li><li name="4f91" id="4f91" class="graf graf--li graf-after--li graf--trailing">Takıldığınız yerde fnished klasörüne bakıp kopya çekebilirsiniz.</li></ul></div></div></section><section name="6ed4" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="1111" id="1111" class="graf graf--li graf--leading">Elimizde aşağıda ki kodlardan oluşan bir server.js dosyası var.</li></ul><figure name="1bef" id="1bef" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/19f75f7b35aabbbd2c3c5c133b9c884d.js"></script></figure><ul class="postList"><li name="a6c3" id="a6c3" class="graf graf--li graf-after--figure">Dosya structure yapısı da aşağıdaki gibi.</li></ul><figure name="2be6" id="2be6" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*meZy9B2WE5S7ZIZ72mWpsw.png" data-width="288" data-height="280" src="https://cdn-images-1.medium.com/max/800/1*meZy9B2WE5S7ZIZ72mWpsw.png"></figure><ul class="postList"><li name="c3fa" id="c3fa" class="graf graf--li graf-after--figure">Uygulamamızın görünümü bu şekilde. Eğer biz bir title ve text ile feedback bırakacak olursak, uygulamamız bunu bir metin belgesine dönüştürecek titleda yazan text’e göre ve bunu dosya structure yapısındaki feedback klasörünün içine atacaktır.</li></ul><figure name="3694" id="3694" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*fTuK_uMzTuCeVROjq3shwg.png" data-width="480" data-height="309" src="https://cdn-images-1.medium.com/max/800/1*fTuK_uMzTuCeVROjq3shwg.png"></figure><ul class="postList"><li name="05b5" id="05b5" class="graf graf--li graf-after--figure">Ve daha sonra buna biz ulaşmak isteseydik url kısmına aşağıdaki gibi feedback/awesome.txt yazdığımızda kaydettiğimiz txt dosyasını görüntüleyebilecektik.</li></ul><figure name="5416" id="5416" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*Y79ozGSurLELNn0zi2OQiA.png" data-width="288" data-height="66" src="https://cdn-images-1.medium.com/max/800/1*Y79ozGSurLELNn0zi2OQiA.png"></figure><ul class="postList"><li name="1633" id="1633" class="graf graf--li graf-after--figure">Burada sorun şu. Biz bu dosyayı dockerize edip docker containerında çalıştığı zaman image kendi dosya sistemi üzerinde çalışacak ve kaydedilen awesome.txt gibi dosyalar bizim uygulama dosyalarının olduğu yerde saklanmayacak. İşte volumelarla container image hostu ve kendi hostumuz arasında bağlantıyı sağlayacağız.</li><li name="130b" id="130b" class="graf graf--li graf-after--li">Şunu iyice anlamalıyız ki imageler sadece read-only’dir. Container ise read-write. Yani biz bir dosya kaydettiğimizde bu dosya containerın file systeminde saklanır. Imagenin file systeminde değil.</li></ul><figure name="2b13" id="2b13" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*PaqPfWUmCWINT2CBjr4l2g.png" data-width="480" data-height="221" src="https://cdn-images-1.medium.com/max/800/1*PaqPfWUmCWINT2CBjr4l2g.png"></figure><ul class="postList"><li name="5d23" id="5d23" class="graf graf--li graf-after--figure">Eğer bir containerı silersek ve daha sonra aynı image ile yeni container oluşturursak daha önce yaptığımız değişikliklerde containerın silinmesiyle gider. Fakat volume ile bu durumu değiştirebiliriz.</li><li name="2290" id="2290" class="graf graf--li graf-after--li">Veya container silmeden sadece stop yaparak durdurup daha sonra çalıştırırsak eski dosyalar silinmez ve aynı dosyaları kullanabilir veya bulabiliriz.</li></ul><figure name="4873" id="4873" class="graf graf--figure graf-after--li graf--trailing"><img class="graf-image" data-image-id="1*IWCjW0QsMnzMJey0Ibx7Iw.png" data-width="480" data-height="377" src="https://cdn-images-1.medium.com/max/800/1*IWCjW0QsMnzMJey0Ibx7Iw.png"></figure></div></div></section><section name="32f2" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="071c" id="071c" class="graf graf--li graf--leading">İki şekilde volume tanımlayabiliriz. Anonymous Volume veya Named volumes.</li><li name="ffdf" id="ffdf" class="graf graf--li graf-after--li">Anonymous volumesları Dockerfile içinde aşağıda ki gibi veya docker run volume create komutunu kullanırken :’den önceki ilk tanımı yapmayarak</li></ul><figure name="f1b1" id="f1b1" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/e8400e9ed0dbcc4a08640dbde355baf8.js"></script></figure><ul class="postList"><li name="a30a" id="a30a" class="graf graf--li graf-after--figure">Ananymous volumeslar container silindikten sonra otomatik olarak silinir.</li></ul><h4 name="86c7" id="86c7" class="graf graf--h4 graf-after--li">docker volume -help</h4><ul class="postList"><li name="4397" id="4397" class="graf graf--li graf-after--h4">Aşağıda docker volume ile yapabileceğimiz komutların bazılarını görüyorsunuz.</li></ul><figure name="03b3" id="03b3" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*whZs7r1mTqcWimR_fXCt7A.png" data-width="285" data-height="105" src="https://cdn-images-1.medium.com/max/800/1*whZs7r1mTqcWimR_fXCt7A.png"></figure><h4 name="cdfb" id="cdfb" class="graf graf--h4 graf-after--figure">docker volume ls</h4><ul class="postList"><li name="22d6" id="22d6" class="graf graf--li graf-after--h4">Docker volumelerimizi listeler.</li></ul><h4 name="444c" id="444c" class="graf graf--h4 graf-after--li">docker volume create volumeName</h4><ul class="postList"><li name="95df" id="95df" class="graf graf--li graf-after--h4">Docker volumesı oluştururuz.</li></ul><h4 name="6993" id="6993" class="graf graf--h4 graf-after--li">docker volume prune</h4><ul class="postList"><li name="eea4" id="eea4" class="graf graf--li graf-after--h4">Kullanılmayan voluemleri siler.</li></ul><h4 name="8d20" id="8d20" class="graf graf--h4 graf-after--li">docker volume rm volumeName</h4><ul class="postList"><li name="75e0" id="75e0" class="graf graf--li graf-after--h4">volume ismine göre volumelerimizi siler.</li></ul><h4 name="4f51" id="4f51" class="graf graf--h4 graf-after--li">docker volume inspect volumeName</h4><ul class="postList"><li name="f551" id="f551" class="graf graf--li graf-after--h4">Oluşturduğumuz volume ait bilgileri görürüz yani inspect ederiz.</li></ul><figure name="0d3f" id="0d3f" class="graf graf--figure graf-after--li graf--trailing"><img class="graf-image" data-image-id="1*grgVtSNaEpzLvqPO9nt6Gg.png" data-width="480" data-height="187" src="https://cdn-images-1.medium.com/max/800/1*grgVtSNaEpzLvqPO9nt6Gg.png"></figure></div></div></section><section name="05d7" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="78b7" id="78b7" class="graf graf--li graf--leading">Terminale gelip yeni temiz bir image buildi alıyoruz.</li></ul><figure name="55c2" id="55c2" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*jxbx5oqFsAIn_LDvIBM7lw.png" data-width="480" data-height="238" src="https://cdn-images-1.medium.com/max/800/1*jxbx5oqFsAIn_LDvIBM7lw.png"></figure><h4 name="1016" id="1016" class="graf graf--h4 graf-after--figure"><strong class="markup--strong markup--h4-strong">docker run -v volumeName:/volumePathFromWorkdirOnImageFileSystem …</strong></h4><ul class="postList"><li name="6048" id="6048" class="graf graf--li graf-after--h4">Yukarıda ise named yani isimlendirilmiş bir volume oluşturuyoruz, imagemizi container oluşturup çalıştırırken yapıyoruz bu işlemleri. İlk olarak volume için isim veriyoruz, ikinci olarak ise : işaretinden sonra imagemizdeki hangi pathdeki dosyaları bu volumede tutacağımız yolu belirliyoruz.</li></ul><p name="9c4e" id="9c4e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker run -v feedback-volume:/app/feedback --name feedback-container -p 3000:80 --rm -d feedback-node:latest</strong></p><ul class="postList"><li name="56de" id="56de" class="graf graf--li graf-after--p">Bizim kendi örneğimizzden gidecek olursak,<br>1. -v ile feedback-volume adında bir volume oluşturuyoruz ve bu volumenin yolu olarakta : işaretinden sonra imagedeki WORKDIR’den volumede tutulacak konumu belirliyoruz.<br>2. --name ile oluşturulup çalıştırılacak containerımıza feedback-container ismini veriyoruz.<br>3. -p ile makinamızdaki 3000 portunu containerın çalıştırdığı imagenin 80 portuyla bind ediyoruz<br>4. --rm ile container stop olduğunda silinsin istiyoruz.<br>5. -d ile detach modda çalışsın istiyoruz. Bu bizi container başlattıktan sonra default olarak attach moddan kurtarır. Böylelikle node terminalinde kalmayız ve direk kendi terminalimize döneriz.<br>6. Ve son olarakda feedback-node:latest ile imageName ve tagine göre imagemizi seçiyoruz.</li><li name="0f39" id="0f39" class="graf graf--li graf-after--li">Yukarıdaki kodu çalıştırıp detach moda geçtiğimizde<br>1. docker ps -a yaparak tüm containerlarımızı görüyorum ve ilk gördüğünüz gibi containerımız çalışıyor.<br>2. Daha sonra docker volume ls yaparak volumeleri listeliyorum. Ve gördüğünüz gibi yukarıda imagemizi containerla çalıştırırken oluşturduğumuz volume burada.<br>3. Daha sonra docker stop containerId mi yazarak çalışan containerımı durduruyorum ve --rm bu container otomatik olarak siliyor. Hatta 2 alt satırda docker ps -a yaptım bunu görmeniz için.<br>4. Daha sonra docker volume ls yapıyoruz ve volumemizin hala silinmediğini ve orada olduğunu görüyoruz. Containerın silinmesine ragmen. Buda bir daha yeni container oluştursak bu volumeyi kaybetmeyeceğimiz için uygulamamız sürekli her çalıştığında aynı verileri bulup saklayabileceği anlamına gelmektedir.<br>5. Ve en alt satırda ki gibi, containerımız silindikten sonra tekrar aynı image ile yeni container oluşturup çalıştırırken aynı isim ile volume’ye bağlanmalıyız.</li></ul><figure name="1b28" id="1b28" class="graf graf--figure graf-after--li graf--trailing"><img class="graf-image" data-image-id="1*eYMi61st67zwFZFJqxpsag.png" data-width="480" data-height="193" src="https://cdn-images-1.medium.com/max/800/1*eYMi61st67zwFZFJqxpsag.png"></figure></div></div></section><section name="43ee" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="fe33" id="fe33" class="graf graf--li graf--leading">Container ve volume etkileşimini iyi anlamamız gerekmektedir.</li><li name="c60e" id="c60e" class="graf graf--li graf-after--li">Container ilk açıldığında /app/data da eğer dosya yoksa volüme deki /some-path den alır. Fakat dosya varsa eğer o zaman containerdaki dosyalar volüme deki /some-path üzerine overwrite edilir yani yazılır.</li><li name="ff15" id="ff15" class="graf graf--li graf-after--li">Fakat /app/code içinde ilk container çalıştığında dosya yoksa /some-other-path volumedeki dosyalar /app/code içine gönderilerek container her başladığında eklenir.</li></ul><figure name="0cde" id="0cde" class="graf graf--figure graf-after--li graf--trailing"><img class="graf-image" data-image-id="1*XJ7O8s3xGcZDoMz2p8EP8Q.png" data-width="480" data-height="308" src="https://cdn-images-1.medium.com/max/800/1*XJ7O8s3xGcZDoMz2p8EP8Q.png"></figure></div></div></section><section name="aad1" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="a9c0" id="a9c0" class="graf graf--h4 graf--leading">Sharing Source Code with a Container</h4><ul class="postList"><li name="0306" id="0306" class="graf graf--li graf-after--h4">Ve şimdi şöyle bir sistem yapalım. Lokalimizde proje dosyalarında herhangi bir değişiklik yaptığımız da bunun projeye anında yansımasını sağlayan bir yapı kuralım volumelerle.</li><li name="a6cd" id="a6cd" class="graf graf--li graf-after--li">Aşağıda ki gibi projemizde bir değişiklik yaparsak bu hemen browserda bize yansımaz. Bunun için yeni bir volume tanımalıyız. Öyle bir şey yapacağız ki projedeki herhangi bir değişiklik immediately yani acil olarak containera yansıyacak.</li></ul><figure name="748f" id="748f" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*_BlYr8v1qzYSk8TWs0tzvw.png" data-width="480" data-height="135" src="https://cdn-images-1.medium.com/max/800/1*_BlYr8v1qzYSk8TWs0tzvw.png"></figure><p name="ebdc" id="ebdc" class="graf graf--p graf-after--figure graf--trailing"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">NOTE</em></strong>: Tabi burada unutmamız gereken şey,<br>önceki volume tanımlamamız orada dataları toplayıp daha sonra uygulamamızın containerı çalışıp mount olduğunda burada voluemdaki dataları uygulamamıza kopyalamak,<br>burada ki volüme tanımlamamızda ki sebep ise uygulamamız açıldığında, şuan ki dizinin adında bir volüme oluşturup bunu anında uygulamamızın containerı çalıştığında oradaki WORKDIR’e yani /app’e göndermek.</p></div></div></section><section name="2c5d" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="2fde" id="2fde" class="graf graf--p graf--leading">PATH Tanımlamaları</p><ul class="postList"><li name="0233" id="0233" class="graf graf--li graf-after--p">İster absolute pathi almak için aşağıdaki gibi uzun adres tanımlayın<br><strong class="markup--strong markup--li-strong">E:\Software\worksheets\docker\examples\volume-example\final</strong></li><li name="4e63" id="4e63" class="graf graf--li graf-after--li">İsterseniz de aşağıdaki gibi sistemlere özgü kısa yolları kullanın<br><strong class="markup--strong markup--li-strong">macOS / Linux:</strong> -v $(pwd):/app<br><strong class="markup--strong markup--li-strong">Windows:</strong> -v “%cd%”:/app</li><li name="9387" id="9387" class="graf graf--li graf-after--li">Veya image tercihine göre containerımızın virtual machinesinin çalıştıracağı imageye göre aşağıdaki şekillerde kullanabilirsiniz.</li></ul><p name="b96f" id="b96f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">FROM node:14<br></strong>docker run -v feedback-volume:/app/feedback -v <strong class="markup--strong markup--p-strong">${pwd}</strong>:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</p><p name="ab81" id="ab81" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">FROM node:14.16.0-alpine3.13<br></strong>docker run -v feedback-volume:/app/feedback -v <strong class="markup--strong markup--p-strong">$(pwd)</strong>:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</p><p name="c026" id="c026" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong">with absolute path<br>E:\Software\worksheets\docker\examples\volume-example\final<br></strong>Özel karakter olur diye “” bu isaret içinde yazmak en güvenilir yoludur volume pathi tanımlarken. Özel karakter yoksa kullanmayada gerek yoktur. Aslında aşağıda da kullanmasak da olurdu.<br>docker run -v feedback-volume:/app/feedback -v <strong class="markup--strong markup--p-strong">“Software\worksheets\docker\examples\volume-example\final:/app” --</strong>name feedback-container -p 3000:80 --rm -d feedback-node:latest</p></div></div></section><section name="7140" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="ce62" id="ce62" class="graf graf--h4 graf--leading"><strong class="markup--strong markup--h4-strong">docker run -v /pathThatBindingWithVolume</strong></h4><ul class="postList"><li name="03a7" id="03a7" class="graf graf--li graf-after--h4">Eger volumeName yazmasak yukarıda ki gibi, anonymous bir volume tanımlamış oluruz.</li></ul><h4 name="ef88" id="ef88" class="graf graf--h4 graf-after--li"><strong class="markup--strong markup--h4-strong">docker run -v bindedPathOnOurOS:/bindedPathOnVMOS</strong></h4><p name="cd9b" id="cd9b" class="graf graf--p graf-after--h4"><strong class="markup--strong markup--p-strong">docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 --rm -d feedback-node:latest</strong></p><ul class="postList"><li name="1e10" id="1e10" class="graf graf--li graf-after--p">Evet bunun için ikinci bir volume belirliyoruz -v ile. Birinci volume hatırlarsanız feedbackleri volumeda tutmak içindi.</li><li name="9cd1" id="9cd1" class="graf graf--li graf-after--li">Ve bu volume’yi dynamic olarak <strong class="markup--strong markup--li-strong">node:14</strong> imagesini kullandığım için <strong class="markup--strong markup--li-strong">${ }</strong> arasina pwd yazarak current directorymizle bir volume oluşturuyoruz. Ve bu volumeyi imagedeki app klasörüyle bağlıyoruz. Böylelikle projede yani ${pwd} dizininde yaptığımız her değişiklik anında app klasörüne yansımış olacak.</li><li name="5cee" id="5cee" class="graf graf--li graf-after--li">Bu şekilde docker run yaptığımızda uygulamamızın çalışıp ve bir container oluşturup ardından daha sonra hemen stop ederek containerın silindiğini göreceksiniz. Çünkü express hatası verecek aşağıda ki gibi.</li></ul><p name="dff0" id="dff0" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 -d feedback-node:latest</strong></p><ul class="postList"><li name="59dc" id="59dc" class="graf graf--li graf-after--p">Bunu gösterebilmek için ben --rm yi silerek yukarıdaki kodun aynısını çalıştıracağım. Böylelikle uygulamamız hata verdiğinde otomatik kapanmayacak ve container silinmeyecek. Bu şekildede biz containerın çalıştırdığı imagemizin terminale bastırdığı hatanın logunu alabileceğiz.</li><li name="a4a3" id="a4a3" class="graf graf--li graf-after--li">Gördüğünüz gibi Express hatası alıyoruz. Sebebi ikinci volüme(<strong class="markup--strong markup--li-strong">-v ${pwd}:/app --name feedback-container</strong>) tanımlamamız yüzünden. Çünkü <strong class="markup--strong markup--li-strong">pwd</strong> deki kendi OS sistemimizdeki dizinde bizim node_modules klasörümüz yukarıda tanımladığımız volumenin bizim pwd dizinindeki tüm herşeyi /app ile overwrite etmesinden dolayı yok, yani uygulamamız npm install yapıyor imagenin Dockerfilesına göre ama daha sonra bu node_modules overwrite yüzünden siliniyor ve uygulama mounted olduğunda node_modules olmayan buradaki tüm klasörler ve dosyaları, imagemizin çalıştığı containerdaki WORKDIR deki /app dizinindeki tüm dosyalarla değiştir. Buda Dockerfile ile npm install yapıp yüklediğimiz node_modules de silinmiş oluyor.</li></ul><figure name="b2a2" id="b2a2" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*s2KBalno70zlOQQTj4o01Q.png" data-width="480" data-height="279" src="https://cdn-images-1.medium.com/max/800/1*s2KBalno70zlOQQTj4o01Q.png"></figure><ul class="postList"><li name="3407" id="3407" class="graf graf--li graf-after--figure">Bu sorunu gidermek için bir kaç farklı yöntem var. Ya bir user oluşturup, buna çeşitli yetkiler vererek halledebiliriz. Yada aşağıdaki gibi node_modules’u başka bir anonymous volume’a veririz ve silinmesini engelleriz. Ve bu şekilde yukarıdaki hatayı önlemiş oluruz.</li></ul><p name="49a0" id="49a0" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker run -v feedback-volume:/app/feedback -v ${pwd}:/app -v /app/node_modules --name feedback-container -p 3000:80 -d --rm feedback-node:latest</strong></p><ul class="postList"><li name="134e" id="134e" class="graf graf--li graf-after--p">Ve şimdi artık uygulamamızda yaptığımız her değişiklik anında çalışan containerdaki dosya sistemimize anında yansıyacaktır. Artık dosyada bir değişiklik yapıp bunu görebilirsiniz.</li><li name="34d5" id="34d5" class="graf graf--li graf-after--li">Fakat yinede bir sorunumuz daha var yukarıdaki yaptığımız değişiklikler dosyalara aynı anda hemen yansır fakat bizim projemiz bu yansımayı hemen bize gösterir mi? Pages içindeki html sayfalarında yaparsak eğer bir f5 sornası yaptığımız değişikliği hemen görebiliriz. Fakat biz hatırlarsanız nodeda kullandığımız express serverını node server.js diyerek başlatıyoruz. Yani biz server.js içindeki bir fonksiyon içinde bir console.log yapacak olursak, node server.js ile bunu yaptığımız için değişiklik hemen yansımayacaktır, çünkü node serverını kapatıp tekrar node server.js dememiz gerekecektir içindeki o değişikliği yakalayabilmek için. Veya bunun için nodemon adında bir npm packagei çözüm sunar bize. O zaman buradada bu değişikliği aşağıdaki gibi package.jsona hemen ekliyoruz.</li></ul><p name="317b" id="317b" class="graf graf--p graf-after--li"><a href="https://gist.github.com/mucahidyazar/ffc479cfbc0b4257ecb5e986604b17b8" data-href="https://gist.github.com/mucahidyazar/ffc479cfbc0b4257ecb5e986604b17b8" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://gist.github.com/mucahidyazar/ffc479cfbc0b4257ecb5e986604b17b8</a></p><ul class="postList"><li name="3fa9" id="3fa9" class="graf graf--li graf-after--p">Ve yukarıda ki yaptığımız değişiklikten ötürü CMD yi artık node server.js yerine yukarıda tanımladığımız script ile kullanacağız.</li><li name="cdc8" id="cdc8" class="graf graf--li graf-after--li">Anonymous volumeyide her seferinde terminalde yazmak yerine artık Dockerfileye aşağıdaki gibi ekliyoruz.</li></ul><figure name="c273" id="c273" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/48e9b96efb12d7ba4b0afc84d7ad1411.js"></script></figure><ul class="postList"><li name="b47e" id="b47e" class="graf graf--li graf-after--figure">Daha sonra imagemizi yeniden build alarak oluşturuyoruz.</li><li name="9e3f" id="9e3f" class="graf graf--li graf-after--li">Ve artık terminale gelip aşağıdaki kodla imagemizi container oluşturarak çalıştırıyoruz.</li></ul><p name="2db6" id="2db6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker run -v feedback-volume:/app/feedback -v ${pwd}:/app --name feedback-container -p 3000:80 -d --rm feedback-node:latest</strong></p><ul class="postList"><li name="66e7" id="66e7" class="graf graf--li graf-after--p">Aslında (<strong class="markup--strong markup--li-strong">${pwd}:/app</strong>) bunu yaparak Dockerfiledaki COPY . . nın işini bir nevi yine yapıyoruz yani Dockerfiledan onu kaldırsakta hiç bir şey olmaz. Fakat biz (<strong class="markup--strong markup--li-strong">${pwd}:/app</strong>) bunu developmentda yaptığımız için günün sonunda COPY . . ya bizim productionda yine ihtiyacımız olacak o yüzden kaldırmaya gerek yok yinede tutabiliriz.</li><li name="372c" id="372c" class="graf graf--li graf-after--li">Ve şimdi server tarafında yaptığımız değişikliklerde anında yansıyacaktır nodemon sayesinde.</li><li name="bfb0" id="bfb0" class="graf graf--li graf-after--li">Bu tarz sorunlar bize farklı uygulamalarda da çıkabilir bunları aşmak için bu tarz yöntemleri araştırıp bulmalıyız veya geliştirmeliyiz.</li></ul><h4 name="4123" id="4123" class="graf graf--h4 graf-after--li">ro (read-only)<br>docker run -v volumeName:/projectPath:ro</h4><ul class="postList"><li name="f0d1" id="f0d1" class="graf graf--li graf-after--h4 graf--trailing">Yukarıda ki gibi tanımlayacağımız volumeleri sadece read-only yapabiliriz.</li></ul></div></div></section><section name="ea4a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a964" id="a964" class="graf graf--h3 graf--leading">ENVironment Variables &amp; ARGuments</h3><h4 name="5db5" id="5db5" class="graf graf--h4 graf-after--h3">ENV</h4><ul class="postList"><li name="b45e" id="b45e" class="graf graf--li graf-after--h4">Environment variablelari ise Dockerfile içerisinde asagidaki gibi ya aralarinda bir bosluk birakarak yada = ile tanimlayabiliriz ben = ile tanımlamayı tercih ediyorum.</li></ul><figure name="ad6f" id="ad6f" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/8308e52dabfac764d7b5d30dc42f85fc.js"></script></figure><ul class="postList"><li name="1b34" id="1b34" class="graf graf--li graf-after--figure">Ve daha sorna imagemizi oluşturup containerimızı imagemizle çalıştırdığımızda istersek bu environmentleri aşağıda ki gibi görebiliriz.</li></ul><figure name="9638" id="9638" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*RzTwqJbwDXTqm2iywI8_IA.png" data-width="480" data-height="187" src="https://cdn-images-1.medium.com/max/800/1*RzTwqJbwDXTqm2iywI8_IA.png"></figure><ul class="postList"><li name="9f4b" id="9f4b" class="graf graf--li graf-after--figure">Veya shell ile çalıştırdığımız için istersek yazdırabiliriz de echo yaparak.</li></ul><figure name="c0e0" id="c0e0" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*UhdCNM6LQc_Nv0r4iJY8Uw.png" data-width="288" data-height="151" src="https://cdn-images-1.medium.com/max/800/1*UhdCNM6LQc_Nv0r4iJY8Uw.png"></figure><h4 name="d8b6" id="d8b6" class="graf graf--h4 graf-after--figure">docker run --env/-e PORT=80 …</h4><ul class="postList"><li name="868d" id="868d" class="graf graf--li graf-after--h4">Veya yukarıdaki tanımdaki veya aşağıdaki örnekteki gibi docker run yaparken de environment variablesları tanımlayabilirsiniz.<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app --<strong class="markup--strong markup--li-strong">env PORT=80</strong> feedback-image<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app <strong class="markup--strong markup--li-strong">-e PORT=80</strong> feedback-image<br>docker run --rm -p 3000:80 --name feedback-container -v feedback-volume:/app/feedback -v ${pwd}:/app --<strong class="markup--strong markup--li-strong">env PORT=80</strong> --<strong class="markup--strong markup--li-strong">env ENDPOINT=https://www.google.com</strong> feedback-image</li></ul><h4 name="696c" id="696c" class="graf graf--h4 graf-after--li">docker run --env-file ./dev.env …</h4><ul class="postList"><li name="94b7" id="94b7" class="graf graf--li graf-after--h4">Veya kendi OS sistemimizde terminaldeki konumumuza göre dev.env veya prod.env gibi dosyalarımızı --env-file komutuna tanımlatarak aslında birden fazla environment variable olan dosyamızdaki tüm environment variablesları tanımlatabiliriz.</li></ul><h4 name="e974" id="e974" class="graf graf--h4 graf-after--li">ARGuments</h4><ul class="postList"><li name="2bed" id="2bed" class="graf graf--li graf-after--h4">Argslar bizim aslında Dockerfile içinde tanımladığımız variableslardır diyebiliriz.</li><li name="46f7" id="46f7" class="graf graf--li graf-after--li">Ve genellikle ENVlerin hemen üstüne tanımlamalıyız çünkü değiştiklerinde aşağısındaki layerların bir daha boş yere hesaplanmasını istemiyoruz.</li></ul><figure name="2cff" id="2cff" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/59b892322e46b526ff17a72f27e3198d.js"></script></figure><ul class="postList"><li name="c369" id="c369" class="graf graf--li graf-after--figure">Ve artık aşağıdaki gibi yeni bir build aldığımızda default port env ve expose port 80 olarak hesaplanarak image oluşturulur.</li></ul><p name="f8df" id="f8df" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker build -t feedback-image .</strong></p><ul class="postList"><li name="6336" id="6336" class="graf graf--li graf-after--p">Fakat istersekde sadece arg tanımımızı docker run da değiştirerek default portu ezerek yeni bir arg tanımlayabiliriz aşağıda ki gibi.</li><li name="200f" id="200f" class="graf graf--li graf-after--li">Böylelikle bu buildimiz ise yeni Dockerfile içinde olan DEFAUULT_PORT argını yeni değeri 8000 ile tanımlamış oluruz.</li></ul><p name="87da" id="87da" class="graf graf--p graf-after--li graf--trailing">docker build -t feedback-image:defaultArg --build-arg <strong class="markup--strong markup--p-strong">DEFAULT_PORT=8000</strong> .</p></div></div></section><section name="75d3" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1c2f" id="1c2f" class="graf graf--h3 graf--leading">NETWORKING: (CROSS-) CONTAINER COMMUNICATION</h3><ul class="postList"><li name="08f4" id="08f4" class="graf graf--li graf-after--h3">Öncelikle githubdan api-example örneğinin starter klasörünü vs codeumuzda indirip açıyoruz.</li></ul><figure name="cd9c" id="cd9c" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*qfmfMRnNZkIDJB3wg4-y-g.png" data-width="480" data-height="292" src="https://cdn-images-1.medium.com/max/800/1*qfmfMRnNZkIDJB3wg4-y-g.png"></figure><ul class="postList"><li name="696e" id="696e" class="graf graf--li graf-after--figure">Bu örnekte containerımızla dış dünya arasındaki ilişkileri inceleyeceğiz. Burada 3 çeşit bağlantımız olabilir.</li></ul><ol class="postList"><li name="2e90" id="2e90" class="graf graf--li graf-after--li">Bir API’a istek atıyor olabileceğimiz durumlar. Bu örneğimizde starwars ile ilgili bir apia istek atıyoruz.</li></ol><figure name="9082" id="9082" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/b23a56f58a1d506ee4c194b1c0f79f0f.js"></script></figure><p name="1f65" id="1f65" class="graf graf--p graf-after--figure">2. Local makinamızla kuracağımız communicationlar. Bu örneğimizde mongodb’ye kendi makinamızda bağlanıyoruz.</p><figure name="6ba8" id="6ba8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mucahidyazar/a95b38800b3634e5f76367783827e049.js"></script></figure><p name="8d93" id="8d93" class="graf graf--p graf-after--figure graf--trailing">3. Başka containerlarla olan communicationlar. Bu örneğimizde şuan yok ama ileride bunları da yapabiliyor olacağız.</p></div></div></section><section name="bcbf" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="e31b" id="e31b" class="graf graf--h4 graf--leading">API Communications</h4><ul class="postList"><li name="9697" id="9697" class="graf graf--li graf-after--h4">Api communicatinoslar için yapmamız gereken her hangi bir özel ayar yoktur.</li><li name="5314" id="5314" class="graf graf--li graf-after--li">Yukarıdaki örnek için konuşacak olursam, app.listenı en yukarı alarak mongoose’yi tamamen iptal ediyorum çünkü şuanda bu şekilde dockerda çalıştırırsak imagemizi build alıp mongoose, localhost’a bağlanamayacağı için hata verecek ve app.listen serverımızı çalıştırmayacaktır.</li><li name="e22a" id="e22a" class="graf graf--li graf-after--li">Aşağıdaki gibi yapıp build alıyoruz,</li></ul><p name="4aab" id="4aab" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker build -t api-image .</strong></p><ul class="postList"><li name="985a" id="985a" class="graf graf--li graf-after--p">Daha sorna run yapıyoruz</li></ul><p name="e9de" id="e9de" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker run --rm --name api-container -p 3000:3000 api-image:latest</strong></p><ul class="postList"><li name="f7e1" id="f7e1" class="graf graf--li graf-after--p">Ve şimdi localhost:3000/movies veya localhost:3000/people ‘a gidersek swapi.dev apiına atyıp aldığımız responseleri, kendi responselerimiz olarak browserda göreceğiz. Yani hiçbir ayar yapmadan api isteklerini atıp alabiliyoruz.</li></ul><figure name="5499" id="5499" class="graf graf--figure graf--iframe graf-after--li graf--trailing"><script src="https://gist.github.com/mucahidyazar/380b2b8882024d260a54c92546a56e67.js"></script></figure></div></div></section><section name="2029" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="87e4" id="87e4" class="graf graf--h4 graf--leading">Your Host Machine Communications</h4><ul class="postList"><li name="d7a8" id="d7a8" class="graf graf--li graf-after--h4">Şimdi tekrar yukarıdaki satırı eski haline getiriyoruz.</li><li name="c9fa" id="c9fa" class="graf graf--li graf-after--li">Tek yapmamız gereken localhost yerine host.docker.internal kullanmaktır. Bu o anki hostunuzun adresi ne ise onun tarifidir. Localhost ise localhost, www ile başlayan özel bir AWS hostu ise o hostu temsil eder.</li><li name="c48c" id="c48c" class="graf graf--li graf-after--li">Ve şimdi tekrar aşağıdaki gibi yapıp build alıyoruz,</li></ul><p name="9f64" id="9f64" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker build -t api-image .</strong></p><ul class="postList"><li name="1a07" id="1a07" class="graf graf--li graf-after--p">Daha sorna run yapıyoruz</li></ul><p name="0eb6" id="0eb6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker run --rm --name api-container -p 3000:3000 api-image:latest</strong></p><ul class="postList"><li name="8945" id="8945" class="graf graf--li graf-after--p">Ve artık localhost’a attığımız favorites POST isteğinide postman vasıtasıyla atıp, localdeki mongo databasemize birşeyler kaydedebiliriz.</li></ul><figure name="1f41" id="1f41" class="graf graf--figure graf--iframe graf-after--li graf--trailing"><script src="https://gist.github.com/mucahidyazar/9e73c91777ba6cd7b1b0831b40b66f6b.js"></script></figure></div></div></section><section name="2055" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="d117" id="d117" class="graf graf--h4 graf--leading">Containers Communications</h4><ul class="postList"><li name="44c5" id="44c5" class="graf graf--li graf-after--h4">İlk önce mongo imagesini dockerhubdan indirtip makinamızda çalıştıralım.<br><strong class="markup--strong markup--li-strong">docker run --rm --name mongo-container -d mongo</strong></li><li name="caf4" id="caf4" class="graf graf--li graf-after--li">Daha sonra docker ps yaptığımızda göreceğiniz üzere mongo-container adında bir container çalışıyor.</li><li name="121d" id="121d" class="graf graf--li graf-after--li">Daha sonra buna inspect yaparak bu containerın bilgilerini alıyoruz.<br><strong class="markup--strong markup--li-strong">docker inspect mongo-container</strong></li></ul><figure name="344f" id="344f" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*q-qyn4miehe4bEYdXmAzJw.png" data-width="480" data-height="229" src="https://cdn-images-1.medium.com/max/800/1*q-qyn4miehe4bEYdXmAzJw.png"></figure><ul class="postList"><li name="2e6d" id="2e6d" class="graf graf--li graf-after--figure">Ve daha sonra çıkan bilgilerden, Networks’deki bridgeden IPAdress’i alıyoruz ve aşağıdaki gibi mongodb tanımına yazıyoruz.</li></ul><figure name="dc03" id="dc03" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/d4a5b9db575644c43180692d12cc0ef2.js"></script></figure><ul class="postList"><li name="a0f8" id="a0f8" class="graf graf--li graf-after--figure graf--trailing">Ve şimdi tekrar uygulamamızın imagesini silip tekrar build alıyoruz ve run yapıyoruz. Göreceksiniz ki artık mongodb miz diğer containerın ip adresine bağlanacaktır. Ve hatta localhost:3000/favorites adresine istek attığınızda göreceksiniz ki boş bir array dönecek çünkü bu mongo imagesinin hostundaki databaseden dönen değerdir.</li></ul></div></div></section><section name="82a5" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5fee" id="5fee" class="graf graf--h3 graf--leading">Networks</h3><ul class="postList"><li name="d055" id="d055" class="graf graf--li graf-after--h3">Containerları dahil edebilip birbirleriyle iletişim kurabilecekleri bir grup gibi düşünebilirsiniz burayı. Birden fazla containerı bir network oluşturup bu networke dahil ederiz run yaptığımız zaman ve daha sonra birbirlerine ulaşmak için tek yapmaları gereken birbir container isimlerini kuyllanmak olacaktır.</li></ul><h4 name="8784" id="8784" class="graf graf--h4 graf-after--li">docker network create networkName</h4><ul class="postList"><li name="88c3" id="88c3" class="graf graf--li graf-after--h4">Containerların birbirleriyle iletişim kuracağı network oluşturur</li></ul><h4 name="6ff7" id="6ff7" class="graf graf--h4 graf-after--li">docker network ls</h4><ul class="postList"><li name="d4ed" id="d4ed" class="graf graf--li graf-after--h4">Networkleri listeler.</li></ul><h4 name="cdad" id="cdad" class="graf graf--h4 graf-after--li">docker network rm networkName</h4><ul class="postList"><li name="2217" id="2217" class="graf graf--li graf-after--h4 graf--trailing">network ismi ile networku siler.</li></ul></div></div></section><section name="bcad" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="67b7" id="67b7" class="graf graf--li graf--leading">Yukarıda ki örneğimiz için önce çalışan containerlarımızı durduruyoruz.</li><li name="1f89" id="1f89" class="graf graf--li graf-after--li">Ve aşağıdaki gibi bir network kuruyoruz.</li></ul><p name="f72f" id="f72f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker network create api-network</strong></p><ul class="postList"><li name="a652" id="a652" class="graf graf--li graf-after--p">Ve şimdi mongo imagemizi çalıştırıp containerının bu networke dahil olmasını sağlıyoruz. Ve artık mongo imagemizin containerı api-network adında kurduğumuz networke girmiş oluyor.</li></ul><p name="b380" id="b380" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker run --rm --name mongo-container -d --network api-network mongo</strong></p><ul class="postList"><li name="62ca" id="62ca" class="graf graf--li graf-after--p">Şimdi uygulamamızdaki app.js’e gelip mongodb bağlantı noktasını mongo imagesi için ayarladığımız container isimi olan mongo-container yapıyoruz aşağıdaki gibi.</li></ul><figure name="287e" id="287e" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/mucahidyazar/6a2753e0980de7d84872442d68dc3427.js"></script></figure><ul class="postList"><li name="7c66" id="7c66" class="graf graf--li graf-after--figure">Ve şimdi bu uygulamamızın imagesinide silip yeniden build alıyoruz.</li></ul><p name="9ae2" id="9ae2" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker build -t api-image .</strong></p><ul class="postList"><li name="9292" id="9292" class="graf graf--li graf-after--p">Ve şimdi uygulamamızı aşağıdaki gibi mongo imagesini run ederken yaptığımız gibi aynı networke dahil edip run yaptırıyoruz.</li></ul><p name="01f2" id="01f2" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">docker run --rm --name api-container -p 3000:3000 --network api-network api-image:latest</strong></p><ul class="postList"><li name="3c1c" id="3c1c" class="graf graf--li graf-after--p graf--trailing">Ve artık imagemizde aynı networkde olduğu için diğer containerı container adıyla yani mongo-container ile tanıyım bulup başarılı bir şekilde diğer bir containerla iletişimi kurup isteklerimizi cevap verecektir.</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mucahidyazar" class="p-author h-card">Mucahid Yazar</a> on <a href="https://medium.com/p/f5d1ee8b815b"><time class="dt-published" datetime="2021-06-04T07:02:08.467Z">June 4, 2021</time></a>.</p><p><a href="https://medium.com/@mucahidyazar/docker-the-neccesarry-part-volume-network-environment-f5d1ee8b815b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 24, 2022.</p></footer></article></body></html>